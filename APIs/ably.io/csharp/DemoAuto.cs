//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ChannelDetails
	{
		
		/// <summary>
		/// The required name of the channel including any qualifier, if any.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ChannelId { get; set; }
		
		/// <summary>
		/// In events relating to the activity of a channel in a specific region, this optionally identifies whether or not that region is responsible for global coordination of the channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsGlobalMaster { get; set; }
		
		/// <summary>
		/// In events relating to the activity of a channel in a specific region, this optionally identifies the region.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Region { get; set; }
		
		/// <summary>
		/// A ChannelStatus instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ChannelStatus Status { get; set; }
	}
	
	/// <summary>
	/// A ChannelStatus instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ChannelStatus
	{
		
		/// <summary>
		/// A required boolean value indicating whether the channel that is the subject of the event is active. For events indicating regional activity of a channel this indicates activity in that region, not global activity.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsActive { get; set; }
		
		/// <summary>
		/// An Occupancy instance indicating the occupancy of a channel. For events indicating regional activity of a channel this indicates activity in that region, not global activity.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Occupancy Occupancy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeviceDetails
	{
		
		/// <summary>
		/// Optional trusted client identifier for the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ClientId { get; set; }
		
		/// <summary>
		/// Secret value for the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DeviceSecret { get; set; }
		
		/// <summary>
		/// Form factor of the push device.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeviceDetailsFormFactor FormFactor { get; set; }
		
		/// <summary>
		/// Unique identifier for the device generated by the device itself.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Optional metadata object for this device. The metadata for a device may only be set by clients with push-admin privileges and will be used more extensively in the future with smart notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		/// <summary>
		/// Platform of the push device.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeviceDetailsPlatform Platform { get; set; }
		
		/// <summary>
		/// Push recipient details for a device.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Recipient Push.recipient { get; set; }
		
		/// <summary>
		/// the current state of the push device.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeviceDetailsPush.state Push.state { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DeviceDetailsFormFactor
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		phone = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tablet = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		desktop = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tv = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		watch = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		car = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		embedded = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DeviceDetailsPlatform
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ios = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		android = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DeviceDetailsPush.state
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 2,
	}
	
	/// <summary>
	/// Returned error from failed REST.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Error
	{
		
		/// <summary>
		/// Error code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// Link to help with error.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Href { get; set; }
		
		/// <summary>
		/// Message explaining the error's cause.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
		
		/// <summary>
		/// Server ID with which error was encountered.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Status error code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StatusCode { get; set; }
	}
	
	/// <summary>
	/// Extras object. Currently only allows for [push](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example) extra.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Extras
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Push Push { get; set; }
	}
	
	/// <summary>
	/// Message object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Message
	{
		
		/// <summary>
		/// The [client ID](https://www.ably.io/documentation/core-features/authentication#identified-clients) of the publisher of this message.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ClientId { get; set; }
		
		/// <summary>
		/// The connection ID of the publisher of this message.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ConnectionId { get; set; }
		
		/// <summary>
		/// The string encoded payload, with the encoding specified below.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Data { get; set; }
		
		/// <summary>
		/// This will typically be empty as all messages received from Ably are automatically decoded client-side using this value. However, if the message encoding cannot be processed, this attribute will contain the remaining transformations not applied to the data payload.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Encoding { get; set; }
		
		/// <summary>
		/// Extras object. Currently only allows for [push](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example) extra.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Extras Extras { get; set; }
		
		/// <summary>
		/// A Unique ID that can be specified by the publisher for [idempotent publishing](https://www.ably.io/documentation/rest/messages#idempotent).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// The event name, if provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Timestamp when the message was received by the Ably, as milliseconds since the epoch.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> Timestamp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Notification
	{
		
		/// <summary>
		/// Text below title on the expanded notification.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Body { get; set; }
		
		/// <summary>
		/// Platform-specific, used to group notifications together.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CollapseKey { get; set; }
		
		/// <summary>
		/// Platform-specific icon for the notification.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Icon { get; set; }
		
		/// <summary>
		/// Platform-specific sound for the notification.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Sound { get; set; }
		
		/// <summary>
		/// Title to display at the notification.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// An Occupancy instance indicating the occupancy of a channel. For events indicating regional activity of a channel this indicates activity in that region, not global activity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Occupancy
	{
		
		/// <summary>
		/// The number of connections that are authorised to enter members into the presence channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PresenceConnections { get; set; }
		
		/// <summary>
		/// The number of members currently entered into the presence channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PresenceMembers { get; set; }
		
		/// <summary>
		/// The number of connections that are authorised to subscribe to presence messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PresenceSubscribers { get; set; }
		
		/// <summary>
		/// The number of connections attached to the channel that are authorised to publish.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Publishers { get; set; }
		
		/// <summary>
		/// The number of connections attached that are authorised to subscribe to messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Subscribers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PresenceMessage
	{
		
		/// <summary>
		/// The event signified by a PresenceMessage.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PresenceMessageAction Action { get; set; }
		
		/// <summary>
		/// The client ID of the publisher of this presence update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ClientId { get; set; }
		
		/// <summary>
		/// The connection ID of the publisher of this presence update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ConnectionId { get; set; }
		
		/// <summary>
		/// The presence update payload, if provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Data { get; set; }
		
		/// <summary>
		/// This will typically be empty as all presence updates received from Ably are automatically decoded client-side using this value. However, if the message encoding cannot be processed, this attribute will contain the remaining transformations not applied to the data payload.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Encoding { get; set; }
		
		/// <summary>
		/// Extras object. Currently only allows for [push](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example) extra.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Extras Extras { get; set; }
		
		/// <summary>
		/// Unique ID assigned by Ably to this presence update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Timestamp when the presence update was received by Ably, as milliseconds since the epoch.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> Timestamp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PresenceMessageAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABSENT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRESENT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENTER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LEAVE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATE = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Push
	{
		
		/// <summary>
		/// Extends and overrides generic values when delivering via APNs. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Apns { get; set; }
		
		/// <summary>
		/// Arbitrary [key-value string-to-string payload](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Data { get; set; }
		
		/// <summary>
		/// Extends and overrides generic values when delivering via GCM/FCM. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Fcm { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Notification Notification { get; set; }
		
		/// <summary>
		/// Extends and overrides generic values when delivering via web. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Web { get; set; }
	}
	
	/// <summary>
	/// Push recipient details for a device.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Recipient
	{
		
		/// <summary>
		/// Client ID of recipient
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ClientId { get; set; }
		
		/// <summary>
		/// Client ID of recipient
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DeviceId { get; set; }
		
		/// <summary>
		/// when using APNs, specifies the required device token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DeviceToken { get; set; }
		
		/// <summary>
		/// when using GCM or FCM, specifies the required registration token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RegistrationToken { get; set; }
		
		/// <summary>
		/// Defines which push platform is being used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RecipientTransportType TransportType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RecipientTransportType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		apns = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fcm = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		gcm = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SignedTokenRequest : TokenRequest
	{
		
		/// <summary>
		/// A signature, generated as an HMAC of each of the above components, using the key secret value.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Mac { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TokenDetails
	{
		
		/// <summary>
		/// Regular expression representation of the capabilities of the token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Capability { get; set; }
		
		/// <summary>
		/// Timestamp of token expiration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Expires { get; set; }
		
		/// <summary>
		/// Timestamp of token creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Issued { get; set; }
		
		/// <summary>
		/// Name of the key used to create the token
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string KeyName { get; set; }
		
		/// <summary>
		/// The Ably Token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Token { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TokenRequest
	{
		
		/// <summary>
		/// The [capabilities](https://www.ably.io/documentation/core-features/authentication#capabilities-explained) (i.e. a set of channel names/namespaces and, for each, a set of operations) which should be a subset of the set of capabilities associated with the key specified in keyName.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Capability { get; set; }
		
		/// <summary>
		/// The [client ID](https://www.ably.io/documentation/core-features/authentication#identified-clients) to be assosciated with the token. Can be set to * to allow for any client ID to be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ClientId { get; set; }
		
		/// <summary>
		/// Name of the key used for the TokenRequest. The keyName comprises of the app ID and key ID on an API Key.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string KeyName { get; set; }
		
		/// <summary>
		/// An unquoted, un-escaped random string of at least 16 characters. Used to ensure the Ably TokenRequest cannot be reused.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Nonce { get; set; }
		
		/// <summary>
		/// Time of creation of the Ably TokenRequest.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Timestamp { get; set; }
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Enumerate all active channels of the application
		/// Enumerate all active channels of the application
		/// GetMetadataOfAllChannels channels
		/// </summary>
		/// <param name="prefix">Optionally limits the query to only those channels whose name starts with the given prefix</param>
		/// <param name="by">optionally specifies whether to return just channel names (by=id) or ChannelDetails (by=value)</param>
		public async Task GetMetadataOfAllChannelsAsync(int limit, string prefix, string by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels?limit="+limit+"&prefix=" + (prefix==null? "" : Uri.EscapeDataString(prefix))+"&by=" + (by==null? "" : Uri.EscapeDataString(by));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get metadata of a channel
		/// Get metadata of a channel
		/// GetMetadataOfChannel channels/{channel_id}
		/// </summary>
		/// <param name="channel_id">The [Channel's ID](https://www.ably.io/documentation/rest/channels).</param>
		/// <returns>OK</returns>
		public async Task<ChannelDetails> GetMetadataOfChannelAsync(string channel_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channel_id==null? "" : Uri.EscapeDataString(channel_id));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ChannelDetails>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get message history for a channel
		/// Get message history for a channel
		/// GetMessagesByChannel channels/{channel_id}/messages
		/// </summary>
		/// <param name="channel_id">The [Channel's ID](https://www.ably.io/documentation/rest/channels).</param>
		public async Task GetMessagesByChannelAsync(string channel_id, string start, int limit, string end, string direction, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channel_id==null? "" : Uri.EscapeDataString(channel_id))+"/messages&start=" + (start==null? "" : Uri.EscapeDataString(start))+"&limit="+limit+"&end=" + (end==null? "" : Uri.EscapeDataString(end))+"&direction=" + (direction==null? "" : Uri.EscapeDataString(direction));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Publish a message to a channel
		/// Publish a message to the specified channel
		/// PublishMessagesToChannel channels/{channel_id}/messages
		/// </summary>
		/// <param name="channel_id">The [Channel's ID](https://www.ably.io/documentation/rest/channels).</param>
		public async Task PublishMessagesToChannelAsync(string channel_id, Message requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channel_id==null? "" : Uri.EscapeDataString(channel_id))+"/messages";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get presence of a channel
		/// Get presence on a channel
		/// GetPresenceOfChannel channels/{channel_id}/presence
		/// </summary>
		/// <param name="channel_id">The [Channel's ID](https://www.ably.io/documentation/rest/channels).</param>
		/// <returns>OK</returns>
		public async Task<PresenceMessage[]> GetPresenceOfChannelAsync(string channel_id, string clientId, string connectionId, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channel_id==null? "" : Uri.EscapeDataString(channel_id))+"/presence&clientId=" + (clientId==null? "" : Uri.EscapeDataString(clientId))+"&connectionId=" + (connectionId==null? "" : Uri.EscapeDataString(connectionId))+"&limit="+limit;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PresenceMessage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get presence history of a channel
		/// Get presence on a channel
		/// GetPresenceHistoryOfChannel channels/{channel_id}/presence/history
		/// </summary>
		/// <param name="channel_id">The [Channel's ID](https://www.ably.io/documentation/rest/channels).</param>
		public async Task GetPresenceHistoryOfChannelAsync(string channel_id, string start, int limit, string end, string direction, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channel_id==null? "" : Uri.EscapeDataString(channel_id))+"/presence/history&start=" + (start==null? "" : Uri.EscapeDataString(start))+"&limit="+limit+"&end=" + (end==null? "" : Uri.EscapeDataString(end))+"&direction=" + (direction==null? "" : Uri.EscapeDataString(direction));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request an access token
		/// This is the means by which clients obtain access tokens to use the service. You can see how to construct an Ably TokenRequest in the [Ably TokenRequest spec](https://www.ably.io/documentation/rest-api/token-request-spec) documentation, although we recommend you use an Ably SDK rather to create a TokenRequest, as the construction of a TokenRequest is complex. The resulting token response object contains the token properties as defined in Ably TokenRequest spec. Authentication is not required if using a Signed TokenRequest.
		/// RequestAccessToken keys/{keyName}/requestToken
		/// </summary>
		/// <param name="keyName">The [key name](https://www.ably.io/documentation/rest-api/token-request-spec#api-key-format) comprises of the app ID and key ID of an API key.</param>
		public async Task RequestAccessTokenAsync(string keyName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "keys/"+ (keyName==null? "" : Uri.EscapeDataString(keyName))+"/requestToken";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a registered device's update token
		/// Delete a device details object.
		/// DeletePushDeviceDetails push/channelSubscriptions
		/// </summary>
		/// <param name="channel">Filter to restrict to subscriptions associated with that channel.</param>
		/// <param name="deviceId">Must be set when clientId is empty, cannot be used with clientId.</param>
		/// <param name="clientId">Must be set when deviceId is empty, cannot be used with deviceId.</param>
		public async Task DeletePushDeviceDetailsAsync(string channel, string deviceId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/channelSubscriptions?channel=" + (channel==null? "" : Uri.EscapeDataString(channel))+"&deviceId=" + (deviceId==null? "" : Uri.EscapeDataString(deviceId))+"&clientId=" + (clientId==null? "" : Uri.EscapeDataString(clientId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List channel subscriptions
		/// Get a list of push notification subscriptions to channels.
		/// GetPushSubscriptionsOnChannels push/channelSubscriptions
		/// </summary>
		/// <param name="channel">Filter to restrict to subscriptions associated with that channel.</param>
		/// <param name="deviceId">Optional filter to restrict to devices associated with that deviceId. Cannot be used with clientId.</param>
		/// <param name="clientId">Optional filter to restrict to devices associated with that clientId. Cannot be used with deviceId.</param>
		/// <param name="limit">The maximum number of records to return.</param>
		public async Task GetPushSubscriptionsOnChannelsAsync(string channel, string deviceId, string clientId, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/channelSubscriptions?channel=" + (channel==null? "" : Uri.EscapeDataString(channel))+"&deviceId=" + (deviceId==null? "" : Uri.EscapeDataString(deviceId))+"&clientId=" + (clientId==null? "" : Uri.EscapeDataString(clientId))+"&limit="+limit;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Subscribe a device to a channel
		/// Subscribe either a single device or all devices associated with a client ID to receive push notifications from messages sent to a channel.
		/// SubscribePushDeviceToChannel push/channelSubscriptions
		/// </summary>
		public async Task SubscribePushDeviceToChannelAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/channelSubscriptions";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all channels with at least one subscribed device
		/// Returns a paginated response of channel names.
		/// GetChannelsWithPushSubscribers push/channels
		/// </summary>
		public async Task GetChannelsWithPushSubscribersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/channels";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unregister matching devices for push notifications
		/// Unregisters devices. All their subscriptions for receiving push notifications through channels will also be deleted.
		/// UnregisterAllPushDevices push/deviceRegistrations
		/// </summary>
		/// <param name="deviceId">Optional filter to restrict to devices associated with that deviceId. Cannot be used with clientId.</param>
		/// <param name="clientId">Optional filter to restrict to devices associated with that clientId. Cannot be used with deviceId.</param>
		public async Task UnregisterAllPushDevicesAsync(string deviceId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/deviceRegistrations?deviceId=" + (deviceId==null? "" : Uri.EscapeDataString(deviceId))+"&clientId=" + (clientId==null? "" : Uri.EscapeDataString(clientId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List devices registered for receiving push notifications
		/// List of device details of devices registed for push notifications.
		/// GetRegisteredPushDevices push/deviceRegistrations
		/// </summary>
		/// <param name="deviceId">Optional filter to restrict to devices associated with that deviceId.</param>
		/// <param name="clientId">Optional filter to restrict to devices associated with that clientId.</param>
		/// <param name="limit">The maximum number of records to return.</param>
		public async Task GetRegisteredPushDevicesAsync(string deviceId, string clientId, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/deviceRegistrations?deviceId=" + (deviceId==null? "" : Uri.EscapeDataString(deviceId))+"&clientId=" + (clientId==null? "" : Uri.EscapeDataString(clientId))+"&limit="+limit;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Register a device for receiving push notifications
		/// Register a device’s details, including the information necessary to deliver push notifications to it. Requires "push-admin" capability.
		/// RegisterPushDevice push/deviceRegistrations
		/// </summary>
		public async Task RegisterPushDeviceAsync(DeviceDetails requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/deviceRegistrations";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Unregister a single device for push notifications
		/// Unregisters a single device by its device ID. All its subscriptions for receiving push notifications through channels will also be deleted.
		/// UnregisterPushDevice push/deviceRegistrations/{device_id}
		/// </summary>
		/// <param name="device_id">Device's ID.</param>
		public async Task UnregisterPushDeviceAsync(string device_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/deviceRegistrations/"+ (device_id==null? "" : Uri.EscapeDataString(device_id));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a device registration
		/// Get the full details of a device.
		/// GetPushDeviceDetails push/deviceRegistrations/{device_id}
		/// </summary>
		/// <param name="device_id">Device's ID.</param>
		public async Task GetPushDeviceDetailsAsync(string device_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/deviceRegistrations/"+ (device_id==null? "" : Uri.EscapeDataString(device_id));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a device registration
		/// Device registrations can be upserted (the existing registration is replaced entirely) with a PUT operation. Only clientId, metadata and push.recipient are mutable.
		/// PutPushDeviceDetails push/deviceRegistrations/{device_id}
		/// </summary>
		/// <param name="device_id">Device's ID.</param>
		public async Task PutPushDeviceDetailsAsync(string device_id, DeviceDetails requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/deviceRegistrations/"+ (device_id==null? "" : Uri.EscapeDataString(device_id));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reset a registered device's update token
		/// Gets an updated device details object.
		/// UpdatePushDeviceDetails push/deviceRegistrations/{device_id}/resetUpdateToken
		/// </summary>
		/// <param name="device_id">Device's ID.</param>
		public async Task UpdatePushDeviceDetailsAsync(string device_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/deviceRegistrations/"+ (device_id==null? "" : Uri.EscapeDataString(device_id))+"/resetUpdateToken";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Publish a push notification to device(s)
		/// A convenience endpoint to deliver a push notification payload to a single device or set of devices identified by their client identifier.
		/// PublishPushNotificationToDevices push/publish
		/// </summary>
		public async Task PublishPushNotificationToDevicesAsync(PublishPushNotificationToDevicesBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "push/publish";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve usage statistics for an application
		/// The Ably system can be queried to obtain usage statistics for a given application, and results are provided aggregated across all channels in use in the application in the specified period. Stats may be used to track usage against account quotas.
		/// GetStats stats
		/// </summary>
		/// <param name="unit">Specifies the unit of aggregation in the returned results.</param>
		public async Task GetStatsAsync(string start, int limit, string end, string direction, string unit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "stats?start=" + (start==null? "" : Uri.EscapeDataString(start))+"&limit="+limit+"&end=" + (end==null? "" : Uri.EscapeDataString(end))+"&direction=" + (direction==null? "" : Uri.EscapeDataString(direction))+"&unit=" + (unit==null? "" : Uri.EscapeDataString(unit));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the service time
		/// This returns the service time in milliseconds since the epoch.
		/// GetTime time
		/// </summary>
		public async Task GetTimeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "time";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PublishPushNotificationToDevicesBody
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Push Push { get; set; }
		
		/// <summary>
		/// Push recipient details for a device.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Recipient Recipient { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
