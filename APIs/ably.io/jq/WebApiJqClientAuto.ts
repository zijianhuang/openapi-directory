///<reference path="HttpClient.ts" />
namespace My_Demo_Client {
	export interface ChannelDetails {

		/**The required name of the channel including any qualifier, if any. */
		channelId: string;

		/**In events relating to the activity of a channel in a specific region, this optionally identifies whether or not that region is responsible for global coordination of the channel. */
		isGlobalMaster?: boolean;

		/**In events relating to the activity of a channel in a specific region, this optionally identifies the region. */
		region?: string;

		/**A ChannelStatus instance. */
		status?: ChannelStatus;
	}


	/**A ChannelStatus instance. */
	export interface ChannelStatus {

		/**A required boolean value indicating whether the channel that is the subject of the event is active. For events indicating regional activity of a channel this indicates activity in that region, not global activity. */
		isActive: boolean;

		/**An Occupancy instance indicating the occupancy of a channel. For events indicating regional activity of a channel this indicates activity in that region, not global activity. */
		occupancy?: Occupancy;
	}

	export interface DeviceDetails {

		/**Optional trusted client identifier for the device. */
		clientId?: string;

		/**Secret value for the device. */
		deviceSecret?: string;

		/**Form factor of the push device. */
		formFactor?: DeviceDetailsFormFactor;

		/**Unique identifier for the device generated by the device itself. */
		id?: string;

		/**Optional metadata object for this device. The metadata for a device may only be set by clients with push-admin privileges and will be used more extensively in the future with smart notifications. */
		metadata?: string;

		/**Platform of the push device. */
		platform?: DeviceDetailsPlatform;

		/**Push recipient details for a device. */
		push.recipient?: Recipient;

		/**the current state of the push device. */
		push.state?: DeviceDetailsPush.state;
	}

	export enum DeviceDetailsFormFactor { phone = 0, tablet = 1, desktop = 2, tv = 3, watch = 4, car = 5, embedded = 6 }

	export enum DeviceDetailsPlatform { ios = 0, android = 1 }

	export enum DeviceDetailsPush.state { Active = 0, Failing = 1, Failed = 2 }


	/**Returned error from failed REST. */
	export interface Error {

		/**Error code. */
		code?: number;

		/**Link to help with error. */
		href?: string;

		/**Message explaining the error's cause. */
		message?: string;

		/**Server ID with which error was encountered. */
		serverId?: string;

		/**Status error code. */
		statusCode?: number;
	}


	/**Extras object. Currently only allows for [push](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example) extra. */
	export interface Extras {
		push?: Push;
	}


	/**Message object. */
	export interface Message {

		/**The [client ID](https://www.ably.io/documentation/core-features/authentication#identified-clients) of the publisher of this message. */
		clientId?: string;

		/**The connection ID of the publisher of this message. */
		connectionId?: string;

		/**The string encoded payload, with the encoding specified below. */
		data?: string;

		/**This will typically be empty as all messages received from Ably are automatically decoded client-side using this value. However, if the message encoding cannot be processed, this attribute will contain the remaining transformations not applied to the data payload. */
		encoding?: string;

		/**Extras object. Currently only allows for [push](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example) extra. */
		extras?: Extras;

		/**A Unique ID that can be specified by the publisher for [idempotent publishing](https://www.ably.io/documentation/rest/messages#idempotent). */
		id?: string;

		/**The event name, if provided. */
		name?: string;

		/**Timestamp when the message was received by the Ably, as milliseconds since the epoch. */
		timestamp?: number;
	}

	export interface Notification {

		/**Text below title on the expanded notification. */
		body?: string;

		/**Platform-specific, used to group notifications together. */
		collapseKey?: string;

		/**Platform-specific icon for the notification. */
		icon?: string;

		/**Platform-specific sound for the notification. */
		sound?: string;

		/**Title to display at the notification. */
		title?: string;
	}


	/**An Occupancy instance indicating the occupancy of a channel. For events indicating regional activity of a channel this indicates activity in that region, not global activity. */
	export interface Occupancy {

		/**The number of connections that are authorised to enter members into the presence channel. */
		presenceConnections?: number;

		/**The number of members currently entered into the presence channel. */
		presenceMembers?: number;

		/**The number of connections that are authorised to subscribe to presence messages. */
		presenceSubscribers?: number;

		/**The number of connections attached to the channel that are authorised to publish. */
		publishers?: number;

		/**The number of connections attached that are authorised to subscribe to messages. */
		subscribers?: number;
	}

	export interface PresenceMessage {

		/**The event signified by a PresenceMessage. */
		action?: PresenceMessageAction;

		/**The client ID of the publisher of this presence update. */
		clientId?: string;

		/**The connection ID of the publisher of this presence update. */
		connectionId?: string;

		/**The presence update payload, if provided. */
		data?: string;

		/**This will typically be empty as all presence updates received from Ably are automatically decoded client-side using this value. However, if the message encoding cannot be processed, this attribute will contain the remaining transformations not applied to the data payload. */
		encoding?: string;

		/**Extras object. Currently only allows for [push](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example) extra. */
		extras?: Extras;

		/**Unique ID assigned by Ably to this presence update. */
		id?: string;

		/**Timestamp when the presence update was received by Ably, as milliseconds since the epoch. */
		timestamp?: number;
	}

	export enum PresenceMessageAction { ABSENT = 0, PRESENT = 1, ENTER = 2, LEAVE = 3, UPDATE = 4 }

	export interface Push {

		/**Extends and overrides generic values when delivering via APNs. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure) */
		apns?: string;

		/**Arbitrary [key-value string-to-string payload](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example). */
		data?: string;

		/**Extends and overrides generic values when delivering via GCM/FCM. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure) */
		fcm?: string;
		notification?: Notification;

		/**Extends and overrides generic values when delivering via web. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure) */
		web?: string;
	}


	/**Push recipient details for a device. */
	export interface Recipient {

		/**Client ID of recipient */
		clientId?: string;

		/**Client ID of recipient */
		deviceId?: string;

		/**when using APNs, specifies the required device token. */
		deviceToken?: string;

		/**when using GCM or FCM, specifies the required registration token. */
		registrationToken?: string;

		/**Defines which push platform is being used. */
		transportType?: RecipientTransportType;
	}

	export enum RecipientTransportType { apns = 0, fcm = 1, gcm = 2 }

	export interface SignedTokenRequest extends TokenRequest {

		/**A signature, generated as an HMAC of each of the above components, using the key secret value. */
		mac: string;
	}

	export interface TokenDetails {

		/**Regular expression representation of the capabilities of the token. */
		capability?: string;

		/**Timestamp of token expiration. */
		expires?: number;

		/**Timestamp of token creation. */
		issued?: number;

		/**Name of the key used to create the token */
		keyName?: string;

		/**The Ably Token. */
		token?: string;
	}

	export interface TokenRequest {

		/**The [capabilities](https://www.ably.io/documentation/core-features/authentication#capabilities-explained) (i.e. a set of channel names/namespaces and, for each, a set of operations) which should be a subset of the set of capabilities associated with the key specified in keyName. */
		capability: string;

		/**The [client ID](https://www.ably.io/documentation/core-features/authentication#identified-clients) to be assosciated with the token. Can be set to * to allow for any client ID to be used. */
		clientId?: string;

		/**Name of the key used for the TokenRequest. The keyName comprises of the app ID and key ID on an API Key. */
		keyName: string;

		/**An unquoted, un-escaped random string of at least 16 characters. Used to ensure the Ably TokenRequest cannot be reused. */
		nonce: string;

		/**Time of creation of the Ably TokenRequest. */
		timestamp: number;
	}

	export class DemoClient {
		constructor(private baseUri: string = HttpClient.locationOrigin, private httpClient: HttpClientBase = new HttpClient(), private error?: (xhr: JQueryXHR, ajaxOptions: string, thrown: string) => any, private statusCode?: { [key: string]: any; }) {
		}

		/**
		 * Enumerate all active channels of the application
		 * Enumerate all active channels of the application
		 * Get channels
		 * @param {string} prefix Optionally limits the query to only those channels whose name starts with the given prefix
		 * @param {string} by optionally specifies whether to return just channel names (by=id) or ChannelDetails (by=value)
		 * @return {void} 
		 */
		GetMetadataOfAllChannels(limit: number, prefix: string, by: string, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'channels?limit=' + limit + '&prefix=' + (prefix == null ? '' : encodeURIComponent(prefix)) + '&by=' + (by == null ? '' : encodeURIComponent(by)), callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Get metadata of a channel
		 * Get metadata of a channel
		 * Get channels/{channel_id}
		 * @param {string} channel_id The [Channel's ID](https://www.ably.io/documentation/rest/channels).
		 * @return {ChannelDetails} OK
		 */
		GetMetadataOfChannel(channel_id: string, callback: (data : ChannelDetails) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'channels/' + (channel_id == null ? '' : encodeURIComponent(channel_id)), callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Get message history for a channel
		 * Get message history for a channel
		 * Get channels/{channel_id}/messages
		 * @param {string} channel_id The [Channel's ID](https://www.ably.io/documentation/rest/channels).
		 * @return {void} 
		 */
		GetMessagesByChannel(channel_id: string, start: string, limit: number, end: string, direction: string, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'channels/' + (channel_id == null ? '' : encodeURIComponent(channel_id)) + '/messages&start=' + (start == null ? '' : encodeURIComponent(start)) + '&limit=' + limit + '&end=' + (end == null ? '' : encodeURIComponent(end)) + '&direction=' + (direction == null ? '' : encodeURIComponent(direction)), callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Publish a message to a channel
		 * Publish a message to the specified channel
		 * Post channels/{channel_id}/messages
		 * @param {string} channel_id The [Channel's ID](https://www.ably.io/documentation/rest/channels).
		 * @return {void} 
		 */
		PublishMessagesToChannel(channel_id: string, callback: (data : void) => any, requestBody: Message, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.post(this.baseUri + 'channels/' + (channel_id == null ? '' : encodeURIComponent(channel_id)) + '/messages', requestBody, callback, this.error, this.statusCode, 'application/json;charset=UTF-8', headersHandler);
		}

		/**
		 * Get presence of a channel
		 * Get presence on a channel
		 * Get channels/{channel_id}/presence
		 * @param {string} channel_id The [Channel's ID](https://www.ably.io/documentation/rest/channels).
		 * @return {Array<PresenceMessage>} OK
		 */
		GetPresenceOfChannel(channel_id: string, clientId: string, connectionId: string, limit: number, callback: (data : Array<PresenceMessage>) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'channels/' + (channel_id == null ? '' : encodeURIComponent(channel_id)) + '/presence&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)) + '&connectionId=' + (connectionId == null ? '' : encodeURIComponent(connectionId)) + '&limit=' + limit, callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Get presence history of a channel
		 * Get presence on a channel
		 * Get channels/{channel_id}/presence/history
		 * @param {string} channel_id The [Channel's ID](https://www.ably.io/documentation/rest/channels).
		 * @return {void} 
		 */
		GetPresenceHistoryOfChannel(channel_id: string, start: string, limit: number, end: string, direction: string, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'channels/' + (channel_id == null ? '' : encodeURIComponent(channel_id)) + '/presence/history&start=' + (start == null ? '' : encodeURIComponent(start)) + '&limit=' + limit + '&end=' + (end == null ? '' : encodeURIComponent(end)) + '&direction=' + (direction == null ? '' : encodeURIComponent(direction)), callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Request an access token
		 * This is the means by which clients obtain access tokens to use the service. You can see how to construct an Ably TokenRequest in the [Ably TokenRequest spec](https://www.ably.io/documentation/rest-api/token-request-spec) documentation, although we recommend you use an Ably SDK rather to create a TokenRequest, as the construction of a TokenRequest is complex. The resulting token response object contains the token properties as defined in Ably TokenRequest spec. Authentication is not required if using a Signed TokenRequest.
		 * Post keys/{keyName}/requestToken
		 * @param {string} keyName The [key name](https://www.ably.io/documentation/rest-api/token-request-spec#api-key-format) comprises of the app ID and key ID of an API key.
		 * @return {void} 
		 */
		RequestAccessToken(keyName: string, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.post(this.baseUri + 'keys/' + (keyName == null ? '' : encodeURIComponent(keyName)) + '/requestToken', null, callback, this.error, this.statusCode, 'application/json;charset=UTF-8', headersHandler);
		}

		/**
		 * Delete a registered device's update token
		 * Delete a device details object.
		 * Delete push/channelSubscriptions
		 * @param {string} channel Filter to restrict to subscriptions associated with that channel.
		 * @param {string} deviceId Must be set when clientId is empty, cannot be used with clientId.
		 * @param {string} clientId Must be set when deviceId is empty, cannot be used with deviceId.
		 * @return {void} 
		 */
		DeletePushDeviceDetails(channel: string, deviceId: string, clientId: string, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.delete(this.baseUri + 'push/channelSubscriptions?channel=' + (channel == null ? '' : encodeURIComponent(channel)) + '&deviceId=' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)), callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * List channel subscriptions
		 * Get a list of push notification subscriptions to channels.
		 * Get push/channelSubscriptions
		 * @param {string} channel Filter to restrict to subscriptions associated with that channel.
		 * @param {string} deviceId Optional filter to restrict to devices associated with that deviceId. Cannot be used with clientId.
		 * @param {string} clientId Optional filter to restrict to devices associated with that clientId. Cannot be used with deviceId.
		 * @param {number} limit The maximum number of records to return.
		 * @return {void} 
		 */
		GetPushSubscriptionsOnChannels(channel: string, deviceId: string, clientId: string, limit: number, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'push/channelSubscriptions?channel=' + (channel == null ? '' : encodeURIComponent(channel)) + '&deviceId=' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)) + '&limit=' + limit, callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Subscribe a device to a channel
		 * Subscribe either a single device or all devices associated with a client ID to receive push notifications from messages sent to a channel.
		 * Post push/channelSubscriptions
		 * @return {void} 
		 */
		SubscribePushDeviceToChannel(callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.post(this.baseUri + 'push/channelSubscriptions', null, callback, this.error, this.statusCode, 'application/json;charset=UTF-8', headersHandler);
		}

		/**
		 * List all channels with at least one subscribed device
		 * Returns a paginated response of channel names.
		 * Get push/channels
		 * @return {void} 
		 */
		GetChannelsWithPushSubscribers(callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'push/channels', callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Unregister matching devices for push notifications
		 * Unregisters devices. All their subscriptions for receiving push notifications through channels will also be deleted.
		 * Delete push/deviceRegistrations
		 * @param {string} deviceId Optional filter to restrict to devices associated with that deviceId. Cannot be used with clientId.
		 * @param {string} clientId Optional filter to restrict to devices associated with that clientId. Cannot be used with deviceId.
		 * @return {void} 
		 */
		UnregisterAllPushDevices(deviceId: string, clientId: string, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.delete(this.baseUri + 'push/deviceRegistrations?deviceId=' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)), callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * List devices registered for receiving push notifications
		 * List of device details of devices registed for push notifications.
		 * Get push/deviceRegistrations
		 * @param {string} deviceId Optional filter to restrict to devices associated with that deviceId.
		 * @param {string} clientId Optional filter to restrict to devices associated with that clientId.
		 * @param {number} limit The maximum number of records to return.
		 * @return {void} 
		 */
		GetRegisteredPushDevices(deviceId: string, clientId: string, limit: number, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'push/deviceRegistrations?deviceId=' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)) + '&limit=' + limit, callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Register a device for receiving push notifications
		 * Register a device’s details, including the information necessary to deliver push notifications to it. Requires "push-admin" capability.
		 * Post push/deviceRegistrations
		 * @return {void} 
		 */
		RegisterPushDevice(callback: (data : void) => any, requestBody: DeviceDetails, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.post(this.baseUri + 'push/deviceRegistrations', requestBody, callback, this.error, this.statusCode, 'application/json;charset=UTF-8', headersHandler);
		}

		/**
		 * Unregister a single device for push notifications
		 * Unregisters a single device by its device ID. All its subscriptions for receiving push notifications through channels will also be deleted.
		 * Delete push/deviceRegistrations/{device_id}
		 * @param {string} device_id Device's ID.
		 * @return {void} 
		 */
		UnregisterPushDevice(device_id: string, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.delete(this.baseUri + 'push/deviceRegistrations/' + (device_id == null ? '' : encodeURIComponent(device_id)), callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Get a device registration
		 * Get the full details of a device.
		 * Get push/deviceRegistrations/{device_id}
		 * @param {string} device_id Device's ID.
		 * @return {void} 
		 */
		GetPushDeviceDetails(device_id: string, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'push/deviceRegistrations/' + (device_id == null ? '' : encodeURIComponent(device_id)), callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Update a device registration
		 * Device registrations can be upserted (the existing registration is replaced entirely) with a PUT operation. Only clientId, metadata and push.recipient are mutable.
		 * Put push/deviceRegistrations/{device_id}
		 * @param {string} device_id Device's ID.
		 * @return {void} 
		 */
		PutPushDeviceDetails(device_id: string, callback: (data : void) => any, requestBody: DeviceDetails, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.put(this.baseUri + 'push/deviceRegistrations/' + (device_id == null ? '' : encodeURIComponent(device_id)), requestBody, callback, this.error, this.statusCode, 'application/json;charset=UTF-8', headersHandler);
		}

		/**
		 * Reset a registered device's update token
		 * Gets an updated device details object.
		 * Get push/deviceRegistrations/{device_id}/resetUpdateToken
		 * @param {string} device_id Device's ID.
		 * @return {void} 
		 */
		UpdatePushDeviceDetails(device_id: string, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'push/deviceRegistrations/' + (device_id == null ? '' : encodeURIComponent(device_id)) + '/resetUpdateToken', callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Publish a push notification to device(s)
		 * A convenience endpoint to deliver a push notification payload to a single device or set of devices identified by their client identifier.
		 * Post push/publish
		 * @return {void} 
		 */
		PublishPushNotificationToDevices(callback: (data : void) => any, requestBody: PublishPushNotificationToDevicesBody, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.post(this.baseUri + 'push/publish', requestBody, callback, this.error, this.statusCode, 'application/json;charset=UTF-8', headersHandler);
		}

		/**
		 * Retrieve usage statistics for an application
		 * The Ably system can be queried to obtain usage statistics for a given application, and results are provided aggregated across all channels in use in the application in the specified period. Stats may be used to track usage against account quotas.
		 * Get stats
		 * @param {string} unit Specifies the unit of aggregation in the returned results.
		 * @return {void} 
		 */
		GetStats(start: string, limit: number, end: string, direction: string, unit: string, callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'stats?start=' + (start == null ? '' : encodeURIComponent(start)) + '&limit=' + limit + '&end=' + (end == null ? '' : encodeURIComponent(end)) + '&direction=' + (direction == null ? '' : encodeURIComponent(direction)) + '&unit=' + (unit == null ? '' : encodeURIComponent(unit)), callback, this.error, this.statusCode, headersHandler);
		}

		/**
		 * Get the service time
		 * This returns the service time in milliseconds since the epoch.
		 * Get time
		 * @return {void} 
		 */
		GetTime(callback: (data : void) => any, headersHandler?: () => {[header: string]: string}) {
			this.httpClient.get(this.baseUri + 'time', callback, this.error, this.statusCode, headersHandler);
		}
	}

	export interface PublishPushNotificationToDevicesBody {
		push?: Push;

		/**Push recipient details for a device. */
		recipient: Recipient;
	}

}

