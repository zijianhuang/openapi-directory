//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A login credential mapped to a user identity. For password credentials, the username to present for Basic auth is the user's username from the user record
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AccessCredential
	{
		
		/// <summary>
		/// The timestamp of creation of the credential
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Created_at { get; set; }
		
		/// <summary>
		/// The type of credential
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		public AccessCredentialType Type { get; set; }
		
		/// <summary>
		/// The credential value (e.g. the password)
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	public enum AccessCredentialType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		password = 0,
	}
	
	/// <summary>
	/// Account information
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Account
	{
		
		/// <summary>
		/// The timestamp when the account was created
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Optional email address associated with the account
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
		
		/// <summary>
		/// The timestamp of the last update to the account metadata itself (not users or creds)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// The account identifier, not updatable after creation
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// State of the account. Disabled accounts prevent member users from logging in, deleting accounts are disabled and pending deletion and will be removed once all owned resources are garbage collected by the system
		/// </summary>
		public AccountState State { get; set; }
		
		/// <summary>
		/// The user type (admin vs user). If not specified in a POST request, 'user' is default
		/// </summary>
		public AccountType Type { get; set; }
	}
	
	public enum AccountState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleting = 2,
	}
	
	public enum AccountType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		service = 2,
	}
	
	/// <summary>
	/// An account to create/add to the system. If already exists will return 400.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AccountCreationRequest
	{
		
		/// <summary>
		/// An optional email to associate with the account for contact purposes
		/// Pattern: [a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
		
		/// <summary>
		/// The account name to use. This will identify the account and must be globally unique in the system.
		/// Pattern: ^[a-zA-Z0-9][a-zA-Z0-9@.!#$+-=^_`~;]{1,126}[a-zA-Z0-9]$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A summary of account status
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AccountStatus
	{
		
		/// <summary>
		/// The status of the account
		/// </summary>
		public AccountStatusState State { get; set; }
	}
	
	public enum AccountStatusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
	}
	
	/// <summary>
	/// The result of adding a single digest to the archive
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnalysisArchiveAddResult
	{
		
		/// <summary>
		/// Details on the status, e.g. the error message
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Detail { get; set; }
		
		/// <summary>
		/// The image digest requested to be added
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Digest { get; set; }
		
		/// <summary>
		/// The status of the archive add operation. Typically either 'archived' or 'error'
		/// </summary>
		public AnalysisArchiveAddResultStatus Status { get; set; }
	}
	
	public enum AnalysisArchiveAddResultStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archived = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archiving = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		error = 2,
	}
	
	/// <summary>
	/// Summary of the transition rule set
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnalysisArchiveRulesSummary
	{
		
		/// <summary>
		/// The number of rules for this account
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// The newest last_updated timestamp from the set of rules
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
	}
	
	/// <summary>
	/// An image reference in the analysis archive for the purposes of loading analysis from the archive into th working set
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnalysisArchiveSource
	{
		
		/// <summary>
		/// The image digest identify the analysis. Archived analyses are based on digest, tag records are restored as analysis is restored.
		/// Pattern: ^sha256:[a-fA-F0-9]{64}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Digest { get; set; }
	}
	
	/// <summary>
	/// A summarization of the analysis archive, including size, counts, etc. This archive stores image analysis only, never the actual image content or layers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnalysisArchiveSummary
	{
		
		/// <summary>
		/// The timestamp of the most recent archived image
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// The total sum of all the bytes stored to the backing storage. Accounts for anchore-applied compression, but not compression by the underlying storage system.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Total_data_bytes { get; set; }
		
		/// <summary>
		/// The number of unique images (digests) in the archive
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Total_image_count { get; set; }
		
		/// <summary>
		/// The number of tag records (registry/repo:tag pull strings) in the archive. This may include repeated tags but will always have a unique tag->digest mapping per record.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Total_tag_count { get; set; }
	}
	
	/// <summary>
	/// A rule for auto-archiving image analysis by time and/or tag-history
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnalysisArchiveTransitionHistory
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Rule_id { get; set; }
		
		public AnalysisArchiveTransitionHistoryTransition Transition { get; set; }
		
		/// <summary>
		/// The task that created & updated this entry
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Transition_task_id { get; set; }
	}
	
	public enum AnalysisArchiveTransitionHistoryTransition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		delete = 1,
	}
	
	/// <summary>
	/// A rule for auto-archiving image analysis by time and/or tag-history
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnalysisArchiveTransitionRule
	{
		
		/// <summary>
		/// Matches if the analysis is strictly older than this number of days
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Analysis_age_days { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// A set of selection criteria to match an image by a tagged pullstring based on its components, with regex support in each field
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageSelector Selector { get; set; }
		
		/// <summary>
		/// True if the rule applies to all accounts in the system. This is only available to admin users to update/modify, but all users with permission to list rules can see them
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> System_global { get; set; }
		
		/// <summary>
		/// Number of images mapped to the tag that are newer
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Tag_versions_newer { get; set; }
		
		/// <summary>
		/// The type of transition to make. If "archive", then archive an image from the working set and remove it from the working set. If "delete", then match against archived images and delete from the archive if match.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		public AnalysisArchiveTransitionRuleTransition Transition { get; set; }
	}
	
	/// <summary>
	/// A set of selection criteria to match an image by a tagged pullstring based on its components, with regex support in each field
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImageSelector
	{
		
		/// <summary>
		/// The registry section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "docker.io"
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry { get; set; }
		
		/// <summary>
		/// The repository section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "anchore/anchore-engine"
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Repository { get; set; }
		
		/// <summary>
		/// The tag-only section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "latest"
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Tag { get; set; }
	}
	
	public enum AnalysisArchiveTransitionRuleTransition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		delete = 1,
	}
	
	/// <summary>
	/// A description of an anchore error code (name, description)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnchoreErrorCode
	{
		
		/// <summary>
		/// Description of the error code
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Error code name
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A unique image in the engine. May have multiple tags or references. Unique to an image content across registries or repositories.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnchoreImage
	{
		
		/// <summary>
		/// A state value for the current status of the analysis progress of the image
		/// </summary>
		public AnchoreImageAnalysis_status Analysis_status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Annotations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
		
		/// <summary>
		/// A metadata content record for a specific image, containing different content type entries
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageContent Image_content { get; set; }
		
		/// <summary>
		/// Details specific to an image reference and type such as tag and image source
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageDetail[] Image_detail { get; set; }
		
		/// <summary>
		/// State of the image
		/// </summary>
		public AnchoreImageImage_status Image_status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	public enum AnchoreImageAnalysis_status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_analyzed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analyzing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analyzed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analysis_failed = 3,
	}
	
	/// <summary>
	/// A metadata detail record for a specific image. Multiple detail records may map a single catalog image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImageDetail
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Dockerfile { get; set; }
		
		/// <summary>
		/// Full docker-pullable digest string including the registry url and repository necessary get the image
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Fulldigest { get; set; }
		
		/// <summary>
		/// Full docker-pullable tag string referencing the image
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Fulltag { get; set; }
		
		/// <summary>
		/// The parent Anchore Image record to which this detail maps
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Registry { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Repo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	public enum AnchoreImageImage_status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		inactive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 2,
	}
	
	/// <summary>
	/// A unique image in the engine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnchoreImageTagSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Analysis_status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Analyzed_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Fulltag { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentDigest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Tag_detected_at { get; set; }
	}
	
	/// <summary>
	/// Generic HTTP API error response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ApiErrorResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// Details structure for additional information about the error if available. Content and structure will be error specific.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Detail { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Error_type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// A summarization of the available archives, a place to for long-term storage of audit, analysis, or other data to remove it from the system's working set but keep it available.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ArchiveSummary
	{
		
		/// <summary>
		/// A summarization of the analysis archive, including size, counts, etc. This archive stores image analysis only, never the actual image content or layers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AnalysisArchiveSummary Images { get; set; }
		
		/// <summary>
		/// Summary of the transition rule set
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AnalysisArchiveRulesSummary Rules { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ArchivedAnalysis
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Analyzed_at { get; set; }
		
		/// <summary>
		/// User provided annotations as key-value pairs
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Annotations { get; set; }
		
		/// <summary>
		/// The size, in bytes, of the analysis archive file
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Archive_size_bytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The image digest (digest of the manifest describing the image, per docker spec)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
		
		/// <summary>
		/// List of tags associated with the image digest
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TagEntry[] Image_detail { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// The digest of a parent manifest (for manifest-list images)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentDigest { get; set; }
		
		/// <summary>
		/// The archival status
		/// </summary>
		public ArchivedAnalysisStatus Status { get; set; }
	}
	
	/// <summary>
	/// A docker-pullable tag value as well as deconstructed components
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagEntry
	{
		
		/// <summary>
		/// The timestamp at which the Anchore Engine detected this tag was mapped to the image digest. Does not necessarily indicate when the tag was actually pushed to the registry.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Detected_at { get; set; }
		
		/// <summary>
		/// The pullable string for the tag. E.g. "docker.io/library/node:latest"
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Pullstring { get; set; }
		
		/// <summary>
		/// The registry hostname:port section of the pull string
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry { get; set; }
		
		/// <summary>
		/// The repository section of the pull string
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Repository { get; set; }
		
		/// <summary>
		/// The tag-only section of the pull string
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Tag { get; set; }
	}
	
	public enum ArchivedAnalysisStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archiving = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archived = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleting = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleted = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CVSSV2Scores
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> Base_score { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> Exploitability_score { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> Impact_score { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CVSSV3Scores
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> Base_score { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> Exploitability_score { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> Impact_score { get; set; }
	}
	
	/// <summary>
	/// File content listings from images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ContentFilesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ContentFilesResponseContent[] ContentFilesResponseContent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
	}
	
	public class ContentFilesResponseContent
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Filename { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Gid { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Linkdest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Sha256 { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Uid { get; set; }
	}
	
	/// <summary>
	/// Java package content listings from images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ContentJAVAPackageResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ContentJAVAPackageResponseContent[] ContentJAVAPackageResponseContent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
	}
	
	public class ContentJAVAPackageResponseContent
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Implementation-version { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Location { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Maven-version { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Origin { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Package { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Specification-version { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Package content listings from images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ContentPackageResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ContentPackageResponseContent[] ContentPackageResponseContent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
	}
	
	public class ContentPackageResponseContent
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string License { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Location { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Origin { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Package { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Size { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Generic wrapper for content listings from images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ContentResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
	}
	
	/// <summary>
	/// A collection of event subcategories
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EventCategory
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Category { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EventSubcategory[] Subcategories { get; set; }
	}
	
	/// <summary>
	/// A collection of events related to each other
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EventSubcategory
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EventDescription[] Events { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A description of an event type
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EventDescription
	{
		
		/// <summary>
		/// The message associated with the event type
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
		
		/// <summary>
		/// The event type. The last component of the fully-qualified event_type (category.subcategory.event)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The type of resource this event is generated from
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Resource_type { get; set; }
		
		/// <summary>
		/// The fully qualified event type as would be seen in the event payload
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A record of occurance of an asynchronous event triggered either by system or by user activity
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EventResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Event { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Generated_uuid { get; set; }
	}
	
	/// <summary>
	/// Response envelope for paginated listing of events
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EventsList
	{
		
		/// <summary>
		/// Number of events in this page
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Item_count { get; set; }
		
		/// <summary>
		/// Boolean flag, True indicates there are more events and False otherwise
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Next_page { get; set; }
		
		/// <summary>
		/// Page number of this result set
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Page { get; set; }
		
		/// <summary>
		/// List of events
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public EventResponse[] Results { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FeedGroupMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_sync { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Record_count { get; set; }
	}
	
	/// <summary>
	/// Metadata on a single feed based on what the engine finds from querying the endpoints
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FeedMetadata
	{
		
		/// <summary>
		/// Date the metadata record was created in engine (first seen on source)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FeedGroupMetadata[] Groups { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_full_sync { get; set; }
		
		/// <summary>
		/// name of the feed
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Date the metadata was last updated
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	/// <summary>
	/// The result of a sync of a single feed
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FeedSyncResult
	{
		
		/// <summary>
		/// The name of the feed synced
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Feed { get; set; }
		
		/// <summary>
		/// Array of group sync results
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GroupSyncResult[] Groups { get; set; }
		
		/// <summary>
		/// The result of the sync operations, either co
		/// </summary>
		public FeedSyncResultStatus Status { get; set; }
		
		/// <summary>
		/// The duratin, in seconds, of the sync of the feed, the sum of all the group syncs
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> Total_time_seconds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GroupSyncResult
	{
		
		/// <summary>
		/// The name of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Group { get; set; }
		
		public GroupSyncResultStatus Status { get; set; }
		
		/// <summary>
		/// The duration of the group sync in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> Total_time_seconds { get; set; }
		
		/// <summary>
		/// The number of images updated by the this group sync, across all accounts. This is typically only non-zero for vulnerability feeds which update images' vulnerability results during the sync.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Updated_image_count { get; set; }
		
		/// <summary>
		/// The number of feed data records synced down as either updates or new records
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Updated_record_count { get; set; }
	}
	
	public enum GroupSyncResultStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 1,
	}
	
	public enum FeedSyncResultStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 1,
	}
	
	/// <summary>
	/// The retrieved file entry including content (b64 encoded)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FileContentSearchResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public RegexContentMatch[] Matches { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// Match of a named regex on a file
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RegexContentMatch
	{
		
		/// <summary>
		/// A list of line numbers in the file that matched the regex
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public int[] Lines { get; set; }
		
		/// <summary>
		/// The name associated with the regular expression
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The regular expression used for the match
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Regex { get; set; }
	}
	
	/// <summary>
	/// A description of the set of gates available in this engine and the triggers and parameters supported
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GateSpec
	{
		
		/// <summary>
		/// Description of the gate
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Gate name, as it would appear in a policy document
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// State of the gate and transitively all triggers it contains if not 'active'
		/// </summary>
		public GateSpecState State { get; set; }
		
		/// <summary>
		/// The name of another trigger that supercedes this on functionally if this is deprecated
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Superceded_by { get; set; }
		
		/// <summary>
		/// List of the triggers that can fire for this Gate
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TriggerSpec[] Triggers { get; set; }
	}
	
	public enum GateSpecState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deprecated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eol = 2,
	}
	
	/// <summary>
	/// Definition of a trigger and its parameters
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TriggerSpec
	{
		
		/// <summary>
		/// Trigger description for what it tests and when it will fire during evaluation
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Name of the trigger as it would appear in a policy document
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of parameters that are valid for this trigger
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TriggerParamSpec[] Parameters { get; set; }
		
		/// <summary>
		/// State of the trigger
		/// </summary>
		public TriggerSpecState State { get; set; }
		
		/// <summary>
		/// The name of another trigger that supercedes this on functionally if this is deprecated
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Superceded_by { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TriggerParamSpec
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// An example value for the parameter (encoded as a string if the parameter is an object or list type)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Example { get; set; }
		
		/// <summary>
		/// Parameter name as it appears in policy document
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Is this a required parameter or optional
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Required { get; set; }
		
		/// <summary>
		/// State of the trigger parameter
		/// </summary>
		public TriggerParamSpecState State { get; set; }
		
		/// <summary>
		/// The name of another trigger that supercedes this on functionally if this is deprecated
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Superceded_by { get; set; }
		
		/// <summary>
		/// If present, a definition for validation of input. Typically a jsonschema object that can be used to validate an input against.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Validator { get; set; }
	}
	
	public enum TriggerParamSpecState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deprecated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eol = 2,
	}
	
	public enum TriggerSpecState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deprecated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eol = 2,
	}
	
	/// <summary>
	/// A request to add an image to be watched and analyzed by the engine. Optionally include the dockerfile content. Either source, digest or tag must be present.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImageAnalysisRequest
	{
		
		/// <summary>
		/// Annotations to be associated with the added image in key/value form
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Annotations { get; set; }
		
		/// <summary>
		/// Optional override of the image creation time, only honored when both tag and digest are also supplied  e.g. 2018-10-17T18:14:00Z. Deprecated in favor of the 'source' field
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// A digest string for an image, maybe a pull string or just a digest. e.g. nginx@sha256:123 or sha256:abc123. If a pull string, it must have same regisry/repo as the tag field. Deprecated in favor of the 'source' field
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Digest { get; set; }
		
		/// <summary>
		/// Base64 encoded content of the dockerfile for the image, if available. Deprecated in favor of the 'source' field.
		/// Pattern: ^[a-zA-Z0-9+/=]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Dockerfile { get; set; }
		
		/// <summary>
		/// Optional. The type of image this is adding, defaults to "docker". This can be ommitted until multiple image types are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Image_type { get; set; }
		
		/// <summary>
		/// A set of analysis source types. Only one may be set in any given request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageSource Source { get; set; }
		
		/// <summary>
		/// Full pullable tag reference for image. e.g. docker.io/nginx:latest. Deprecated in favor of the 'source' field
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Tag { get; set; }
	}
	
	/// <summary>
	/// A set of analysis source types. Only one may be set in any given request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImageSource
	{
		
		/// <summary>
		/// An image reference in the analysis archive for the purposes of loading analysis from the archive into th working set
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AnalysisArchiveSource Archive { get; set; }
		
		/// <summary>
		/// An image reference using a digest in a registry, includes some extra tag and timestamp info in addition to the pull string to allow proper tag history reconstruction.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RegistryDigestSource Digest { get; set; }
		
		/// <summary>
		/// An image reference using a tag in a registry, this is the most common source type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RegistryTagSource Tag { get; set; }
	}
	
	/// <summary>
	/// An image reference using a digest in a registry, includes some extra tag and timestamp info in addition to the pull string to allow proper tag history reconstruction.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RegistryDigestSource
	{
		
		/// <summary>
		/// Optional override of the image creation time to support proper tag history construction in cases of out-of-order analysis compared to registry history for the tag
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset Creation_timestamp_override { get; set; }
		
		/// <summary>
		/// Base64 encoded content of the dockerfile used to build the image, if available.
		/// Pattern: ^[a-zA-Z0-9+/=]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Dockerfile { get; set; }
		
		/// <summary>
		/// A digest-based pullstring (e.g. docker.io/nginx@sha256:123abc)
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Pullstring { get; set; }
		
		/// <summary>
		/// A docker pull string (e.g. docker.io/nginx:latest, or docker.io/nginx@sha256:abd) to retrieve the image
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Tag { get; set; }
	}
	
	/// <summary>
	/// An image reference using a tag in a registry, this is the most common source type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RegistryTagSource
	{
		
		/// <summary>
		/// Base64 encoded content of the dockerfile used to build the image, if available.
		/// Pattern: ^[a-zA-Z0-9+/=]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Dockerfile { get; set; }
		
		/// <summary>
		/// A docker pull string (e.g. docker.io/nginx:latest, or docker.io/nginx@sha256:abd) to retrieve the image
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Pullstring { get; set; }
	}
	
	/// <summary>
	/// Filter for an image list by id, tag, or digest, but not both
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImageFilter
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Digest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Tag { get; set; }
	}
	
	/// <summary>
	/// A reference to an image
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImageRef
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ImageRefType Type { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	public enum ImageRefType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tag = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		digest = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		id = 2,
	}
	
	/// <summary>
	/// A summary of an image identity, including digest, id (if available), and any tags known to have ever been mapped to the digest
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImageReference
	{
		
		/// <summary>
		/// Timestamp, in rfc3339 format, indicating when the image state became 'analyzed' in Anchore Engine.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Analyzed_at { get; set; }
		
		/// <summary>
		/// The image digest
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Digest { get; set; }
		
		/// <summary>
		/// The image id if available
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TagEntry[] Tag_history { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImageSelectionRule
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// A reference to an image
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ImageRef Image { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Registry { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Repository { get; set; }
	}
	
	/// <summary>
	/// An image record that contains packages
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImageWithPackages
	{
		
		/// <summary>
		/// A summary of an image identity, including digest, id (if available), and any tags known to have ever been mapped to the digest
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageReference Image { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PackageReference[] Packages { get; set; }
	}
	
	/// <summary>
	/// A record of a software item which is vulnerable or carries a fix for a vulnerability
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PackageReference
	{
		
		/// <summary>
		/// Package name
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Package type (e.g. package, rpm, deb, apk, jar, npm, gem, ...)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
		
		/// <summary>
		/// A version for the package. If null, then references all versions
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MappingRule
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// A reference to an image
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ImageRef Image { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Optional single policy to evalute, if set will override any value in policy_ids, for backwards compatibility. Generally, policy_ids should be used even with a array of length 1.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Policy_id { get; set; }
		
		/// <summary>
		/// List of policyIds to evaluate in order, to completion
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Policy_ids { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Registry { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Repository { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Whitelist_ids { get; set; }
	}
	
	/// <summary>
	/// Generic wrapper for metadata listings from images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MetadataResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata_type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class NvdDataObject
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CVSSV2Scores Cvss_v2 { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CVSSV3Scores Cvss_v3 { get; set; }
		
		/// <summary>
		/// NVD Vulnerability ID
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Pagination wrapped list of images that match some filter
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PaginatedImageList : PaginationProperties
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ImageWithPackages[] Images { get; set; }
	}
	
	/// <summary>
	/// A paginated listing of vulnerability records sorted by ID in descending order
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PaginatedVulnerabilityList : PaginationProperties
	{
		
		/// <summary>
		/// The listing of matching vulnerabilities for the query subject to pagination
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public StandaloneVulnerability[] Vulnerabilities { get; set; }
	}
	
	/// <summary>
	/// A single vulnerability record in a single namespace, the unique key is the combinatino of the id and namespace
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StandaloneVulnerability
	{
		
		/// <summary>
		/// The array of packages (typically packages) that are vulnerable-to or provide fixes-for this vulnerability
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PackageReference[] Affected_packages { get; set; }
		
		/// <summary>
		/// Vulnerability identifier. May be CVE-X, RHSA-X, etc. Not necessarily unique across namespaces
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// URL for the upstream CVE record in the reporting source (e.g. ubuntu security tracker)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Link { get; set; }
		
		/// <summary>
		/// The namespace for the vulnerability record to avoid conflicts for the same id in different distros or sources (e.g. deb vs ubuntu for same CVE)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Namespace { get; set; }
		
		/// <summary>
		/// List of Nvd Data objects
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NvdDataObject[] Nvd_data { get; set; }
		
		/// <summary>
		/// Severity label specific to the namepsace
		/// </summary>
		public StandaloneVulnerabilitySeverity Severity { get; set; }
		
		/// <summary>
		/// List of Vendor Data objects
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public VendorDataObject[] Vendor_data { get; set; }
	}
	
	public enum StandaloneVulnerabilitySeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Negligible = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Low = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Medium = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		High = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Critical = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VendorDataObject
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CVSSV2Scores Cvss_v2 { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CVSSV3Scores Cvss_v3 { get; set; }
		
		/// <summary>
		/// Vendor Vulnerability ID
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Pagination wrapped list of images with vulnerabilties that match some filter
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PaginatedVulnerableImageList : PaginationProperties
	{
		
		[System.Runtime.Serialization.DataMember()]
		public VulnerableImage[] Images { get; set; }
	}
	
	/// <summary>
	/// A record of an image vulnerable to some known vulnerability. Includes vulnerable package information
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VulnerableImage
	{
		
		[System.Runtime.Serialization.DataMember()]
		public VulnerablePackageReference[] Affected_packages { get; set; }
		
		/// <summary>
		/// A summary of an image identity, including digest, id (if available), and any tags known to have ever been mapped to the digest
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageReference Image { get; set; }
	}
	
	/// <summary>
	/// A record of a software item which is vulnerable or carries a fix for a vulnerability
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VulnerablePackageReference
	{
		
		/// <summary>
		/// Package name
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Vulnerability namespace of affected package
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Namespace { get; set; }
		
		/// <summary>
		/// Severity of vulnerability affecting package
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Severity { get; set; }
		
		/// <summary>
		/// Package type (e.g. package, rpm, deb, apk, jar, npm, gem, ...)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
		
		/// <summary>
		/// A version for the package. If null, then references all versions
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Properties for common pagination handling to be included in any wrapping object that needs pagination elements
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PaginationProperties
	{
		
		/// <summary>
		/// True if additional pages exist (page + 1) or False if this is the last page
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Next_page { get; set; }
		
		/// <summary>
		/// The page number returned (should match the requested page query string param)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Page { get; set; }
		
		/// <summary>
		/// The number of items sent in this response
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Returned_count { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Policy
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PolicyRule[] Rules { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// A rule that defines and decision value if the match is found true for a given image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PolicyRule
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PolicyRuleAction Action { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Gate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PolicyRuleParams[] PolicyRuleParams { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Trigger { get; set; }
	}
	
	public enum PolicyRuleAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GO = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WARN = 2,
	}
	
	public class PolicyRuleParams
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A bundle containing a set of policies, whitelists, and rules for mapping them to specific images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PolicyBundle
	{
		
		/// <summary>
		/// List of mapping rules that define which images should always result in a STOP/FAIL policy result regardless of policy content or presence in whitelisted_images
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageSelectionRule[] Blacklisted_images { get; set; }
		
		/// <summary>
		/// Description of the bundle, human readable
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		/// <summary>
		/// Id of the bundle
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Mapping rules for defining which policy and whitelist(s) to apply to an image based on a match of the image tag or id. Evaluated in order.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public MappingRule[] Mappings { get; set; }
		
		/// <summary>
		/// Human readable name for the bundle
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Policies which define the go/stop/warn status of an image using rule matches on image properties
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Policy[] Policies { get; set; }
		
		/// <summary>
		/// Version id for this bundle format
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
		
		/// <summary>
		/// List of mapping rules that define which images should always be passed (unless also on the blacklist), regardless of policy result.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageSelectionRule[] Whitelisted_images { get; set; }
		
		/// <summary>
		/// Whitelists which define which policy matches to disregard explicitly in the final policy decision
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Whitelist[] Whitelists { get; set; }
	}
	
	/// <summary>
	/// A collection of whitelist items to match a policy evaluation against.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Whitelist
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public WhitelistItem[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Identifies a specific gate and trigger match from a policy against an image and indicates it should be ignored in final policy decisions
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WhitelistItem
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Gate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Trigger_id { get; set; }
	}
	
	/// <summary>
	/// A policy bundle plus some metadata
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PolicyBundleRecord
	{
		
		/// <summary>
		/// True if the bundle is currently defined to be used automatically
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// The bundle's identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PolicyId { get; set; }
		
		/// <summary>
		/// Source location of where the policy bundle originated
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Policy_source { get; set; }
		
		/// <summary>
		/// A bundle containing a set of policies, whitelists, and rules for mapping them to specific images
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PolicyBundle Policybundle { get; set; }
		
		/// <summary>
		/// UserId of the user that owns the bundle
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	/// <summary>
	/// A registry entry describing the endpoint and credentials for a registry to pull images from
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RegistryConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_upated { get; set; }
		
		/// <summary>
		/// hostname:port string for accessing the registry, as would be used in a docker pull operation
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry { get; set; }
		
		/// <summary>
		/// human readable name associated with registry record
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry_name { get; set; }
		
		/// <summary>
		/// Type of registry
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry_type { get; set; }
		
		/// <summary>
		/// Username portion of credential to use for this registry
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry_user { get; set; }
		
		/// <summary>
		/// Use TLS/SSL verification for the registry URL
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Registry_verify { get; set; }
		
		/// <summary>
		/// Engine user that owns this registry entry
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	/// <summary>
	/// A registry record describing the endpoint and credentials for a registry
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RegistryConfigurationRequest
	{
		
		/// <summary>
		/// hostname:port string for accessing the registry, as would be used in a docker pull operation. May include some or all of a repository and wildcards (e.g. docker.io/library/* or gcr.io/myproject/myrepository)
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry { get; set; }
		
		/// <summary>
		/// human readable name associated with registry record
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry_name { get; set; }
		
		/// <summary>
		/// Password portion of credential to use for this registry
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry_pass { get; set; }
		
		/// <summary>
		/// Type of registry
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry_type { get; set; }
		
		/// <summary>
		/// Username portion of credential to use for this registry
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Registry_user { get; set; }
		
		/// <summary>
		/// Use TLS/SSL verification for the registry URL
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Registry_verify { get; set; }
	}
	
	/// <summary>
	/// The retrieved file entry including content (b64 encoded)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RetrievedFile
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string B64_content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// The retrieved file entry including content (b64 encoded)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SecretSearchResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public RegexContentMatch[] Matches { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// A service status record
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Service
	{
		
		/// <summary>
		/// The url to reach the service, including port as needed
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Base_url { get; set; }
		
		/// <summary>
		/// The unique id of the host on which the service is executing
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Hostid { get; set; }
		
		/// <summary>
		/// System status response
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public StatusResponse Service_detail { get; set; }
		
		/// <summary>
		/// Registered service name
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Servicename { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Status { get; set; }
		
		/// <summary>
		/// A state indicating the condition of the service. Normal operation is 'registered'
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Status_message { get; set; }
		
		/// <summary>
		/// The version of the service as reported by the service implementation on registration
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// System status response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StatusResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Available { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Busy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Db_version { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Detail { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Up { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Version information for a service
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ServiceVersion
	{
		
		/// <summary>
		/// Api Version string
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Api { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Db { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Service { get; set; }
	}
	
	/// <summary>
	/// Subscription entry
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Subscription
	{
		
		/// <summary>
		/// Is the subscription currently active
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// the unique id for this subscription record
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Subscription_id { get; set; }
		
		/// <summary>
		/// The key value that the subscription references. E.g. a tag value or a repo name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Subscription_key { get; set; }
		
		/// <summary>
		/// The type of the subscription
		/// </summary>
		public SubscriptionSubscription_type Subscription_type { get; set; }
		
		/// <summary>
		/// The value of the subscription target
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Subscription_value { get; set; }
		
		/// <summary>
		/// The userId of the subscribed user
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	public enum SubscriptionSubscription_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		policy_eval = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tag_update = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vuln_update = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		repo_update = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analysis_update = 4,
	}
	
	/// <summary>
	/// A subscription entry to add to the system
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SubscriptionRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Subscription_key { get; set; }
		
		public SubscriptionRequestSubscription_type Subscription_type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Subscription_value { get; set; }
	}
	
	public enum SubscriptionRequestSubscription_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		policy_eval = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tag_update = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vuln_update = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		repo_update = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analysis_update = 4,
	}
	
	/// <summary>
	/// A modification to a subscription entry to change its status or value
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SubscriptionUpdate
	{
		
		/// <summary>
		/// Toggle the subscription processing on or off
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The new subscription value, e.g. the new tag to be subscribed to
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Subscription_value { get; set; }
	}
	
	/// <summary>
	/// System status response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SystemStatusResponse
	{
		
		/// <summary>
		/// A list of service objects
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Service[] Service_states { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TokenResponse
	{
		
		/// <summary>
		/// The token content
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Token { get; set; }
	}
	
	/// <summary>
	/// A username for authenticating with one or more types of credentials. User type defines the expected credentials allowed for the user. Native users have passwords, External users have no credential internally. Internal users are service/system users for inter-service communication.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class User
	{
		
		/// <summary>
		/// The timestampt the user record was created
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The timestamp of the last update to this record
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// If the user is external, this is the source that the user was initialized from. All other user types have this set to null
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Source { get; set; }
		
		/// <summary>
		/// The user's type
		/// </summary>
		public UserType Type { get; set; }
		
		/// <summary>
		/// The username to authenticate with
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Username { get; set; }
	}
	
	public enum UserType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		native = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		@internal = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		external = 2,
	}
	
	/// <summary>
	/// A payload for creating a new user, includes the username and password in a single request
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UserCreationRequest
	{
		
		/// <summary>
		/// The initial password for the user, must be at least 6 characters, up to 128
		/// Pattern: .{6,128}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Password { get; set; }
		
		/// <summary>
		/// The username to create
		/// Pattern: ^[a-zA-Z0-9][a-zA-Z0-9@.!#$+-=^_`~;]{1,126}[a-zA-Z0-9]$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Vulnerability
	{
		
		/// <summary>
		/// The name of the feed where vulnerability match was made
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Feed { get; set; }
		
		/// <summary>
		/// The name of the feed group where vulnerability match was made
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Feed_group { get; set; }
		
		/// <summary>
		/// The package containing a fix, if available
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Fix { get; set; }
		
		/// <summary>
		/// List of Nvd Data objects
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NvdDataObject[] Nvd_data { get; set; }
		
		/// <summary>
		/// The package name and version that are vulnerable in the image
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Package { get; set; }
		
		/// <summary>
		/// The CPE string (if applicable) describing the package to vulnerability match
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Package_cpe { get; set; }
		
		/// <summary>
		/// The name of the vulnerable package artifact
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Package_name { get; set; }
		
		/// <summary>
		/// The location (if applicable) of the vulnerable package in the container filesystem
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Package_path { get; set; }
		
		/// <summary>
		/// The type of vulnerable package
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Package_type { get; set; }
		
		/// <summary>
		/// The version of the vulnerable package artifact
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Package_version { get; set; }
		
		/// <summary>
		/// The severity of the vulnerability
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Severity { get; set; }
		
		/// <summary>
		/// The url for more information about the vulnerability
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
		
		/// <summary>
		/// List of Vendor Data objects
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public VendorDataObject[] Vendor_data { get; set; }
		
		/// <summary>
		/// The vulnerability identifier, such as CVE-2017-100, or RHSA-2017123
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Vuln { get; set; }
	}
	
	/// <summary>
	/// envelope containing list of vulnerabilities
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VulnerabilityResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageDigest { get; set; }
		
		/// <summary>
		/// List of Vulnerability objects
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Vulnerability[] Vulnerabilities { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Vulnerability_type { get; set; }
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Simple status check
		/// Ping 
		/// </summary>
		/// <returns>Version check response, returns the api version prefix (e.g. 'v1')</returns>
		public async Task<string> PingAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the account for the authenticated user
		/// Get_users_account account
		/// </summary>
		/// <returns>User details for caller's user</returns>
		public async Task<Account> Get_users_accountAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Account>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List user summaries. Only available to the system admin user.
		/// List_accounts accounts
		/// </summary>
		/// <param name="state">Filter accounts by state</param>
		/// <returns>Accound summary listing</returns>
		public async Task<Account[]> List_accountsAsync(string state, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts?state=" + (state==null? "" : Uri.EscapeDataString(state));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Account[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new user. Only avaialble to admin user.
		/// Create_account accounts
		/// </summary>
		/// <returns>Account Record</returns>
		public async Task<Account> Create_accountAsync(AccountCreationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Account>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete the specified account, only allowed if the account is in the disabled state. All users will be deleted along with the account and all resources will be garbage collected
		/// Delete_account accounts/{accountname}
		/// </summary>
		public async Task Delete_accountAsync(string accountname, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : Uri.EscapeDataString(accountname));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get info about an user. Only available to admin user. Uses the main user Id, not a username.
		/// Get_account accounts/{accountname}
		/// </summary>
		/// <returns>Get user information</returns>
		public async Task<Account> Get_accountAsync(string accountname, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : Uri.EscapeDataString(accountname));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Account>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the state of an account to either enabled or disabled. For deletion use the DELETE route
		/// Update_account_state accounts/{accountname}/state
		/// </summary>
		/// <returns>Updated state of the account</returns>
		public async Task<AccountStatus> Update_account_stateAsync(string accountname, AccountStatus requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : Uri.EscapeDataString(accountname))+"/state";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AccountStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List accounts for the user
		/// List_users accounts/{accountname}/users
		/// </summary>
		/// <returns>User listing</returns>
		public async Task<User[]> List_usersAsync(string accountname, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : Uri.EscapeDataString(accountname))+"/users";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<User[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new user
		/// Create_user accounts/{accountname}/users
		/// </summary>
		/// <returns>Credential summary</returns>
		public async Task<User> Create_userAsync(string accountname, UserCreationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : Uri.EscapeDataString(accountname))+"/users";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a specific user credential by username of the credential. Cannot be the credential used to authenticate the request.
		/// Delete_user accounts/{accountname}/users/{username}
		/// </summary>
		public async Task Delete_userAsync(string accountname, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : Uri.EscapeDataString(accountname))+"/users/"+ (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific user in the specified account
		/// Get_account_user accounts/{accountname}/users/{username}
		/// </summary>
		/// <returns>User record</returns>
		public async Task<User> Get_account_userAsync(string accountname, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : Uri.EscapeDataString(accountname))+"/users/"+ (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a credential by type
		/// Delete_user_credential accounts/{accountname}/users/{username}/credentials
		/// </summary>
		public async Task Delete_user_credentialAsync(string accountname, string username, AccessCredentialType credential_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : Uri.EscapeDataString(accountname))+"/users/"+ (username==null? "" : Uri.EscapeDataString(username))+"/credentials&credential_type=" + credential_type;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get current credential summary
		/// List_user_credentials accounts/{accountname}/users/{username}/credentials
		/// </summary>
		/// <returns>User credential listing</returns>
		public async Task<AccessCredential[]> List_user_credentialsAsync(string accountname, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : Uri.EscapeDataString(accountname))+"/users/"+ (username==null? "" : Uri.EscapeDataString(username))+"/credentials";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AccessCredential[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// add/replace credential
		/// Create_user_credential accounts/{accountname}/users/{username}/credentials
		/// </summary>
		/// <returns>Add a credential, overwritting if already exists</returns>
		public async Task<User> Create_user_credentialAsync(string accountname, string username, AccessCredential requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : Uri.EscapeDataString(accountname))+"/users/"+ (username==null? "" : Uri.EscapeDataString(username))+"/credentials";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List_archives archives
		/// </summary>
		/// <returns>Archive summary listing</returns>
		public async Task<ArchiveSummary> List_archivesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ArchiveSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List_analysis_archive archives/images
		/// </summary>
		/// <returns>Image analysis archive listing for the requesting account (not the whole system)</returns>
		public async Task<ArchivedAnalysis[]> List_analysis_archiveAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/images";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ArchivedAnalysis[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Archive_image_analysis archives/images
		/// </summary>
		/// <returns>Archive statuses</returns>
		public async Task<AnalysisArchiveAddResult[]> Archive_image_analysisAsync(ImageAnalysisReferences requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/images";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnalysisArchiveAddResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Performs a synchronous archive deletion
		/// Delete_archived_analysis archives/images/{imageDigest}
		/// </summary>
		/// <returns>ArchivdImageAnalysis record but with status 'deleted'</returns>
		public async Task<ArchivedAnalysis> Delete_archived_analysisAsync(string imageDigest, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"&force="+force;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ArchivedAnalysis>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the archive metadata record identifying the image and tags for the analysis in the archive.
		/// Get_archived_analysis archives/images/{imageDigest}
		/// </summary>
		/// <param name="imageDigest">The image digest to identify the image analysis</param>
		/// <returns>Archived Image</returns>
		public async Task<ArchivedAnalysis> Get_archived_analysisAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ArchivedAnalysis>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List_analysis_archive_rules archives/rules
		/// </summary>
		/// <param name="system_global">If true include system global rules (owned by admin) even for non-admin users. Defaults to true if not set. Can be set to false to exclude globals</param>
		/// <returns>Archive transition rules</returns>
		public async Task<AnalysisArchiveTransitionRule[]> List_analysis_archive_rulesAsync(bool system_global, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/rules?system_global="+system_global;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnalysisArchiveTransitionRule[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create_analysis_archive_rule archives/rules
		/// </summary>
		/// <returns>Archive transition rule</returns>
		public async Task<AnalysisArchiveTransitionRule> Create_analysis_archive_ruleAsync(AnalysisArchiveTransitionRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/rules";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnalysisArchiveTransitionRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete_analysis_archive_rule archives/rules/{ruleId}
		/// </summary>
		/// <returns>Archive transition rule</returns>
		public async Task<AnalysisArchiveTransitionRule> Delete_analysis_archive_ruleAsync(string ruleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/rules/"+ (ruleId==null? "" : Uri.EscapeDataString(ruleId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnalysisArchiveTransitionRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get_analysis_archive_rule archives/rules/{ruleId}
		/// </summary>
		/// <returns>Archive transition rule</returns>
		public async Task<AnalysisArchiveTransitionRule> Get_analysis_archive_ruleAsync(string ruleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/rules/"+ (ruleId==null? "" : Uri.EscapeDataString(ruleId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnalysisArchiveTransitionRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List Event Types
		/// Returns list of event types in the category hierarchy
		/// List_event_types event_types
		/// </summary>
		/// <returns>List of event types</returns>
		public async Task<EventCategory[]> List_event_typesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "event_types";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<EventCategory[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete Events
		/// Delete all or a subset of events filtered using the optional query parameters
		/// Delete_events events
		/// </summary>
		/// <param name="before">Delete events that occurred before the timestamp</param>
		/// <param name="since">Delete events that occurred after the timestamp</param>
		/// <param name="level">Delete events that match the level - INFO or ERROR</param>
		/// <returns>List of deleted event IDs</returns>
		public async Task<string[]> Delete_eventsAsync(string before, string since, string level, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "events?before=" + (before==null? "" : Uri.EscapeDataString(before))+"&since=" + (since==null? "" : Uri.EscapeDataString(since))+"&level=" + (level==null? "" : Uri.EscapeDataString(level));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List Events
		/// Returns a paginated list of events in the descending order of their occurrence. Optional query parameters may be used for filtering results
		/// List_events events
		/// </summary>
		/// <param name="source_servicename">Filter events by the originating service</param>
		/// <param name="source_hostid">Filter events by the originating host ID</param>
		/// <param name="event_type">Filter events by a prefix match on the event type (e.g. "user.image.")</param>
		/// <param name="resource_type">Filter events by the type of resource - tag, imageDigest, repository etc</param>
		/// <param name="resource_id">Filter events by the id of the resource</param>
		/// <param name="level">Filter events by the level - INFO or ERROR</param>
		/// <param name="since">Return events that occurred after the timestamp</param>
		/// <param name="before">Return events that occurred before the timestamp</param>
		/// <param name="page">Pagination controls - return the nth page of results. Defaults to first page if left empty</param>
		/// <param name="limit">Number of events in the result set. Defaults to 100 if left empty</param>
		/// <returns>Paginated list of event records and the next token</returns>
		public async Task<EventsList> List_eventsAsync(string source_servicename, string source_hostid, string event_type, string resource_type, string resource_id, string level, string since, string before, int page, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "events?source_servicename=" + (source_servicename==null? "" : Uri.EscapeDataString(source_servicename))+"&source_hostid=" + (source_hostid==null? "" : Uri.EscapeDataString(source_hostid))+"&event_type=" + (event_type==null? "" : Uri.EscapeDataString(event_type))+"&resource_type=" + (resource_type==null? "" : Uri.EscapeDataString(resource_type))+"&resource_id=" + (resource_id==null? "" : Uri.EscapeDataString(resource_id))+"&level=" + (level==null? "" : Uri.EscapeDataString(level))+"&since=" + (since==null? "" : Uri.EscapeDataString(since))+"&before=" + (before==null? "" : Uri.EscapeDataString(before))+"&page="+page+"&limit="+limit;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<EventsList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete Event
		/// Delete an event by its event ID
		/// Delete_event events/{eventId}
		/// </summary>
		/// <param name="eventId">Event ID of the event to be deleted</param>
		/// <returns>Delete success</returns>
		public async Task Delete_eventAsync(string eventId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "events/"+ (eventId==null? "" : Uri.EscapeDataString(eventId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Event
		/// Lookup an event by its event ID
		/// Get_event events/{eventId}
		/// </summary>
		/// <param name="eventId">Event ID of the event for lookup</param>
		/// <returns>Single event record</returns>
		public async Task<EventResponse> Get_eventAsync(string eventId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "events/"+ (eventId==null? "" : Uri.EscapeDataString(eventId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<EventResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Health check, returns 200 and no body if service is running
		/// Health_noop health
		/// </summary>
		/// <returns>Empty body on success</returns>
		public async Task Health_noopAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "health";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all visible images
		/// List all images visible to the user
		/// List_images images
		/// </summary>
		/// <param name="history">Include image history in the response</param>
		/// <param name="fulltag">Full docker-pull string to filter results by (e.g. docker.io/library/nginx:latest, or myhost.com:5000/testimages:v1.1.1)</param>
		/// <returns>successful operation</returns>
		public async Task<AnchoreImage[]> List_imagesAsync(bool history, string fulltag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images?history="+history+"&fulltag=" + (fulltag==null? "" : Uri.EscapeDataString(fulltag));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnchoreImage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Submit a new image for analysis by the engine
		/// Creates a new analysis task that is executed asynchronously
		/// Add_image images
		/// </summary>
		/// <param name="force">Override any existing entry in the system</param>
		/// <param name="autosubscribe">Instruct engine to automatically begin watching the added tag for updates from registry</param>
		/// <returns>Successfully added image to analysis queue</returns>
		public async Task<AnchoreImage[]> Add_imageAsync(bool force, bool autosubscribe, ImageAnalysisRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images?force="+force+"&autosubscribe="+autosubscribe;
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnchoreImage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete image by docker imageId
		/// Delete_image_by_imageId images/by_id/{imageId}
		/// </summary>
		/// <returns>Image deletion success</returns>
		public async Task Delete_image_by_imageIdAsync(string imageId, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : Uri.EscapeDataString(imageId))+"&force="+force;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lookup image by docker imageId
		/// Get_image_by_imageId images/by_id/{imageId}
		/// </summary>
		/// <returns>Image lookup success</returns>
		public async Task<AnchoreImage[]> Get_image_by_imageIdAsync(string imageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : Uri.EscapeDataString(imageId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnchoreImage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check policy evaluation status for image
		/// Get the policy evaluation for the given image
		/// Get_image_policy_check_by_imageId images/by_id/{imageId}/check
		/// </summary>
		/// <returns>Policy evaluation success</returns>
		public async Task<PolicyEvaluation[]> Get_image_policy_check_by_imageIdAsync(string imageId, string policyId, string tag, bool detail, bool history, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : Uri.EscapeDataString(imageId))+"/check&policyId=" + (policyId==null? "" : Uri.EscapeDataString(policyId))+"&tag=" + (tag==null? "" : Uri.EscapeDataString(tag))+"&detail="+detail+"&history="+history;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PolicyEvaluation[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List image content types
		/// List_image_content_by_imageid images/by_id/{imageId}/content
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<string[]> List_image_content_by_imageidAsync(string imageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : Uri.EscapeDataString(imageId))+"/content";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type files
		/// Get_image_content_by_type_imageId_files images/by_id/{imageId}/content/files
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentFilesResponse> Get_image_content_by_type_imageId_filesAsync(string imageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : Uri.EscapeDataString(imageId))+"/content/files";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ContentFilesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type java
		/// Get_image_content_by_type_imageId_javapackage images/by_id/{imageId}/content/java
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentJAVAPackageResponse> Get_image_content_by_type_imageId_javapackageAsync(string imageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : Uri.EscapeDataString(imageId))+"/content/java";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ContentJAVAPackageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type
		/// Get_image_content_by_type_imageId images/by_id/{imageId}/content/{ctype}
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentPackageResponse> Get_image_content_by_type_imageIdAsync(string imageId, string ctype, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : Uri.EscapeDataString(imageId))+"/content/"+ (ctype==null? "" : Uri.EscapeDataString(ctype));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ContentPackageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vulnerability types
		/// Get_image_vulnerability_types_by_imageId images/by_id/{imageId}/vuln
		/// </summary>
		/// <returns>Vulnerability listing for the image</returns>
		public async Task<string[]> Get_image_vulnerability_types_by_imageIdAsync(string imageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : Uri.EscapeDataString(imageId))+"/vuln";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vulnerabilities by type
		/// Get_image_vulnerabilities_by_type_imageId images/by_id/{imageId}/vuln/{vtype}
		/// </summary>
		/// <returns>Vulnerability listing for the image</returns>
		public async Task<VulnerabilityResponse> Get_image_vulnerabilities_by_type_imageIdAsync(string imageId, string vtype, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : Uri.EscapeDataString(imageId))+"/vuln/"+ (vtype==null? "" : Uri.EscapeDataString(vtype));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<VulnerabilityResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an image analysis
		/// Delete_image images/{imageDigest}
		/// </summary>
		/// <returns>Image deletion success</returns>
		public async Task Delete_imageAsync(string imageDigest, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"&force="+force;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get image metadata
		/// Get_image images/{imageDigest}
		/// </summary>
		/// <returns>Image lookup success</returns>
		public async Task<AnchoreImage[]> Get_imageAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnchoreImage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of analyzer artifacts of the specified type
		/// List_file_content_search_results images/{imageDigest}/artifacts/file_content_search
		/// </summary>
		/// <returns>List of file metadata objects</returns>
		public async Task<FileContentSearchResult[]> List_file_content_search_resultsAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/artifacts/file_content_search";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<FileContentSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of analyzer artifacts of the specified type
		/// List_retrieved_files images/{imageDigest}/artifacts/retrieved_files
		/// </summary>
		/// <returns>List of file metadata objects</returns>
		public async Task<RetrievedFile[]> List_retrieved_filesAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/artifacts/retrieved_files";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RetrievedFile[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of analyzer artifacts of the specified type
		/// List_secret_search_results images/{imageDigest}/artifacts/secret_search
		/// </summary>
		/// <returns>List of file metadata objects</returns>
		public async Task<SecretSearchResult[]> List_secret_search_resultsAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/artifacts/secret_search";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<SecretSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check policy evaluation status for image
		/// Get the policy evaluation for the given image
		/// Get_image_policy_check images/{imageDigest}/check
		/// </summary>
		/// <returns>Policy evaluation success</returns>
		public async Task<PolicyEvaluation[]> Get_image_policy_checkAsync(string imageDigest, string policyId, string tag, bool detail, bool history, bool interactive, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/check&policyId=" + (policyId==null? "" : Uri.EscapeDataString(policyId))+"&tag=" + (tag==null? "" : Uri.EscapeDataString(tag))+"&detail="+detail+"&history="+history+"&interactive="+interactive;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PolicyEvaluation[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List image content types
		/// List_image_content images/{imageDigest}/content
		/// </summary>
		/// <returns>Content listing for the image</returns>
		public async Task<string[]> List_image_contentAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/content";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type files
		/// Get_image_content_by_type_files images/{imageDigest}/content/files
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentFilesResponse> Get_image_content_by_type_filesAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/content/files";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ContentFilesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type java
		/// Get_image_content_by_type_javapackage images/{imageDigest}/content/java
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentJAVAPackageResponse> Get_image_content_by_type_javapackageAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/content/java";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ContentJAVAPackageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type
		/// Get_image_content_by_type images/{imageDigest}/content/{ctype}
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentPackageResponse> Get_image_content_by_typeAsync(string imageDigest, string ctype, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/content/"+ (ctype==null? "" : Uri.EscapeDataString(ctype));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ContentPackageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List image metadata types
		/// List_image_metadata images/{imageDigest}/metadata
		/// </summary>
		/// <returns>Metadata listing for the image</returns>
		public async Task<string[]> List_image_metadataAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/metadata";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the metadata of an image by type
		/// Get_image_metadata_by_type images/{imageDigest}/metadata/{mtype}
		/// </summary>
		/// <returns>Metadata of specified type from the image</returns>
		public async Task<MetadataResponse> Get_image_metadata_by_typeAsync(string imageDigest, string mtype, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/metadata/"+ (mtype==null? "" : Uri.EscapeDataString(mtype));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MetadataResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vulnerability types
		/// Get_image_vulnerability_types images/{imageDigest}/vuln
		/// </summary>
		/// <returns>Vulnerability listing for the image</returns>
		public async Task<string[]> Get_image_vulnerability_typesAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/vuln";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vulnerabilities by type
		/// Get_image_vulnerabilities_by_type images/{imageDigest}/vuln/{vtype}
		/// </summary>
		/// <returns>Vulnerability listing for the image</returns>
		public async Task<VulnerabilityResponse> Get_image_vulnerabilities_by_typeAsync(string imageDigest, string vtype, bool force_refresh, bool vendor_only, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : Uri.EscapeDataString(imageDigest))+"/vuln/"+ (vtype==null? "" : Uri.EscapeDataString(vtype))+"&force_refresh="+force_refresh+"&vendor_only="+vendor_only;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<VulnerabilityResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request a jwt token for subsequent operations, this request is authenticated with normal HTTP auth
		/// Get_oauth_token oauth/token
		/// </summary>
		/// <returns>Resulting JWT token</returns>
		public async Task<TokenResponse> Get_oauth_tokenAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oauth/token";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<TokenResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List policies
		/// List all saved policy bundles
		/// List_policies policies
		/// </summary>
		/// <param name="detail">Include policy bundle detail in the form of the full bundle content for each entry</param>
		/// <returns>Policy listing</returns>
		public async Task<PolicyBundleRecord[]> List_policiesAsync(bool detail, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policies?detail="+detail;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PolicyBundleRecord[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a new policy
		/// Adds a new policy bundle to the system
		/// Add_policy policies
		/// </summary>
		/// <returns>Saved bundle</returns>
		public async Task<PolicyBundleRecord> Add_policyAsync(PolicyBundle requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policies";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PolicyBundleRecord>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete policy
		/// Delete the specified policy
		/// Delete_policy policies/{policyId}
		/// </summary>
		/// <returns>Delete success</returns>
		public async Task Delete_policyAsync(string policyId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policies/"+ (policyId==null? "" : Uri.EscapeDataString(policyId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get specific policy
		/// Get the policy bundle content
		/// Get_policy policies/{policyId}
		/// </summary>
		/// <param name="detail">Include policy bundle detail in the form of the full bundle content for each entry</param>
		/// <returns>A list with a single fetched policy bundle record</returns>
		public async Task<PolicyBundleRecord[]> Get_policyAsync(string policyId, bool detail, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policies/"+ (policyId==null? "" : Uri.EscapeDataString(policyId))+"&detail="+detail;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PolicyBundleRecord[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update policy
		/// Update/replace and existing policy
		/// Update_policy policies/{policyId}
		/// </summary>
		/// <param name="active">Mark policy as active</param>
		/// <returns>A list with a single updated policy bundle record</returns>
		public async Task<PolicyBundleRecord[]> Update_policyAsync(string policyId, bool active, PolicyBundleRecord requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policies/"+ (policyId==null? "" : Uri.EscapeDataString(policyId))+"&active="+active;
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PolicyBundleRecord[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List of images containing given package
		/// Filterable query interface to search for images containing specified package
		/// Query_images_by_package query/images/by_package
		/// </summary>
		/// <param name="name">Name of package to search for (e.g. sed)</param>
		/// <param name="package_type">Type of package to filter on (e.g. dpkg)</param>
		/// <param name="version">Version of named package to filter on (e.g. 4.4-1)</param>
		/// <param name="page">The page of results to fetch. Pages start at 1</param>
		/// <param name="limit">Limit the number of records for the requested page. If omitted or set to 0, return all results in a single page</param>
		/// <returns>Image listing</returns>
		public async Task<PaginatedImageList> Query_images_by_packageAsync(string name, string package_type, string version, string page, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "query/images/by_package?name=" + (name==null? "" : Uri.EscapeDataString(name))+"&package_type=" + (package_type==null? "" : Uri.EscapeDataString(package_type))+"&version=" + (version==null? "" : Uri.EscapeDataString(version))+"&page=" + (page==null? "" : Uri.EscapeDataString(page))+"&limit="+limit;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PaginatedImageList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List images vulnerable to the specific vulnerability ID.
		/// Returns a listing of images and their respective packages vulnerable to the given vulnerability ID
		/// Query_images_by_vulnerability query/images/by_vulnerability
		/// </summary>
		/// <param name="vulnerability_id">The ID of the vulnerability to search for within all images stored in anchore-engine (e.g. CVE-1999-0001)</param>
		/// <param name="namespace">Filter results to images within the given vulnerability namespace (e.g. debian:8, ubuntu:14.04)</param>
		/// <param name="affected_package">Filter results to images with vulnable packages with the given package name (e.g. libssl)</param>
		/// <param name="severity">Filter results to vulnerable package/vulnerability with the given severity</param>
		/// <param name="vendor_only">Filter results to include only vulnerabilities that are not marked as invalid by upstream OS vendor data</param>
		/// <param name="page">The page of results to fetch. Pages start at 1</param>
		/// <param name="limit">Limit the number of records for the requested page. If omitted or set to 0, return all results in a single page</param>
		/// <returns>Image lookup success</returns>
		public async Task<PaginatedVulnerableImageList> Query_images_by_vulnerabilityAsync(string vulnerability_id, string @namespace, string affected_package, StandaloneVulnerabilitySeverity severity, bool vendor_only, int page, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "query/images/by_vulnerability?vulnerability_id=" + (vulnerability_id==null? "" : Uri.EscapeDataString(vulnerability_id))+"&namespace=" + (namespace==null? "" : Uri.EscapeDataString(namespace))+"&affected_package=" + (affected_package==null? "" : Uri.EscapeDataString(affected_package))+"&severity=" + severity+"&vendor_only="+vendor_only+"&page="+page+"&limit="+limit;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PaginatedVulnerableImageList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Listing information about given vulnerability
		/// List (w/filters) vulnerability records known by the system, with affected packages information if present
		/// Query_vulnerabilities query/vulnerabilities
		/// </summary>
		/// <param name="id">The ID of the vulnerability (e.g. CVE-1999-0001)</param>
		/// <param name="affected_package">Filter results by specified package name (e.g. sed)</param>
		/// <param name="affected_package_version">Filter results by specified package version (e.g. 4.4-1)</param>
		/// <param name="page">The page of results to fetch. Pages start at 1</param>
		/// <param name="limit">Limit the number of records for the requested page. If omitted or set to 0, return all results in a single page</param>
		/// <param name="namespace">Namespace(s) to filter vulnerability records by</param>
		/// <returns>Vulnerability listing paginated</returns>
		public async Task<PaginatedVulnerabilityList> Query_vulnerabilitiesAsync(string[] id, string affected_package, string affected_package_version, string page, int limit, string[] @namespace, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "query/vulnerabilities?"+String.Join("&", id.Select(z => $"id={Uri.EscapeDataString(z.ToString())}"))+"&affected_package=" + (affected_package==null? "" : Uri.EscapeDataString(affected_package))+"&affected_package_version=" + (affected_package_version==null? "" : Uri.EscapeDataString(affected_package_version))+"&page=" + (page==null? "" : Uri.EscapeDataString(page))+"&limit="+limit+"&"+String.Join("&", namespace.Select(z => $"namespace={Uri.EscapeDataString(z.ToString())}"));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PaginatedVulnerabilityList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List configured registries
		/// List all configured registries the system can/will watch
		/// List_registries registries
		/// </summary>
		/// <returns>Registry listing</returns>
		public async Task<RegistryConfiguration[]> List_registriesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registries";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RegistryConfiguration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a new registry
		/// Adds a new registry to the system
		/// Create_registry registries
		/// </summary>
		/// <param name="validate">flag to determine whether or not to validate registry/credential at registry add time</param>
		/// <returns>Saved registry configuration</returns>
		public async Task<RegistryConfiguration[]> Create_registryAsync(bool validate, RegistryConfigurationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registries?validate="+validate;
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RegistryConfiguration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a registry configuration
		/// Delete a registry configuration record from the system. Does not remove any images.
		/// Delete_registry registries/{registry}
		/// </summary>
		/// <returns>Delete success</returns>
		public async Task Delete_registryAsync(string registry, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registries/"+ (registry==null? "" : Uri.EscapeDataString(registry));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific registry configuration
		/// Get information on a specific registry
		/// Get_registry registries/{registry}
		/// </summary>
		/// <returns>Registry configuration</returns>
		public async Task<RegistryConfiguration> Get_registryAsync(string registry, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registries/"+ (registry==null? "" : Uri.EscapeDataString(registry));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RegistryConfiguration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update/replace a registry configuration
		/// Replaces an existing registry record with the given record
		/// Update_registry registries/{registry}
		/// </summary>
		/// <param name="validate">flag to determine whether or not to validate registry/credential at registry update time</param>
		/// <returns>Updated registry configuration</returns>
		public async Task<RegistryConfiguration[]> Update_registryAsync(string registry, bool validate, RegistryConfigurationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registries/"+ (registry==null? "" : Uri.EscapeDataString(registry))+"&validate="+validate;
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RegistryConfiguration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add repository to watch
		/// Add_repository repositories
		/// </summary>
		/// <param name="repository">full repository to add e.g. docker.io/library/alpine</param>
		/// <param name="autosubscribe">flag to enable/disable auto tag_update activation when new images from a repo are added</param>
		/// <param name="lookuptag">use specified existing tag to perform repo scan (default is 'latest')</param>
		/// <returns>Repository and discovered tags added</returns>
		public async Task<Subscription[]> Add_repositoryAsync(string repository, bool autosubscribe, string lookuptag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repositories?repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&autosubscribe="+autosubscribe+"&lookuptag=" + (lookuptag==null? "" : Uri.EscapeDataString(lookuptag));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Subscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Service status
		/// Get the API service status
		/// Get_status status
		/// </summary>
		/// <returns>Status listing</returns>
		public async Task<StatusResponse> Get_statusAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "status";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<StatusResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all subscriptions
		/// List_subscriptions subscriptions
		/// </summary>
		/// <param name="subscription_key">filter only subscriptions matching key</param>
		/// <param name="subscription_type">filter only subscriptions matching type</param>
		/// <returns>Subscription listing</returns>
		public async Task<Subscription[]> List_subscriptionsAsync(string subscription_key, string subscription_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions?subscription_key=" + (subscription_key==null? "" : Uri.EscapeDataString(subscription_key))+"&subscription_type=" + (subscription_type==null? "" : Uri.EscapeDataString(subscription_type));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Subscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a subscription of a specific type
		/// Create a new subscription to watch a tag and get notifications of changes
		/// Add_subscription subscriptions
		/// </summary>
		/// <returns>Subscription add success</returns>
		public async Task<Subscription[]> Add_subscriptionAsync(SubscriptionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Subscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete subscriptions of a specific type
		/// Delete_subscription subscriptions/{subscriptionId}
		/// </summary>
		/// <returns>Delete success</returns>
		public async Task Delete_subscriptionAsync(string subscriptionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific subscription set
		/// Get_subscription subscriptions/{subscriptionId}
		/// </summary>
		/// <returns>Filtered subscription list by type</returns>
		public async Task<Subscription[]> Get_subscriptionAsync(string subscriptionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Subscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing and specific subscription
		/// Update_subscription subscriptions/{subscriptionId}
		/// </summary>
		/// <returns>Subscription add success</returns>
		public async Task<Subscription[]> Update_subscriptionAsync(string subscriptionId, SubscriptionUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Subscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List all visible image digests and tags
		/// List all image tags visible to the user
		/// List_imagetags summaries/imagetags
		/// </summary>
		/// <returns>successful operation</returns>
		public async Task<AnchoreImageTagSummary[]> List_imagetagsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "summaries/imagetags";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnchoreImageTagSummary[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// System status
		/// Get the system status including queue lengths
		/// Get_service_detail system
		/// </summary>
		/// <returns>Status listing</returns>
		public async Task<SystemStatusResponse> Get_service_detailAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<SystemStatusResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describe anchore engine error codes.
		/// Describe anchore engine error codes.
		/// Describe_error_codes system/error_codes
		/// </summary>
		/// <returns>Error Codes Description</returns>
		public async Task<AnchoreErrorCode[]> Describe_error_codesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/error_codes";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AnchoreErrorCode[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// list feeds operations and information
		/// Get_system_feeds system/feeds
		/// </summary>
		/// <returns>success</returns>
		public async Task<FeedMetadata[]> Get_system_feedsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/feeds";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<FeedMetadata[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// trigger feeds operations
		/// Post_system_feeds system/feeds
		/// </summary>
		/// <param name="flush">instruct system to flush existing data feeds records from anchore-engine</param>
		/// <param name="sync">instruct system to re-sync data feeds</param>
		/// <returns>Feeds operation success</returns>
		public async Task<FeedSyncResult[]> Post_system_feedsAsync(bool flush, bool sync, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/feeds?flush="+flush+"&sync="+sync;
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<FeedSyncResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describe the policy language spec implemented by this service.
		/// Get the policy language spec for this service
		/// Describe_policy system/policy_spec
		/// </summary>
		/// <returns>Policy Language Description</returns>
		public async Task<GateSpec[]> Describe_policyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/policy_spec";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GateSpec[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List system services
		/// List_services system/services
		/// </summary>
		/// <returns>Service listing</returns>
		public async Task<Service[]> List_servicesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/services";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Service[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a service configuration and state
		/// Get_services_by_name system/services/{servicename}
		/// </summary>
		/// <returns>Service Info</returns>
		public async Task<Service[]> Get_services_by_nameAsync(string servicename, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/services/"+ (servicename==null? "" : Uri.EscapeDataString(servicename));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Service[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete the service config
		/// Delete_service system/services/{servicename}/{hostid}
		/// </summary>
		/// <returns>Delete success</returns>
		public async Task Delete_serviceAsync(string servicename, string hostid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/services/"+ (servicename==null? "" : Uri.EscapeDataString(servicename))+"/"+ (hostid==null? "" : Uri.EscapeDataString(hostid));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get service config for a specific host
		/// Get_services_by_name_and_host system/services/{servicename}/{hostid}
		/// </summary>
		/// <returns>Listing of registered services</returns>
		public async Task<Service[]> Get_services_by_name_and_hostAsync(string servicename, string hostid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/services/"+ (servicename==null? "" : Uri.EscapeDataString(servicename))+"/"+ (hostid==null? "" : Uri.EscapeDataString(hostid));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Service[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List authenticated user info
		/// Get_user user
		/// </summary>
		/// <returns>User details for caller's user</returns>
		public async Task<User> Get_userAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get current credential summary
		/// Get_credentials user/credentials
		/// </summary>
		/// <returns>User credential listing</returns>
		public async Task<AccessCredential[]> Get_credentialsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/credentials";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AccessCredential[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// add/replace credential
		/// Add_credential user/credentials
		/// </summary>
		/// <returns>Add a credential, overwritting if already exists</returns>
		public async Task<User> Add_credentialAsync(AccessCredential requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/credentials";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the version object for the service, including db schema version info
		/// Version_noop version
		/// </summary>
		/// <returns>Version object describing version state</returns>
		public async Task<ServiceVersion> Version_noopAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ServiceVersion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
