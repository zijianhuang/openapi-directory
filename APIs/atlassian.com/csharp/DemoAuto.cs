//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Returns all application properties or a single application property.
		/// Application_propertiesGetByKeyAndKeyFilterAndPermissionLevel application-properties
		/// </summary>
		/// <param name="key">The key of the application property.</param>
		/// <param name="keyFilter">When a key isn't provided, this filters the list of results by the application property key using a regular expression. For example, using jira.lf.* will return all application properties with keys that start with jira.lf..</param>
		/// <param name="permissionLevel">The permission level of all items being returned in the list.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task Application_propertiesGetByKeyAndKeyFilterAndPermissionLevelAsync(string key, string keyFilter, string permissionLevel, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "application-properties?key=" + (key==null? "" : Uri.EscapeDataString(key))+"&keyFilter=" + (keyFilter==null? "" : Uri.EscapeDataString(keyFilter))+"&permissionLevel=" + (permissionLevel==null? "" : Uri.EscapeDataString(permissionLevel));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the application properties that are accessible on the Advanced Settings page. To navigate to the Advanced Settings page in Jira, choose the Jira icon > Jira settings > System, General Configuration and then click Advanced Settings (in the upper right).
		/// Application_propertiesAdvanced_settingsGet application-properties/advanced-settings
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task Application_propertiesAdvanced_settingsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "application-properties/advanced-settings";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes the value of an application property. For example, you can change the value of the jira.clone.prefix from its default value of CLONE - to Clone - if you prefer sentence case capitalization. Editable properties are described below along with their default values.
		/// Application_propertiesPutById application-properties/{id}
		/// </summary>
		/// <param name="id">The key of the application property to update.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task Application_propertiesPutByIdAsync(string id, Application_propertiesPutByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "application-properties/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all application roles. In Jira, application roles are managed using the Application access configuration page.
		/// ApplicationroleGet applicationrole
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ApplicationroleGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "applicationrole";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an application role.
		/// ApplicationroleGetByKey applicationrole/{key}
		/// </summary>
		/// <param name="key">The key of the application role. Use the Get all application roles method to get the key for each application role.</param>
		/// <returns>Returns the ApplicationRole if it exists.</returns>
		public async Task ApplicationroleGetByKeyAsync(string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "applicationrole/"+ (key==null? "" : Uri.EscapeDataString(key));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the global attachment settings, that is, whether attachments are enabled and the maximum attachment size allowed.
		/// AttachmentMetaGet attachment/meta
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task AttachmentMetaGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "attachment/meta";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an attachment from an issue.
		/// AttachmentDeleteById attachment/{id}
		/// </summary>
		/// <param name="id">The ID of the attachment.</param>
		public async Task AttachmentDeleteByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "attachment/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the metadata for an attachment. Note that the attachment itself is not returned.
		/// AttachmentGetById attachment/{id}
		/// </summary>
		/// <param name="id">The ID of the attachment.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task AttachmentGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "attachment/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the metadata for the contents of an attachment, if it is an archive, and metadata for the attachment itself. For example, if the attachment is a ZIP archive, then information about the files in the archive is returned and metadata for the ZIP archive. Currently, only the ZIP archive format is supported.
		/// AttachmentExpandHumanGetById attachment/{id}/expand/human
		/// </summary>
		/// <param name="id">The ID of the attachment.</param>
		/// <returns>Returned if the request is successful. If an empty list is returned in the response, the attachment is empty, corrupt, or not an archive.</returns>
		public async Task AttachmentExpandHumanGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "attachment/"+ (id==null? "" : Uri.EscapeDataString(id))+"/expand/human";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the metadata for the contents of an attachment, if it is an archive. For example, if the attachment is a ZIP archive, then information about the files in the archive is returned. Currently, only the ZIP archive format is supported.
		/// AttachmentExpandRawGetById attachment/{id}/expand/raw
		/// </summary>
		/// <param name="id">The ID of the attachment.</param>
		/// <returns>Returned if the request is successful. If an empty list is returned in the response, the attachment is empty, corrupt, or not an archive.</returns>
		public async Task AttachmentExpandRawGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "attachment/"+ (id==null? "" : Uri.EscapeDataString(id))+"/expand/raw";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of audit records. The list can be filtered to include items:
		/// AuditingRecordGetByFilterAndFromAndLimitAndOffsetAndTo auditing/record
		/// </summary>
		/// <param name="filter">The query string.</param>
		/// <param name="from">The date and time on or after which returned audit records must have been created. If to is provided from must be before to or the result set will be empty.</param>
		/// <param name="limit">The maximum number of results to return. The maximum is 1000.</param>
		/// <param name="offset">The number of records to skip before returning the first result.</param>
		/// <param name="to">The date and time on or before which returned audit results must have been created. If from is provided to must be after from or the result set will be empty.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task AuditingRecordGetByFilterAndFromAndLimitAndOffsetAndToAsync(string filter, string from, int limit, int offset, string to, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "auditing/record?filter=" + (filter==null? "" : Uri.EscapeDataString(filter))+"&from=" + (from==null? "" : Uri.EscapeDataString(from))+"&limit="+limit+"&offset="+offset+"&to=" + (to==null? "" : Uri.EscapeDataString(to));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of system avatar details by owner type, where the owner types are issue type, project, or user.
		/// AvatarSystemGetByType avatar/{type}/system
		/// </summary>
		/// <param name="type">The avatar type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task AvatarSystemGetByTypeAsync(string type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "avatar/"+ (type==null? "" : Uri.EscapeDataString(type))+"/system";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the comments for a list of comment IDs.
		/// CommentListPostByExpand comment/list
		/// </summary>
		/// <param name="expand">Use expand to include additional information about comments in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task CommentListPostByExpandAsync(string expand, CommentListPostByExpandBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comment/list?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the keys of all the properties of a comment.
		/// CommentPropertiesGetByCommentId comment/{commentId}/properties
		/// </summary>
		/// <param name="commentId">The ID of the comment.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task CommentPropertiesGetByCommentIdAsync(string commentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comment/"+ (commentId==null? "" : Uri.EscapeDataString(commentId))+"/properties";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a comment property.
		/// CommentPropertiesDeleteByCommentIdAndPropertyKey comment/{commentId}/properties/{propertyKey}
		/// </summary>
		/// <param name="commentId">The ID of the comment.</param>
		/// <param name="propertyKey">The key of the property.</param>
		public async Task CommentPropertiesDeleteByCommentIdAndPropertyKeyAsync(string commentId, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comment/"+ (commentId==null? "" : Uri.EscapeDataString(commentId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the value of a comment property.
		/// CommentPropertiesGetByCommentIdAndPropertyKey comment/{commentId}/properties/{propertyKey}
		/// </summary>
		/// <param name="commentId">The ID of the comment.</param>
		/// <param name="propertyKey">The key of the property.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task CommentPropertiesGetByCommentIdAndPropertyKeyAsync(string commentId, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comment/"+ (commentId==null? "" : Uri.EscapeDataString(commentId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates or updates the value of a property for a comment. Use this resource to store custom data against a comment.
		/// CommentPropertiesPutByCommentIdAndPropertyKey comment/{commentId}/properties/{propertyKey}
		/// </summary>
		/// <param name="commentId">The ID of the comment.</param>
		/// <param name="propertyKey">The key of the property. The maximum length is 255 characters.</param>
		/// <returns>Returned if the comment property is updated.</returns>
		public async Task CommentPropertiesPutByCommentIdAndPropertyKeyAsync(string commentId, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comment/"+ (commentId==null? "" : Uri.EscapeDataString(commentId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a component. Use components to provide containers for issues within a project. Permissions required: Any of the following:
		/// ComponentPost component
		/// </summary>
		public async Task ComponentPostAsync(ComponentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "component";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a component. Permissions required: Any of the following:
		/// ComponentDeleteByIdAndMoveIssuesTo component/{id}
		/// </summary>
		/// <param name="id">The ID of the component.</param>
		/// <param name="moveIssuesTo">The ID of the component to replace the deleted component. If this value is null no replacement is made.</param>
		public async Task ComponentDeleteByIdAndMoveIssuesToAsync(string id, string moveIssuesTo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "component/"+ (id==null? "" : Uri.EscapeDataString(id))+"&moveIssuesTo=" + (moveIssuesTo==null? "" : Uri.EscapeDataString(moveIssuesTo));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a component. Permissions required: Browse projects project permission.
		/// ComponentGetById component/{id}
		/// </summary>
		/// <param name="id">The ID of the component.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ComponentGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "component/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modifies a component. Any fields included in the request are overwritten. If leadUserName is an empty string ("") the component lead is removed. Permissions required: Any of the following:
		/// ComponentPutById component/{id}
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ComponentPutByIdAsync(string id, ComponentPutByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "component/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the counts of issues assigned to the component. Permissions required: Permission to access Jira.
		/// ComponentRelatedIssueCountsGetById component/{id}/relatedIssueCounts
		/// </summary>
		/// <param name="id">The ID of the component.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ComponentRelatedIssueCountsGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "component/"+ (id==null? "" : Uri.EscapeDataString(id))+"/relatedIssueCounts";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the global settings in Jira. These settings determine whether optional features (for example, sub-tasks, time tracking, and others) are enabled. If time tracking is enabled, this method also returns the time tracking configuration.
		/// ConfigurationGet configuration
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ConfigurationGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "configuration";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disables time tracking.
		/// ConfigurationTimetrackingDelete configuration/timetracking
		/// </summary>
		public async Task ConfigurationTimetrackingDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "configuration/timetracking";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the time tracking provider that is currently selected. Note that if time tracking is disabled, then a successful but empty response is returned.
		/// ConfigurationTimetrackingGet configuration/timetracking
		/// </summary>
		/// <returns>Returned if the request is successful and time tracking is enabled.</returns>
		public async Task ConfigurationTimetrackingGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "configuration/timetracking";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Selects a time tracking provider.
		/// ConfigurationTimetrackingPut configuration/timetracking
		/// </summary>
		public async Task ConfigurationTimetrackingPutAsync(ConfigurationTimetrackingPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "configuration/timetracking";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all time tracking providers. By default, Jira only has one time tracking provider: JIRA provided time tracking. However, you can install other time tracking providers via apps from the Atlassian Marketplace. For more information on time tracking providers, see the documentation for the Time Tracking Provider module.
		/// ConfigurationTimetrackingListGet configuration/timetracking/list
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ConfigurationTimetrackingListGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "configuration/timetracking/list";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the time tracking settings. This includes settings such as the time format, default time unit, and others. For more information, see Configuring time tracking.
		/// ConfigurationTimetrackingOptionsGet configuration/timetracking/options
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ConfigurationTimetrackingOptionsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "configuration/timetracking/options";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the time tracking settings.
		/// ConfigurationTimetrackingOptionsPut configuration/timetracking/options
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ConfigurationTimetrackingOptionsPutAsync(ConfigurationTimetrackingOptionsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "configuration/timetracking/options";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a custom field option. For example, an option in a cascading select list.
		/// CustomFieldOptionGetById customFieldOption/{id}
		/// </summary>
		/// <param name="id">The ID of the custom field option. To find this ID, configure the custom field and edit its options in Jira. Click the option and its ID will show in the URL as the selectedParentOptionId parameter.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task CustomFieldOptionGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "customFieldOption/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of dashboards owned by or shared with the user. The list may be filtered to include only favorite or owned dashboards.
		/// DashboardGetByFilterAndMaxResultsAndStartAt dashboard
		/// </summary>
		/// <param name="filter">The filter applied to the list of dashboards. Valid values are:</param>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 1000.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task DashboardGetByFilterAndMaxResultsAndStartAtAsync(string filter, int maxResults, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dashboard?filter=" + (filter==null? "" : Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the keys of all properties for a dashboard item.
		/// DashboardItemsPropertiesGetByDashboardIdAndItemId dashboard/{dashboardId}/items/{itemId}/properties
		/// </summary>
		/// <param name="dashboardId">The ID of the dashboard.</param>
		/// <param name="itemId">The ID of the dashboard item.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task DashboardItemsPropertiesGetByDashboardIdAndItemIdAsync(string dashboardId, string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dashboard/"+ (dashboardId==null? "" : Uri.EscapeDataString(dashboardId))+"/items/"+ (itemId==null? "" : Uri.EscapeDataString(itemId))+"/properties";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a dashboard item property.
		/// DashboardItemsPropertiesDeleteByDashboardIdAndItemIdAndPropertyKey dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}
		/// </summary>
		/// <param name="dashboardId">The ID of the dashboard.</param>
		/// <param name="itemId">The ID of the dashboard item.</param>
		/// <param name="propertyKey">The key of the dashboard item property.</param>
		public async Task DashboardItemsPropertiesDeleteByDashboardIdAndItemIdAndPropertyKeyAsync(string dashboardId, string itemId, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dashboard/"+ (dashboardId==null? "" : Uri.EscapeDataString(dashboardId))+"/items/"+ (itemId==null? "" : Uri.EscapeDataString(itemId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the key and value of a dashboard item property.
		/// DashboardItemsPropertiesGetByDashboardIdAndItemIdAndPropertyKey dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}
		/// </summary>
		/// <param name="dashboardId">The ID of the dashboard.</param>
		/// <param name="itemId">The ID of the dashboard item.</param>
		/// <param name="propertyKey">The key of the dashboard item property.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task DashboardItemsPropertiesGetByDashboardIdAndItemIdAndPropertyKeyAsync(string dashboardId, string itemId, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dashboard/"+ (dashboardId==null? "" : Uri.EscapeDataString(dashboardId))+"/items/"+ (itemId==null? "" : Uri.EscapeDataString(itemId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the value of a dashboard item property. Use this resource in apps to store custom data against a dashboard item.
		/// DashboardItemsPropertiesPutByDashboardIdAndItemIdAndPropertyKey dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}
		/// </summary>
		/// <param name="dashboardId">The ID of the dashboard.</param>
		/// <param name="itemId">The ID of the dashboard item.</param>
		/// <param name="propertyKey">The key of the dashboard item property. The maximum length of the key is 255 bytes.</param>
		/// <returns>Returned if the dashboard item property is updated.</returns>
		public async Task DashboardItemsPropertiesPutByDashboardIdAndItemIdAndPropertyKeyAsync(string dashboardId, string itemId, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dashboard/"+ (dashboardId==null? "" : Uri.EscapeDataString(dashboardId))+"/items/"+ (itemId==null? "" : Uri.EscapeDataString(itemId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a dashboard.
		/// DashboardGetById dashboard/{id}
		/// </summary>
		/// <param name="id">The ID of the dashboard.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task DashboardGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dashboard/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Evaluates a Jira expression and returns its value.
		/// ExpressionEvalPostByExpand expression/eval
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <returns>Returned if the expression evaluated successfully. The result can be any JSON, not only a primitive value but also a list or object.</returns>
		public async Task ExpressionEvalPostByExpandAsync(string expand, ExpressionEvalPostByExpandBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "expression/eval?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all issue fields in Jira, both system and custom fields.
		/// FieldGet field
		/// </summary>
		/// <returns>Returned if the requested fields are returned.</returns>
		public async Task FieldGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "field";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a custom field.
		/// FieldPost field
		/// </summary>
		public async Task FieldPostAsync(FieldPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "field";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all options defined for a select list issue field. A select list issue field is a type of issue field that allows a user to select an value from a list of options.
		/// FieldOptionGetByFieldKeyAndMaxResultsAndStartAt field/{fieldKey}/option
		/// </summary>
		/// <param name="fieldKey">The field key is specified in the following format: $(app-key)__$(field-key). For example, example-add-on__example-issue-field.</param>
		/// <param name="maxResults">The maximum number of items to return per page. For example, 20.</param>
		/// <param name="startAt">The starting index of the returned objects. For example, 1.</param>
		/// <returns>Returned if the requested options are returned.</returns>
		public async Task FieldOptionGetByFieldKeyAndMaxResultsAndStartAtAsync(string fieldKey, int maxResults, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "field/"+ (fieldKey==null? "" : Uri.EscapeDataString(fieldKey))+"/option&maxResults="+maxResults+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an option for a select list issue field.
		/// FieldOptionPostByFieldKey field/{fieldKey}/option
		/// </summary>
		/// <returns>Returned if the option has been created.</returns>
		public async Task FieldOptionPostByFieldKeyAsync(string fieldKey, FieldOptionPostByFieldKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "field/"+ (fieldKey==null? "" : Uri.EscapeDataString(fieldKey))+"/option";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns options defined for a select list issue field that can be viewed and selected by the currently logged in user.
		/// FieldOptionSuggestionsEditGetByFieldKeyAndMaxResultsAndProjectIdAndStartAt field/{fieldKey}/option/suggestions/edit
		/// </summary>
		/// <param name="fieldKey">The field key is specified in the following format: $(app-key)__$(field-key). For example, example-add-on__example-issue-field.</param>
		/// <param name="maxResults">The maximum number of items to return per page. For example, 20.</param>
		/// <param name="projectId">Filters the results to options that are only available in the specified project. For example, 10000.</param>
		/// <param name="startAt">The starting index of the returned objects. For example, 1.</param>
		/// <returns>Returned if the requested options are returned.</returns>
		public async Task FieldOptionSuggestionsEditGetByFieldKeyAndMaxResultsAndProjectIdAndStartAtAsync(string fieldKey, int maxResults, int projectId, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "field/"+ (fieldKey==null? "" : Uri.EscapeDataString(fieldKey))+"/option/suggestions/edit&maxResults="+maxResults+"&projectId="+projectId+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns options defined for a select list issue field that can be viewed by the currently logged in user.
		/// FieldOptionSuggestionsSearchGetByFieldKeyAndMaxResultsAndProjectIdAndStartAt field/{fieldKey}/option/suggestions/search
		/// </summary>
		/// <param name="fieldKey">The field key is specified in the following format: $(app-key)__$(field-key). For example, example-add-on__example-issue-field.</param>
		/// <param name="maxResults">The maximum number of items to return per page. For example, 20.</param>
		/// <param name="projectId">Filters the results to options that are only available in the specified project. For example, 10000.</param>
		/// <param name="startAt">The starting index of the returned objects. For example, 1.</param>
		/// <returns>Returned if the requested options are returned.</returns>
		public async Task FieldOptionSuggestionsSearchGetByFieldKeyAndMaxResultsAndProjectIdAndStartAtAsync(string fieldKey, int maxResults, int projectId, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "field/"+ (fieldKey==null? "" : Uri.EscapeDataString(fieldKey))+"/option/suggestions/search&maxResults="+maxResults+"&projectId="+projectId+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an option from a select list issue field.
		/// FieldOptionDeleteByFieldKeyAndOptionId field/{fieldKey}/option/{optionId}
		/// </summary>
		/// <param name="fieldKey">The field key is specified in the following format: $(app-key)__$(field-key). For example, example-add-on__example-issue-field.</param>
		/// <param name="optionId">The ID of the option to be deleted. For example, 3.</param>
		public async Task FieldOptionDeleteByFieldKeyAndOptionIdAsync(string fieldKey, int optionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "field/"+ (fieldKey==null? "" : Uri.EscapeDataString(fieldKey))+"/option/"+optionId;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an option from a select list issue field.
		/// FieldOptionGetByFieldKeyAndOptionId field/{fieldKey}/option/{optionId}
		/// </summary>
		/// <param name="fieldKey">The field key is specified in the following format: $(app-key)__$(field-key). For example, example-add-on__example-issue-field.</param>
		/// <param name="optionId">The ID of the option to be returned. For example, 3.</param>
		/// <returns>Returned if the requested option is returned.</returns>
		public async Task FieldOptionGetByFieldKeyAndOptionIdAsync(string fieldKey, int optionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "field/"+ (fieldKey==null? "" : Uri.EscapeDataString(fieldKey))+"/option/"+optionId;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an option for a select list issue field. If the option does not exist, a new option is created.
		/// FieldOptionPutByFieldKeyAndOptionId field/{fieldKey}/option/{optionId}
		/// </summary>
		/// <param name="fieldKey">The field key is specified in the following format: $(app-key)__$(field-key). For example, example-add-on__example-issue-field.</param>
		/// <param name="optionId">The ID of the option to be updated. For example, 3.</param>
		/// <returns>Returned if the option has been updated or created.</returns>
		public async Task FieldOptionPutByFieldKeyAndOptionIdAsync(string fieldKey, int optionId, FieldOptionPutByFieldKeyAndOptionIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "field/"+ (fieldKey==null? "" : Uri.EscapeDataString(fieldKey))+"/option/"+optionId;
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deselects a select list issue field option in all issues that it has been selected in. A different option can be selected to replace the deselected option. The update can also be limited to a smaller set of issues by using a JQL query.
		/// FieldOptionIssueDeleteByFieldKeyAndJqlAndOptionIdAndReplaceWith field/{fieldKey}/option/{optionId}/issue
		/// </summary>
		/// <param name="fieldKey">The field key is specified in the following format: $(app-key)__$(field-key). For example, example-add-on__example-issue-field.</param>
		/// <param name="jql">A JQL query that specifies the issues to be updated. For example, project=10000.</param>
		/// <param name="optionId">The ID of the option to be deselected. For example, 3.</param>
		/// <param name="replaceWith">The ID of the option that will replace the currently selected option. For example, 2.</param>
		public async Task FieldOptionIssueDeleteByFieldKeyAndJqlAndOptionIdAndReplaceWithAsync(string fieldKey, string jql, int optionId, int replaceWith, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "field/"+ (fieldKey==null? "" : Uri.EscapeDataString(fieldKey))+"/option/"+optionId+"/issue&jql=" + (jql==null? "" : Uri.EscapeDataString(jql))+"&replaceWith="+replaceWith;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all filters. Deprecated, use Search for filters that supports search and pagination. Permissions required: None, however only the following filters are returned:
		/// FilterGetByExpand filter
		/// </summary>
		/// <param name="expand">Use expand to include additional information about filter in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterGetByExpandAsync(string expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new filter. The new filter is not shared and not selected as a favorite. Permissions required: Permission to log in to Jira.
		/// FilterPostByExpand filter
		/// </summary>
		/// <param name="expand">Use expand to include additional information about filter in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterPostByExpandAsync(string expand, FilterPostByExpandBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the default sharing settings for new filters and dashboards for a user. Permissions required: Permission to log in to Jira (i.e., member of the users group).
		/// FilterDefaultShareScopeGet filter/defaultShareScope
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterDefaultShareScopeGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/defaultShareScope";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the default sharing for new filters and dashboards for a user. Permissions required: Permission to log in to Jira (i.e., member of the users group).
		/// FilterDefaultShareScopePut filter/defaultShareScope
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterDefaultShareScopePutAsync(FilterDefaultShareScopePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/defaultShareScope";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the favorite filters of the calling user. Permissions required: Permission to log in to Jira (i.e., member of the users group).
		/// FilterFavouriteGetByExpand filter/favourite
		/// </summary>
		/// <param name="expand">Use expand to include additional information about filter in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterFavouriteGetByExpandAsync(string expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/favourite?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the filters owned by the calling user. If includeFavourites is true, the user's favorite filters are also returned. Permissions required: Permission to log in to Jira (i.e., member of the users group).
		/// FilterMyGetByExpandAndIncludeFavourites filter/my
		/// </summary>
		/// <param name="expand">Use expand to include additional information about filter in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="includeFavourites">Include the user's favorite filters in the response.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterMyGetByExpandAndIncludeFavouritesAsync(string expand, bool includeFavourites, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/my?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&includeFavourites="+includeFavourites;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search for filters. This method is similar to Get filters except that you can refine the results to include filters that have specific attributes. For example, filters with a particular name. Permissions required: None, however only the following filters are returned (if no search parameters are set):
		/// FilterSearchGetByAccountIdAndExpandAndFilterNameAndGroupnameAndMaxResultsAndOrderByAndOwnerAndProjectIdAndStartAt filter/search
		/// </summary>
		/// <param name="accountId">Returns filters with an owner that exactly matches accountId of the owner. This parameter cannot be used with the owner parameter.</param>
		/// <param name="expand">Use expand to include additional information about filter in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="filterName">Returns filters with a name that partially matches filterName.</param>
		/// <param name="groupname">Returns filters that are shared with a group that has a name that exactly matches groupname.</param>
		/// <param name="maxResults">The maximum number of items to return per page. Max is 50.</param>
		/// <param name="orderBy">Orders the results by a property of the filter. For example, name.</param>
		/// <param name="owner">Returns filters with an owner that exactly matches owner. This parameter cannot be used with the accountId parameter.</param>
		/// <param name="projectId">Returns filters that are shared with a project that has an ID that exactly matches projectId.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset). The base index is 0.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterSearchGetByAccountIdAndExpandAndFilterNameAndGroupnameAndMaxResultsAndOrderByAndOwnerAndProjectIdAndStartAtAsync(string accountId, string expand, string filterName, string groupname, int maxResults, string orderBy, string owner, int projectId, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/search?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&filterName=" + (filterName==null? "" : Uri.EscapeDataString(filterName))+"&groupname=" + (groupname==null? "" : Uri.EscapeDataString(groupname))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : Uri.EscapeDataString(orderBy))+"&owner=" + (owner==null? "" : Uri.EscapeDataString(owner))+"&projectId="+projectId+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a filter. Permissions required: Permission to log in to Jira, however the following rules govern what a user can delete:
		/// FilterDeleteById filter/{id}
		/// </summary>
		/// <param name="id">The ID of the filter to delete.</param>
		public async Task FilterDeleteByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a filter. Permissions required: None, however the calling user must have permission view the filter.
		/// FilterGetByExpandAndId filter/{id}
		/// </summary>
		/// <param name="expand">Use expand to include additional information about filter in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="id">The ID of the filter to return.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterGetByExpandAndIdAsync(string expand, int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing filter. Use this method to update a filter's name, description, JQL, or sharing. Permissions required: Permission to log in to Jira, however the following rules govern what a user can update:
		/// FilterPutByExpandAndId filter/{id}
		/// </summary>
		/// <param name="expand">Use expand to include additional information about filter in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="id">The ID of the filter to update.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterPutByExpandAndIdAsync(string expand, int id, FilterPutByExpandAndIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reset the user's column configuration for the filter to the default. Permissions required: Permission to log in to Jira (i.e., member of the users group) and permission to view the filter.
		/// FilterColumnsDeleteById filter/{id}/columns
		/// </summary>
		/// <param name="id">The ID of the filter.</param>
		public async Task FilterColumnsDeleteByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"/columns";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the columns configured for a filter. The column configuration is used when the filter's results are viewed in List View with the Columns set to Filter. Permissions required: None, however the calling user must have permission to view the filter.
		/// FilterColumnsGetById filter/{id}/columns
		/// </summary>
		/// <param name="id">The ID of the filter.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterColumnsGetByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"/columns";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the columns for a filter. Only navigable fields can be set as columns. Use Get fields to get the list fields in Jira. A navigable field has navigable set to true. Permissions required: Permission to log in to Jira (i.e., member of the users group) and permission to view the filter.
		/// FilterColumnsPutById filter/{id}/columns
		/// </summary>
		/// <param name="id">The ID of the filter.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterColumnsPutByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"/columns";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a filter as a favorite for the calling user. Permissions required: Permission to log in to Jira (i.e., member of the users group) and permission to view the filter.
		/// FilterFavouriteDeleteByExpandAndId filter/{id}/favourite
		/// </summary>
		/// <param name="expand">Use expand to include additional information about filter in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="id">The ID of the filter.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterFavouriteDeleteByExpandAndIdAsync(string expand, int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"/favourite?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a filter as a favorite for the calling user. Permissions required: Permission to log in to Jira (i.e., member of the users group) and permission to view the filter.
		/// FilterFavouritePutByExpandAndId filter/{id}/favourite
		/// </summary>
		/// <param name="expand">Use expand to include additional information about filter in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="id">The ID of the filter.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterFavouritePutByExpandAndIdAsync(string expand, int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"/favourite?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the share permissions for a filter. A filter can be shared with groups, projects, all logged-in users, or the public. Sharing with all logged-in users or the public is known as a global share permission. Permissions required: None, however the calling user must have permission to view the filter.
		/// FilterPermissionGetById filter/{id}/permission
		/// </summary>
		/// <param name="id">The ID of the filter.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterPermissionGetByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"/permission";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a share permissions to a filter. If you add a global share permission (i.e., all logged-in users or the public) it will overwrite all share permissions for the filter.Be aware that this method uses different objects for updating share permissions compared to Update filter. Permissions required: Share dashboards and filters global permission and the calling user must own the filter.
		/// FilterPermissionPostById filter/{id}/permission
		/// </summary>
		/// <param name="id">The ID of the filter.</param>
		public async Task FilterPermissionPostByIdAsync(int id, FilterPermissionPostByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"/permission";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a share permission from a filter. Permissions required: Permission to log in to Jira (i.e., member of the users group) and the calling user must own the filter.
		/// FilterPermissionDeleteByIdAndPermissionId filter/{id}/permission/{permissionId}
		/// </summary>
		/// <param name="id">The ID of the filter.</param>
		/// <param name="permissionId">The ID of the share permission.</param>
		public async Task FilterPermissionDeleteByIdAndPermissionIdAsync(int id, int permissionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"/permission/"+permissionId;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a share permission for a filter. A filter can be shared with groups, projects, all logged-in users, or the public. Sharing with all logged-in users or the public is known as a global share permission. Permissions required: None, however the calling user must have permission to view the filter.
		/// FilterPermissionGetByIdAndPermissionId filter/{id}/permission/{permissionId}
		/// </summary>
		/// <param name="id">The ID of the filter.</param>
		/// <param name="permissionId">The ID of the share permission.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task FilterPermissionGetByIdAndPermissionIdAsync(int id, int permissionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filter/"+id+"/permission/"+permissionId;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a group.
		/// GroupDeleteByGroupnameAndSwapGroup group
		/// </summary>
		/// <param name="groupname">The name of the group.</param>
		/// <param name="swapGroup">The group to transfer restrictions to. Only comments and worklogs are transferred. If restrictions are not transferred, comments and worklogs will be inaccessible after the deletion.</param>
		/// <returns>Returned if the group was deleted.</returns>
		public async Task GroupDeleteByGroupnameAndSwapGroupAsync(string groupname, string swapGroup, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "group?groupname=" + (groupname==null? "" : Uri.EscapeDataString(groupname))+"&swapGroup=" + (swapGroup==null? "" : Uri.EscapeDataString(swapGroup));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// This resource is deprecated, use group/member.
		/// GroupGetByExpandAndGroupname group
		/// </summary>
		/// <param name="expand">List of fields to expand.</param>
		/// <param name="groupname">The name of the group.</param>
		/// <returns>Returned if the requested group is returned.</returns>
		public async Task GroupGetByExpandAndGroupnameAsync(string expand, string groupname, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "group?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&groupname=" + (groupname==null? "" : Uri.EscapeDataString(groupname));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a group.
		/// GroupPost group
		/// </summary>
		public async Task GroupPostAsync(GroupPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "group";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all users in a group. Users are ordered by username.
		/// GroupMemberGetByGroupnameAndIncludeInactiveUsersAndMaxResultsAndStartAt group/member
		/// </summary>
		/// <param name="groupname">The name of the group.</param>
		/// <param name="includeInactiveUsers">Include inactive users.</param>
		/// <param name="maxResults">The maximum number of users to return per page.</param>
		/// <param name="startAt">The index of the first user to return.</param>
		/// <returns>Returned if the requested group is returned.</returns>
		public async Task GroupMemberGetByGroupnameAndIncludeInactiveUsersAndMaxResultsAndStartAtAsync(string groupname, bool includeInactiveUsers, int maxResults, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "group/member?groupname=" + (groupname==null? "" : Uri.EscapeDataString(groupname))+"&includeInactiveUsers="+includeInactiveUsers+"&maxResults="+maxResults+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a user from a group. Permissions required: Administer Jira global permission.
		/// GroupUserDeleteByAccountidAndGroupnameAndUsername group/user
		/// </summary>
		/// <param name="accountid">The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192. Required, unless username is specified.</param>
		/// <param name="groupname">The name of the group.</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The username of the user. For example, admin. Required, unless accountId is specified.</param>
		/// <returns>Returned if the user is removed from the group.</returns>
		public async Task GroupUserDeleteByAccountidAndGroupnameAndUsernameAsync(string accountid, string groupname, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "group/user?accountid=" + (accountid==null? "" : Uri.EscapeDataString(accountid))+"&groupname=" + (groupname==null? "" : Uri.EscapeDataString(groupname))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a user to a group.
		/// GroupUserPostByGroupname group/user
		/// </summary>
		/// <param name="groupname">The name of the group.</param>
		public async Task GroupUserPostByGroupnameAsync(string groupname, GroupUserPostByGroupnameBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "group/user?groupname=" + (groupname==null? "" : Uri.EscapeDataString(groupname));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of groups whose names contain a query string. A list of group names can be provided to exclude groups from the results.
		/// GroupsPickerGetByAccountIdAndExcludeAndMaxResultsAndQueryAndUserName groups/picker
		/// </summary>
		/// <param name="accountId">Parameter not in use.</param>
		/// <param name="exclude">A list of groups to exclude from the result.</param>
		/// <param name="maxResults">The maximum number of groups to return. The maximum number of groups that can be returned is limited by the system property jira.ajax.autocomplete.limit.</param>
		/// <param name="query">The string to find in group names.</param>
		/// <param name="userName">Parameter not in use.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task GroupsPickerGetByAccountIdAndExcludeAndMaxResultsAndQueryAndUserNameAsync(string accountId, string[] exclude, int maxResults, string query, string userName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/picker?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&"+String.Join("&", exclude.Select(z => $"exclude={Uri.EscapeDataString(z.ToString())}"))+"&maxResults="+maxResults+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&userName=" + (userName==null? "" : Uri.EscapeDataString(userName));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of users and groups matching a string. The string is used:
		/// GroupuserpickerGetByAvatarSizeAndCaseInsensitiveAndExcludeConnectAddonsAndFieldIdAndIssueTypeIdAndMaxResultsAndProjectIdAndQueryAndShowAvatar groupuserpicker
		/// </summary>
		/// <param name="avatarSize">The size of the avatar to return. If an invalid value is provided, the default value is used.</param>
		/// <param name="caseInsensitive">Indicates whether the search for groups should be case insensitive.</param>
		/// <param name="excludeConnectAddons">Indicates whether Connect app users and groups should be excluded from the search results. If an invalid value is provided, the default value is used.</param>
		/// <param name="fieldId">The custom field ID of the field this request is for.</param>
		/// <param name="issueTypeId">The ID of an issue type that returned users and groups must have permission to view. To include multiple issue type IDs repeat this parameter, use of a comma separated list is not supported. Special values, such as -1 (all standard issue types) and -2 (all subtask issue types), are supported. This parameter is only used when fieldId is present.</param>
		/// <param name="maxResults">The maximum number of items to return in each list. The maximum is 1000.</param>
		/// <param name="projectId">The ID of a project that returned users and groups must have permission to view. To include multiple projects repeat this parameter, use of a comma separated list is not supported. This parameter is only used when fieldId is present.</param>
		/// <param name="query">The search string.</param>
		/// <param name="showAvatar">Indicates whether the user avatar should be returned. If an invalid value is provided, the default value is used.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task GroupuserpickerGetByAvatarSizeAndCaseInsensitiveAndExcludeConnectAddonsAndFieldIdAndIssueTypeIdAndMaxResultsAndProjectIdAndQueryAndShowAvatarAsync(string avatarSize, bool caseInsensitive, bool excludeConnectAddons, string fieldId, string[] issueTypeId, int maxResults, string[] projectId, string query, bool showAvatar, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groupuserpicker?avatarSize=" + (avatarSize==null? "" : Uri.EscapeDataString(avatarSize))+"&caseInsensitive="+caseInsensitive+"&excludeConnectAddons="+excludeConnectAddons+"&fieldId=" + (fieldId==null? "" : Uri.EscapeDataString(fieldId))+"&"+String.Join("&", issueTypeId.Select(z => $"issueTypeId={Uri.EscapeDataString(z.ToString())}"))+"&maxResults="+maxResults+"&"+String.Join("&", projectId.Select(z => $"projectId={Uri.EscapeDataString(z.ToString())}"))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&showAvatar="+showAvatar;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an issue or, where the option to create sub-tasks is enabled in Jira, a sub-task. A transition may be applied, to move the issue or sub-task to a workflow step other than the default start step, and issue properties set.
		/// IssuePostByUpdateHistory issue
		/// </summary>
		/// <param name="updateHistory">Indicates whether the project in which the issue is created is added to the user's Recently viewed project list, as shown under Projects in Jira.</param>
		public async Task IssuePostByUpdateHistoryAsync(bool updateHistory, IssuePostByUpdateHistoryBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue?updateHistory="+updateHistory;
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates issues and, where the option to create sub-tasks is enabled in Jira, sub-tasks. Transitions may be applied, to move the issues or sub-tasks to a workflow step other than the default start step, and issue properties set.
		/// IssueBulkPost issue/bulk
		/// </summary>
		public async Task IssueBulkPostAsync(IssueBulkPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/bulk";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns details of projects, issue types within projects, and, when requested, the create screen fields for each issue type for the user. Use the information to populate the requests in Create issue and Create issues.
		/// IssueCreatemetaGetByExpandAndIssuetypeIdsAndIssuetypeNamesAndProjectIdsAndProjectKeys issue/createmeta
		/// </summary>
		/// <param name="expand">Use expand to include additional information about in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="issuetypeIds">Comma-separated list of issue type IDs. May be specified multiple times and with issuetypeNames.</param>
		/// <param name="issuetypeNames">Comma-separated list of issue type names. May be specified multiple times and with issuetypeIds.</param>
		/// <param name="projectIds">Comma-separated list of project IDs. May be specified multiple times and with projectKeys.</param>
		/// <param name="projectKeys">Comma-separated list of project keys. May be specified multiple times and with projectIds.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueCreatemetaGetByExpandAndIssuetypeIdsAndIssuetypeNamesAndProjectIdsAndProjectKeysAsync(string expand, string[] issuetypeIds, string[] issuetypeNames, string[] projectIds, string[] projectKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/createmeta?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&"+String.Join("&", issuetypeIds.Select(z => $"issuetypeIds={Uri.EscapeDataString(z.ToString())}"))+"&"+String.Join("&", issuetypeNames.Select(z => $"issuetypeNames={Uri.EscapeDataString(z.ToString())}"))+"&"+String.Join("&", projectIds.Select(z => $"projectIds={Uri.EscapeDataString(z.ToString())}"))+"&"+String.Join("&", projectKeys.Select(z => $"projectKeys={Uri.EscapeDataString(z.ToString())}"));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of suggested issues matching the auto-completion query for the user executing this request. This operation checks the user's history and browsing context to return issue suggestions.
		/// IssuePickerGetByCurrentIssueKeyAndCurrentJQLAndCurrentProjectIdAndQueryAndShowSubTaskParentAndShowSubTasks issue/picker
		/// </summary>
		/// <param name="currentIssueKey">Key of the issue defining search context. The issue defining a context is excluded from the search results.</param>
		/// <param name="currentJQL">JQL that defines the search context. Only issues matching this JQL query are included in the results. Note that username and userkey have been deprecated as search terms for this parameter. See the migration guide for details. Use accountId instead.</param>
		/// <param name="currentProjectId">ID of a project defining search context. Only issues belonging to a given project are suggested.</param>
		/// <param name="query">Query used to filter issue search results.</param>
		/// <param name="showSubTaskParent">Set to false to exclude parent issue from the suggestions list if search is performed in the context of a sub-task.</param>
		/// <param name="showSubTasks">Set to false to exclude subtasks from the suggestions list.</param>
		/// <returns>Returns a list of issues matching the issue picker parameters.</returns>
		public async Task IssuePickerGetByCurrentIssueKeyAndCurrentJQLAndCurrentProjectIdAndQueryAndShowSubTaskParentAndShowSubTasksAsync(string currentIssueKey, string currentJQL, string currentProjectId, string query, bool showSubTaskParent, bool showSubTasks, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/picker?currentIssueKey=" + (currentIssueKey==null? "" : Uri.EscapeDataString(currentIssueKey))+"&currentJQL=" + (currentJQL==null? "" : Uri.EscapeDataString(currentJQL))+"&currentProjectId=" + (currentProjectId==null? "" : Uri.EscapeDataString(currentProjectId))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&showSubTaskParent="+showSubTaskParent+"&showSubTasks="+showSubTasks;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a property value from multiple issues. The issues to be updated can be specified by filter criteria.
		/// IssuePropertiesDeleteByPropertyKey issue/properties/{propertyKey}
		/// </summary>
		/// <param name="propertyKey">The key of the property.</param>
		public async Task IssuePropertiesDeleteByPropertyKeyAsync(string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets a property value on multiple issues. The issues to be updated can be specified by a filter.
		/// IssuePropertiesPutByPropertyKey issue/properties/{propertyKey}
		/// </summary>
		/// <param name="propertyKey">The key of the property. The maximum length is 255 characters.</param>
		public async Task IssuePropertiesPutByPropertyKeyAsync(string propertyKey, IssuePropertiesPutByPropertyKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an issue.
		/// IssueDeleteByDeleteSubtasksAndIssueIdOrKey issue/{issueIdOrKey}
		/// </summary>
		/// <param name="deleteSubtasks">Indicates whether the issue's sub-tasks are deleted when the issue is deleted.</param>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		public async Task IssueDeleteByDeleteSubtasksAndIssueIdOrKeyAsync(string deleteSubtasks, string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"?deleteSubtasks=" + (deleteSubtasks==null? "" : Uri.EscapeDataString(deleteSubtasks));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the details for an issue.
		/// IssueGetByExpandAndFieldsAndFieldsByKeysAndIssueIdOrKeyAndPropertiesAndUpdateHistory issue/{issueIdOrKey}
		/// </summary>
		/// <param name="expand">Use expand to include additional information about the issues in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="fields">A comma-separated list of fields to return for the issue. Use it to retrieve a subset of fields. Allowed values:</param>
		/// <param name="fieldsByKeys">Indicates whether fields in fields are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field's key may differ from its ID.</param>
		/// <param name="issueIdOrKey">The ID or key of the issue. For example, JRACLOUD-1549.</param>
		/// <param name="properties">A comma-separated list of issue properties to return for the issue. Allowed values:</param>
		/// <param name="updateHistory">Indicates whether the project in which the issue is created is added to the user's Recently viewed project list, as shown under Projects in Jira. This also populates the JQL issues search lastViewed field.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueGetByExpandAndFieldsAndFieldsByKeysAndIssueIdOrKeyAndPropertiesAndUpdateHistoryAsync(string expand, string[] fields, bool fieldsByKeys, string issueIdOrKey, string[] properties, bool updateHistory, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&"+String.Join("&", fields.Select(z => $"fields={Uri.EscapeDataString(z.ToString())}"))+"&fieldsByKeys="+fieldsByKeys+"&"+String.Join("&", properties.Select(z => $"properties={Uri.EscapeDataString(z.ToString())}"))+"&updateHistory="+updateHistory;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Edits an issue. A transition may be applied and issue properties updated as part of the edit.
		/// IssuePutByIssueIdOrKeyAndNotifyUsersAndOverrideEditableFlagAndOverrideScreenSecurity issue/{issueIdOrKey}
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="notifyUsers">Indicates whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn't have the necessary permission the request is ignored.</param>
		/// <param name="overrideEditableFlag">Indicates whether screen security should be overridden to enable uneditable fields to be edited. Available to Connect app users with admin permissions.</param>
		/// <param name="overrideScreenSecurity">Indicates whether screen security should be overridden to enable hidden fields to be edited. Available to Connect app users with admin permissions.</param>
		public async Task IssuePutByIssueIdOrKeyAndNotifyUsersAndOverrideEditableFlagAndOverrideScreenSecurityAsync(string issueIdOrKey, bool notifyUsers, bool overrideEditableFlag, bool overrideScreenSecurity, IssuePutByIssueIdOrKeyAndNotifyUsersAndOverrideEditableFlagAndOverrideScreenSecurityBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"&notifyUsers="+notifyUsers+"&overrideEditableFlag="+overrideEditableFlag+"&overrideScreenSecurity="+overrideScreenSecurity;
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Assigns an issue to a user. Use this operation when the calling user does not have the Edit Issues permission but has the Assign issue permission for the project that the issue is in.
		/// IssueAssigneePutByIssueIdOrKey issue/{issueIdOrKey}/assignee
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue to be assigned.</param>
		public async Task IssueAssigneePutByIssueIdOrKeyAsync(string issueIdOrKey, IssueAssigneePutByIssueIdOrKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/assignee";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds one or more attachments to an issue. Attachments are posted as multipart/form-data (RFC 1867).
		/// IssueAttachmentsPostByIssueIdOrKey issue/{issueIdOrKey}/attachments
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue that attachments are added to.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueAttachmentsPostByIssueIdOrKeyAsync(string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/attachments";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a paginated list of all updates of an issue, sorted by date, starting from the oldest.
		/// IssueChangelogGetByIssueIdOrKeyAndMaxResultsAndStartAt issue/{issueIdOrKey}/changelog
		/// </summary>
		/// <param name="issueIdOrKey">ID or key of the issue.</param>
		/// <param name="maxResults">Maximum number of items to return per page. See Pagination section for more details.</param>
		/// <param name="startAt">Page offset, ie. index of the first item returned in the page of results. Base index: 0.</param>
		/// <returns>returns a collection of changelogs associated with the issue, with count and pagination information.</returns>
		public async Task IssueChangelogGetByIssueIdOrKeyAndMaxResultsAndStartAtAsync(string issueIdOrKey, int maxResults, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/changelog&maxResults="+maxResults+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// to get comments for
		/// IssueCommentGetByExpandAndIssueIdOrKeyAndMaxResultsAndOrderByAndStartAt issue/{issueIdOrKey}/comment
		/// </summary>
		/// <param name="expand">optional flags: renderedBody (provides body rendered in HTML)</param>
		/// <param name="issueIdOrKey">to get comments for</param>
		/// <param name="maxResults">how many results on the page should be included. Defaults to 50.</param>
		/// <param name="orderBy">ordering of the results.</param>
		/// <param name="startAt">the page offset, if not specified then defaults to 0</param>
		/// <returns>returns a collection of comments associated with the issue, with count and pagination information.</returns>
		public async Task IssueCommentGetByExpandAndIssueIdOrKeyAndMaxResultsAndOrderByAndStartAtAsync(string expand, string issueIdOrKey, int maxResults, string orderBy, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/comment?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : Uri.EscapeDataString(orderBy))+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// a string containing the issue id or key the comment will be added to
		/// IssueCommentPostByExpandAndIssueIdOrKey issue/{issueIdOrKey}/comment
		/// </summary>
		/// <param name="expand">optional flags: renderedBody (provides body rendered in HTML)</param>
		/// <param name="issueIdOrKey">a string containing the issue id or key the comment will be added to</param>
		public async Task IssueCommentPostByExpandAndIssueIdOrKeyAsync(string expand, string issueIdOrKey, IssueCommentPostByExpandAndIssueIdOrKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/comment?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// a string containing the issue id or key the comment belongs to
		/// IssueCommentDeleteByIdAndIssueIdOrKey issue/{issueIdOrKey}/comment/{id}
		/// </summary>
		/// <param name="id">id of the comment to be deleted</param>
		/// <param name="issueIdOrKey">a string containing the issue id or key the comment belongs to</param>
		public async Task IssueCommentDeleteByIdAndIssueIdOrKeyAsync(string id, string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/comment/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// of the issue the comment belongs to
		/// IssueCommentGetByExpandAndIdAndIssueIdOrKey issue/{issueIdOrKey}/comment/{id}
		/// </summary>
		/// <param name="expand">optional flags: renderedBody (provides body rendered in HTML)</param>
		/// <param name="id">the ID of the comment to request</param>
		/// <param name="issueIdOrKey">of the issue the comment belongs to</param>
		/// <returns>Returns a full representation of a Jira comment in JSON format.</returns>
		public async Task IssueCommentGetByExpandAndIdAndIssueIdOrKeyAsync(string expand, string id, string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/comment/"+ (id==null? "" : Uri.EscapeDataString(id))+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// a string containing the issue id or key the comment belongs to
		/// IssueCommentPutByExpandAndIdAndIssueIdOrKey issue/{issueIdOrKey}/comment/{id}
		/// </summary>
		/// <param name="expand">optional flags: renderedBody (provides body rendered in HTML)</param>
		/// <param name="id">id of the comment to be updated</param>
		/// <param name="issueIdOrKey">a string containing the issue id or key the comment belongs to</param>
		/// <returns>Returned if update was successful</returns>
		public async Task IssueCommentPutByExpandAndIdAndIssueIdOrKeyAsync(string expand, string id, string issueIdOrKey, IssueCommentPutByExpandAndIdAndIssueIdOrKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/comment/"+ (id==null? "" : Uri.EscapeDataString(id))+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the edit screen fields for an issue that are visible to and editable by the user. Use the information to populate the requests in Edit issue.
		/// IssueEditmetaGetByIssueIdOrKeyAndOverrideEditableFlagAndOverrideScreenSecurity issue/{issueIdOrKey}/editmeta
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="overrideEditableFlag">Indicates whether non-editable fields should be returned. Available to connect app users with admin permissions.</param>
		/// <param name="overrideScreenSecurity">Indicates whether hidden fields should be returned. Available to connect app users with admin permissions.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueEditmetaGetByIssueIdOrKeyAndOverrideEditableFlagAndOverrideScreenSecurityAsync(string issueIdOrKey, bool overrideEditableFlag, bool overrideScreenSecurity, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/editmeta&overrideEditableFlag="+overrideEditableFlag+"&overrideScreenSecurity="+overrideScreenSecurity;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an email notification for an issue and adds it to the mail queue.
		/// IssueNotifyPostByIssueIdOrKey issue/{issueIdOrKey}/notify
		/// </summary>
		/// <param name="issueIdOrKey">ID or key of the issue that the notification is sent for.</param>
		public async Task IssueNotifyPostByIssueIdOrKeyAsync(string issueIdOrKey, IssueNotifyPostByIssueIdOrKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/notify";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the URIs and keys of an issue's properties.
		/// IssuePropertiesGetByIssueIdOrKey issue/{issueIdOrKey}/properties
		/// </summary>
		/// <param name="issueIdOrKey">The key or ID of the issue.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssuePropertiesGetByIssueIdOrKeyAsync(string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/properties";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an issue's property.
		/// IssuePropertiesDeleteByIssueIdOrKeyAndPropertyKey issue/{issueIdOrKey}/properties/{propertyKey}
		/// </summary>
		/// <param name="issueIdOrKey">The key or ID of the issue.</param>
		/// <param name="propertyKey">The key of the property.</param>
		public async Task IssuePropertiesDeleteByIssueIdOrKeyAndPropertyKeyAsync(string issueIdOrKey, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the key and value of an issue's property.
		/// IssuePropertiesGetByIssueIdOrKeyAndPropertyKey issue/{issueIdOrKey}/properties/{propertyKey}
		/// </summary>
		/// <param name="issueIdOrKey">The key or ID of the issue.</param>
		/// <param name="propertyKey">The key of the property.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssuePropertiesGetByIssueIdOrKeyAndPropertyKeyAsync(string issueIdOrKey, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the value of an issue's property. Use this resource to store custom data against an issue.
		/// IssuePropertiesPutByIssueIdOrKeyAndPropertyKey issue/{issueIdOrKey}/properties/{propertyKey}
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="propertyKey">The key of the issue property. The maximum length is 255 characters.</param>
		/// <returns>Returned if the issue property is updated.</returns>
		public async Task IssuePropertiesPutByIssueIdOrKeyAndPropertyKeyAsync(string issueIdOrKey, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the remote issue link from the issue using the link's global ID.
		/// IssueRemotelinkDeleteByGlobalIdAndIssueIdOrKey issue/{issueIdOrKey}/remotelink
		/// </summary>
		/// <param name="globalId">The global ID of a remote issue link.</param>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		public async Task IssueRemotelinkDeleteByGlobalIdAndIssueIdOrKeyAsync(string globalId, string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/remotelink?globalId=" + (globalId==null? "" : Uri.EscapeDataString(globalId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the remote issue links for an issue. When a remote issue link global ID is provided the record with that global ID is returned, otherwise all remote issue links are returned.
		/// IssueRemotelinkGetByGlobalIdAndIssueIdOrKey issue/{issueIdOrKey}/remotelink
		/// </summary>
		/// <param name="globalId">The global ID of the remote issue link.</param>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueRemotelinkGetByGlobalIdAndIssueIdOrKeyAsync(string globalId, string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/remotelink?globalId=" + (globalId==null? "" : Uri.EscapeDataString(globalId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates or updates a remote issue link for an issue.
		/// IssueRemotelinkPostByIssueIdOrKey issue/{issueIdOrKey}/remotelink
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <returns>Returned if the remote issue link is updated.</returns>
		public async Task IssueRemotelinkPostByIssueIdOrKeyAsync(string issueIdOrKey, IssueRemotelinkPostByIssueIdOrKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/remotelink";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a remote issue link from an issue.
		/// IssueRemotelinkDeleteByIssueIdOrKeyAndLinkId issue/{issueIdOrKey}/remotelink/{linkId}
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="linkId">The ID of a remote issue link.</param>
		public async Task IssueRemotelinkDeleteByIssueIdOrKeyAndLinkIdAsync(string issueIdOrKey, string linkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/remotelink/"+ (linkId==null? "" : Uri.EscapeDataString(linkId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a remote issue link for an issue.
		/// IssueRemotelinkGetByIssueIdOrKeyAndLinkId issue/{issueIdOrKey}/remotelink/{linkId}
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="linkId">The ID of the remote issue link.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueRemotelinkGetByIssueIdOrKeyAndLinkIdAsync(string issueIdOrKey, string linkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/remotelink/"+ (linkId==null? "" : Uri.EscapeDataString(linkId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a remote issue link for an issue.
		/// IssueRemotelinkPutByIssueIdOrKeyAndLinkId issue/{issueIdOrKey}/remotelink/{linkId}
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="linkId">The ID of the remote issue link.</param>
		public async Task IssueRemotelinkPutByIssueIdOrKeyAndLinkIdAsync(string issueIdOrKey, string linkId, IssueRemotelinkPutByIssueIdOrKeyAndLinkIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/remotelink/"+ (linkId==null? "" : Uri.EscapeDataString(linkId));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns either all transitions or a transition that can be performed by the user on an issue, based on the issue's status.
		/// IssueTransitionsGetByExpandAndIssueIdOrKeyAndSkipRemoteOnlyConditionAndTransitionId issue/{issueIdOrKey}/transitions
		/// </summary>
		/// <param name="expand">Use expand to include additional information about in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="skipRemoteOnlyCondition">Indicates whether transitions with the condition Hide From User Condition are included in the response.</param>
		/// <param name="transitionId">The ID of the transition.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueTransitionsGetByExpandAndIssueIdOrKeyAndSkipRemoteOnlyConditionAndTransitionIdAsync(string expand, string issueIdOrKey, bool skipRemoteOnlyCondition, string transitionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/transitions?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&skipRemoteOnlyCondition="+skipRemoteOnlyCondition+"&transitionId=" + (transitionId==null? "" : Uri.EscapeDataString(transitionId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen. Optionally, issue properties can be set.
		/// IssueTransitionsPostByIssueIdOrKey issue/{issueIdOrKey}/transitions
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		public async Task IssueTransitionsPostByIssueIdOrKeyAsync(string issueIdOrKey, IssueTransitionsPostByIssueIdOrKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/transitions";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a user's vote from an issue. This is the equivalent of the user clicking Unvote on an issue in Jira.
		/// IssueVotesDeleteByIssueIdOrKey issue/{issueIdOrKey}/votes
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		public async Task IssueVotesDeleteByIssueIdOrKeyAsync(string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/votes";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns details about the votes on an issue.
		/// IssueVotesGetByIssueIdOrKey issue/{issueIdOrKey}/votes
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueVotesGetByIssueIdOrKeyAsync(string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/votes";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds the user's vote to an issue. This is the equivalent of the user clicking Vote on an issue in Jira.
		/// IssueVotesPostByIssueIdOrKey issue/{issueIdOrKey}/votes
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		public async Task IssueVotesPostByIssueIdOrKeyAsync(string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/votes";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a user as a watcher of an issue.
		/// IssueWatchersDeleteByAccountIdAndIssueIdOrKeyAndUsername issue/{issueIdOrKey}/watchers
		/// </summary>
		/// <param name="accountId">The account ID of the user. Required if username is omitted, otherwise must be omitted.</param>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="username">The name of the user. Required if accountId is omitted, otherwise must be omitted.</param>
		public async Task IssueWatchersDeleteByAccountIdAndIssueIdOrKeyAndUsernameAsync(string accountId, string issueIdOrKey, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/watchers?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the watchers for an issue.
		/// IssueWatchersGetByIssueIdOrKey issue/{issueIdOrKey}/watchers
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <returns>Returned if the request is successful</returns>
		public async Task IssueWatchersGetByIssueIdOrKeyAsync(string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/watchers";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a user as a watcher of an issue. If no user is specified the calling user is added.
		/// IssueWatchersPostByIssueIdOrKey issue/{issueIdOrKey}/watchers
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		public async Task IssueWatchersPostByIssueIdOrKeyAsync(string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/watchers";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all worklogs for an issue.
		/// IssueWorklogGetByExpandAndIssueIdOrKeyAndMaxResultsAndStartAt issue/{issueIdOrKey}/worklog
		/// </summary>
		/// <param name="expand">Use expand to include additional information about worklogs in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 1048576.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <returns>Returned if the request is successful</returns>
		public async Task IssueWorklogGetByExpandAndIssueIdOrKeyAndMaxResultsAndStartAtAsync(string expand, string issueIdOrKey, int maxResults, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/worklog?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&maxResults="+maxResults+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a worklog to an issue.
		/// IssueWorklogPostByAdjustEstimateAndExpandAndIssueIdOrKeyAndNewEstimateAndNotifyUsersAndOverrideEditableFlagAndReduceBy issue/{issueIdOrKey}/worklog
		/// </summary>
		/// <param name="adjustEstimate">Defines how to update the issue's time estimate, the options are:</param>
		/// <param name="expand">Use expand to include additional information about work logs in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="issueIdOrKey">The ID or key the issue.</param>
		/// <param name="newEstimate">The value to set as the issue's remaining time estimate, as days (#d), hours (#h), or minutes (#m or #). For example, 2d. Required when adjustEstimate is new.</param>
		/// <param name="notifyUsers">Indicates whether users watching the issue are notified by email.</param>
		/// <param name="overrideEditableFlag">Indicates whether the worklog entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Only connect app users with admin scope permission can use this flag.</param>
		/// <param name="reduceBy">The amount to reduce the issue's remaining estimate by, as days (#d), hours (#h), or minutes (#m). For example, 2d. Required when adjustEstimate is manual.</param>
		public async Task IssueWorklogPostByAdjustEstimateAndExpandAndIssueIdOrKeyAndNewEstimateAndNotifyUsersAndOverrideEditableFlagAndReduceByAsync(string adjustEstimate, string expand, string issueIdOrKey, string newEstimate, bool notifyUsers, bool overrideEditableFlag, string reduceBy, IssueWorklogPostByAdjustEstimateAndExpandAndIssueIdOrKeyAndNewEstimateAndNotifyUsersAndOverrideEditableFlagAndReduceByBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/worklog?adjustEstimate=" + (adjustEstimate==null? "" : Uri.EscapeDataString(adjustEstimate))+"&expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&newEstimate=" + (newEstimate==null? "" : Uri.EscapeDataString(newEstimate))+"&notifyUsers="+notifyUsers+"&overrideEditableFlag="+overrideEditableFlag+"&reduceBy=" + (reduceBy==null? "" : Uri.EscapeDataString(reduceBy));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a worklog from an issue.
		/// IssueWorklogDeleteByAdjustEstimateAndIdAndIncreaseByAndIssueIdOrKeyAndNewEstimateAndNotifyUsersAndOverrideEditableFlag issue/{issueIdOrKey}/worklog/{id}
		/// </summary>
		/// <param name="adjustEstimate">Defines how to update the issue's time estimate, the options are:</param>
		/// <param name="id">The ID of the worklog.</param>
		/// <param name="increaseBy">The amount to increase the issue's remaining estimate by, as days (#d), hours (#h), or minutes (#m or #). For example, 2d. Required when adjustEstimate is manual.</param>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="newEstimate">The value to set as the issue's remaining time estimate, as days (#d), hours (#h), or minutes (#m or #). For example, 2d. Required when adjustEstimate is new.</param>
		/// <param name="notifyUsers">Indicates whether users watching the issue are notified by email.</param>
		/// <param name="overrideEditableFlag">Indicates whether the work log entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Only connect app users with admin permissions can use this flag.</param>
		public async Task IssueWorklogDeleteByAdjustEstimateAndIdAndIncreaseByAndIssueIdOrKeyAndNewEstimateAndNotifyUsersAndOverrideEditableFlagAsync(string adjustEstimate, string id, string increaseBy, string issueIdOrKey, string newEstimate, bool notifyUsers, bool overrideEditableFlag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/worklog/"+ (id==null? "" : Uri.EscapeDataString(id))+"?adjustEstimate=" + (adjustEstimate==null? "" : Uri.EscapeDataString(adjustEstimate))+"&increaseBy=" + (increaseBy==null? "" : Uri.EscapeDataString(increaseBy))+"&newEstimate=" + (newEstimate==null? "" : Uri.EscapeDataString(newEstimate))+"&notifyUsers="+notifyUsers+"&overrideEditableFlag="+overrideEditableFlag;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a worklog.
		/// IssueWorklogGetByExpandAndIdAndIssueIdOrKey issue/{issueIdOrKey}/worklog/{id}
		/// </summary>
		/// <param name="expand">Use expand to include additional information about work logs in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="id">The ID of the worklog.</param>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueWorklogGetByExpandAndIdAndIssueIdOrKeyAsync(string expand, string id, string issueIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/worklog/"+ (id==null? "" : Uri.EscapeDataString(id))+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a worklog.
		/// IssueWorklogPutByAdjustEstimateAndExpandAndIdAndIssueIdOrKeyAndNewEstimateAndNotifyUsersAndOverrideEditableFlag issue/{issueIdOrKey}/worklog/{id}
		/// </summary>
		/// <param name="adjustEstimate">Defines how to update the issue's time estimate, the options are:</param>
		/// <param name="expand">Use expand to include additional information about worklogs in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="id">The ID of the worklog.</param>
		/// <param name="issueIdOrKey">The ID or key the issue.</param>
		/// <param name="newEstimate">The value to set as the issue's remaining time estimate, as days (#d), hours (#h), or minutes (#m or #). For example, 2d. Required when adjustEstimate is new.</param>
		/// <param name="notifyUsers">Indicates whether users watching the issue are notified by email.</param>
		/// <param name="overrideEditableFlag">Indicates whether the worklog should be added to the issue even if the issue is not editable, for example, because the issue is closed. Only connect app users with admin permissions can use this flag.</param>
		/// <returns>Returned if the request is successful</returns>
		public async Task IssueWorklogPutByAdjustEstimateAndExpandAndIdAndIssueIdOrKeyAndNewEstimateAndNotifyUsersAndOverrideEditableFlagAsync(string adjustEstimate, string expand, string id, string issueIdOrKey, string newEstimate, bool notifyUsers, bool overrideEditableFlag, IssueWorklogPutByAdjustEstimateAndExpandAndIdAndIssueIdOrKeyAndNewEstimateAndNotifyUsersAndOverrideEditableFlagBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/worklog/"+ (id==null? "" : Uri.EscapeDataString(id))+"?adjustEstimate=" + (adjustEstimate==null? "" : Uri.EscapeDataString(adjustEstimate))+"&expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&newEstimate=" + (newEstimate==null? "" : Uri.EscapeDataString(newEstimate))+"&notifyUsers="+notifyUsers+"&overrideEditableFlag="+overrideEditableFlag;
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the keys of all properties for a worklog.
		/// IssueWorklogPropertiesGetByIssueIdOrKeyAndWorklogId issue/{issueIdOrKey}/worklog/{worklogId}/properties
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="worklogId">The ID of the worklog.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueWorklogPropertiesGetByIssueIdOrKeyAndWorklogIdAsync(string issueIdOrKey, string worklogId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/worklog/"+ (worklogId==null? "" : Uri.EscapeDataString(worklogId))+"/properties";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a worklog property.
		/// IssueWorklogPropertiesDeleteByIssueIdOrKeyAndPropertyKeyAndWorklogId issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="propertyKey">The key of the property.</param>
		/// <param name="worklogId">The ID of the worklog.</param>
		public async Task IssueWorklogPropertiesDeleteByIssueIdOrKeyAndPropertyKeyAndWorklogIdAsync(string issueIdOrKey, string propertyKey, string worklogId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/worklog/"+ (worklogId==null? "" : Uri.EscapeDataString(worklogId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the value of a worklog property.
		/// IssueWorklogPropertiesGetByIssueIdOrKeyAndPropertyKeyAndWorklogId issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="propertyKey">The key of the property.</param>
		/// <param name="worklogId">The ID of the worklog.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueWorklogPropertiesGetByIssueIdOrKeyAndPropertyKeyAndWorklogIdAsync(string issueIdOrKey, string propertyKey, string worklogId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/worklog/"+ (worklogId==null? "" : Uri.EscapeDataString(worklogId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the value of a worklog property. Use this operation to store custom data against the worklog.
		/// IssueWorklogPropertiesPutByIssueIdOrKeyAndPropertyKeyAndWorklogId issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}
		/// </summary>
		/// <param name="issueIdOrKey">The ID or key of the issue.</param>
		/// <param name="propertyKey">The key of the issue property. The maximum length is 255 characters.</param>
		/// <param name="worklogId">The ID of the worklog.</param>
		/// <returns>Returned if the worklog property is updated.</returns>
		public async Task IssueWorklogPropertiesPutByIssueIdOrKeyAndPropertyKeyAndWorklogIdAsync(string issueIdOrKey, string propertyKey, string worklogId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issue/"+ (issueIdOrKey==null? "" : Uri.EscapeDataString(issueIdOrKey))+"/worklog/"+ (worklogId==null? "" : Uri.EscapeDataString(worklogId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a link between two issues. Use this operation to indicate a relationship between two issues and optionally add a comment to the from (outward) issue. To use this resource the site must have Issue Linking enabled.
		/// IssueLinkPost issueLink
		/// </summary>
		public async Task IssueLinkPostAsync(IssueLinkPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issueLink";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an issue link.
		/// IssueLinkDeleteByLinkId issueLink/{linkId}
		/// </summary>
		/// <param name="linkId">The ID of the issue link.</param>
		/// <returns>200 response</returns>
		public async Task IssueLinkDeleteByLinkIdAsync(string linkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issueLink/"+ (linkId==null? "" : Uri.EscapeDataString(linkId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an issue link.
		/// IssueLinkGetByLinkId issueLink/{linkId}
		/// </summary>
		/// <param name="linkId">The ID of the issue link.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueLinkGetByLinkIdAsync(string linkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issueLink/"+ (linkId==null? "" : Uri.EscapeDataString(linkId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of all issue link types.
		/// IssueLinkTypeGet issueLinkType
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueLinkTypeGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issueLinkType";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an issue link type. Use this operation to create descriptions of the reasons why issues are linked. The issue link type consists of a name and descriptions for a link's inward and outward relationships.
		/// IssueLinkTypePost issueLinkType
		/// </summary>
		public async Task IssueLinkTypePostAsync(IssueLinkTypePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issueLinkType";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an issue link type.
		/// IssueLinkTypeDeleteByIssueLinkTypeId issueLinkType/{issueLinkTypeId}
		/// </summary>
		/// <param name="issueLinkTypeId">The ID of the issue link type.</param>
		public async Task IssueLinkTypeDeleteByIssueLinkTypeIdAsync(string issueLinkTypeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issueLinkType/"+ (issueLinkTypeId==null? "" : Uri.EscapeDataString(issueLinkTypeId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an issue link type.
		/// IssueLinkTypeGetByIssueLinkTypeId issueLinkType/{issueLinkTypeId}
		/// </summary>
		/// <param name="issueLinkTypeId">The ID of the issue link type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueLinkTypeGetByIssueLinkTypeIdAsync(string issueLinkTypeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issueLinkType/"+ (issueLinkTypeId==null? "" : Uri.EscapeDataString(issueLinkTypeId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an issue link type.
		/// IssueLinkTypePutByIssueLinkTypeId issueLinkType/{issueLinkTypeId}
		/// </summary>
		/// <param name="issueLinkTypeId">The ID of the issue link type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssueLinkTypePutByIssueLinkTypeIdAsync(string issueLinkTypeId, IssueLinkTypePutByIssueLinkTypeIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issueLinkType/"+ (issueLinkTypeId==null? "" : Uri.EscapeDataString(issueLinkTypeId));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all issue security schemes.
		/// IssuesecurityschemesGet issuesecurityschemes
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssuesecurityschemesGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuesecurityschemes";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an issue security scheme along with its security levels.
		/// IssuesecurityschemesGetById issuesecurityschemes/{id}
		/// </summary>
		/// <param name="id">The ID of the issue security scheme. Use the Get issue security schemes operation to get a list of issue security scheme IDs.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssuesecurityschemesGetByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuesecurityschemes/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all issue types. Permissions required: Permission to access Jira, however, only issue types that are visible to the user are returned.
		/// IssuetypeGet issuetype
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssuetypeGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an issue type and adds it to the default issue type scheme. Permissions required: Administer Jira global permission.
		/// IssuetypePost issuetype
		/// </summary>
		public async Task IssuetypePostAsync(IssuetypePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the issue type. If the issue type is in use, all uses are updated with the alternative issue type (alternativeIssueTypeId). A list of alternative issue types can be obtained from the Get alternative issue types resource. Permissions required: Administer Jira global permission.
		/// IssuetypeDeleteByAlternativeIssueTypeIdAndId issuetype/{id}
		/// </summary>
		/// <param name="alternativeIssueTypeId">The ID of the replacement issue type.</param>
		/// <param name="id">The ID of the issue type.</param>
		public async Task IssuetypeDeleteByAlternativeIssueTypeIdAndIdAsync(string alternativeIssueTypeId, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype/"+ (id==null? "" : Uri.EscapeDataString(id))+"?alternativeIssueTypeId=" + (alternativeIssueTypeId==null? "" : Uri.EscapeDataString(alternativeIssueTypeId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an issue type. Permissions required:
		/// IssuetypeGetById issuetype/{id}
		/// </summary>
		/// <param name="id">The ID of the issue type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssuetypeGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the issue type. Permissions required: Administer Jira global permission.
		/// IssuetypePutById issuetype/{id}
		/// </summary>
		/// <param name="id">The ID of the issue type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssuetypePutByIdAsync(string id, IssuetypePutByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of issue types that can be used to replace the issue type. The alternative issue types are those assigned to the same workflow scheme, field configuration scheme, and screen scheme. Permissions required: Permission to access Jira.
		/// IssuetypeAlternativesGetById issuetype/{id}/alternatives
		/// </summary>
		/// <param name="id">The ID of the issue type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssuetypeAlternativesGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype/"+ (id==null? "" : Uri.EscapeDataString(id))+"/alternatives";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Loads an avatar for the issue type.
		/// IssuetypeAvatar2PostByIdAndSizeAndXAndY issuetype/{id}/avatar2
		/// </summary>
		/// <param name="id">The ID of the issue type.</param>
		/// <param name="size">The length of each side of the crop region.</param>
		/// <param name="x">The X coordinate of the top-left corner of the crop region.</param>
		/// <param name="y">The Y coordinate of the top-left corner of the crop region.</param>
		public async Task IssuetypeAvatar2PostByIdAndSizeAndXAndYAsync(string id, int size, int x, int y, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype/"+ (id==null? "" : Uri.EscapeDataString(id))+"/avatar2&size="+size+"&x="+x+"&y="+y;
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all the issue type property keys of the issue type. Permissions required:
		/// IssuetypePropertiesGetByIssueTypeId issuetype/{issueTypeId}/properties
		/// </summary>
		/// <param name="issueTypeId">The ID of the issue type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssuetypePropertiesGetByIssueTypeIdAsync(string issueTypeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype/"+ (issueTypeId==null? "" : Uri.EscapeDataString(issueTypeId))+"/properties";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the issue type property. Permissions required: Administer Jira global permission.
		/// IssuetypePropertiesDeleteByIssueTypeIdAndPropertyKey issuetype/{issueTypeId}/properties/{propertyKey}
		/// </summary>
		/// <param name="issueTypeId">The ID of the issue type.</param>
		/// <param name="propertyKey">The key of the property. Use Get issue type property keys to get a list of all issue type property keys.</param>
		public async Task IssuetypePropertiesDeleteByIssueTypeIdAndPropertyKeyAsync(string issueTypeId, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype/"+ (issueTypeId==null? "" : Uri.EscapeDataString(issueTypeId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the key and value of the issue type property. Permissions required:
		/// IssuetypePropertiesGetByIssueTypeIdAndPropertyKey issuetype/{issueTypeId}/properties/{propertyKey}
		/// </summary>
		/// <param name="issueTypeId">The ID of the issue type.</param>
		/// <param name="propertyKey">The key of the property. Use Get issue type property keys to get a list of all issue type property keys.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task IssuetypePropertiesGetByIssueTypeIdAndPropertyKeyAsync(string issueTypeId, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype/"+ (issueTypeId==null? "" : Uri.EscapeDataString(issueTypeId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates or updates the value of the issue type property. Use this resource to store and update data against an issue type. The value of the request body must be a valid, non-empty JSON blob. The maximum length of the property value is 32768 bytes. Permissions required: Administer Jira global permission.
		/// IssuetypePropertiesPutByIssueTypeIdAndPropertyKey issuetype/{issueTypeId}/properties/{propertyKey}
		/// </summary>
		/// <param name="issueTypeId">The ID of the issue type.</param>
		/// <param name="propertyKey">The key of the issue type property. The maximum length of the key is 255 bytes.</param>
		/// <returns>Returned if the issue type property is updated.</returns>
		public async Task IssuetypePropertiesPutByIssueTypeIdAndPropertyKeyAsync(string issueTypeId, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issuetype/"+ (issueTypeId==null? "" : Uri.EscapeDataString(issueTypeId))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns reference data for JQL searches. This is a downloadable version of the documentation provided in Advanced searching - fields reference and Advanced searching - functions reference, along with a list of JQL-reserved words. Use this information to assist with the programmatic creation of JQL queries or the validation of queries built in a custom query builder.
		/// JqlAutocompletedataGet jql/autocompletedata
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task JqlAutocompletedataGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jql/autocompletedata";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the JQL search auto complete suggestions for a field.
		/// JqlAutocompletedataSuggestionsGetByFieldNameAndFieldValueAndPredicateNameAndPredicateValue jql/autocompletedata/suggestions
		/// </summary>
		/// <param name="fieldName">The name of the field.</param>
		/// <param name="fieldValue">The partial field item name entered by the user.</param>
		/// <param name="predicateName">The name of the CHANGED operator predicate for which the suggestions are generated. The valid predicate operators are by, from, and to.</param>
		/// <param name="predicateValue">The partial predicate item name entered by the user.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task JqlAutocompletedataSuggestionsGetByFieldNameAndFieldValueAndPredicateNameAndPredicateValueAsync(string fieldName, string fieldValue, string predicateName, string predicateValue, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jql/autocompletedata/suggestions?fieldName=" + (fieldName==null? "" : Uri.EscapeDataString(fieldName))+"&fieldValue=" + (fieldValue==null? "" : Uri.EscapeDataString(fieldValue))+"&predicateName=" + (predicateName==null? "" : Uri.EscapeDataString(predicateName))+"&predicateValue=" + (predicateValue==null? "" : Uri.EscapeDataString(predicateValue));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The query strings having personal data that need to be migrated. There should be at most 100 queries.
		/// JqlPdcleanerPost jql/pdcleaner
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task JqlPdcleanerPostAsync(JqlPdcleanerPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jql/pdcleaner";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of permissions indicating which permissions the user has. Details of the user's permissions can be obtained in a global, project, or issue context.
		/// MypermissionsGetByIssueIdAndIssueKeyAndPermissionsAndProjectIdAndProjectKey mypermissions
		/// </summary>
		/// <param name="issueId">The ID of the issue.</param>
		/// <param name="issueKey">The key of the issue. Ignored if issueId is provided.</param>
		/// <param name="permissions">A comma separated list of permission keys. Omitting this parameter is deprecated. To get the list of available permissions, use Get all permissions. Note that deprecated keys cannot be used. Deprecated keys are not returned by Get all permissions but are returned by this operation if permissions is omitted.</param>
		/// <param name="projectId">The ID of project.</param>
		/// <param name="projectKey">The key of project. Ignored if projectId is provided.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task MypermissionsGetByIssueIdAndIssueKeyAndPermissionsAndProjectIdAndProjectKeyAsync(string issueId, string issueKey, string permissions, string projectId, string projectKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mypermissions?issueId=" + (issueId==null? "" : Uri.EscapeDataString(issueId))+"&issueKey=" + (issueKey==null? "" : Uri.EscapeDataString(issueKey))+"&permissions=" + (permissions==null? "" : Uri.EscapeDataString(permissions))+"&projectId=" + (projectId==null? "" : Uri.EscapeDataString(projectId))+"&projectKey=" + (projectKey==null? "" : Uri.EscapeDataString(projectKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a preference of the user, which restores the default value of system defined settings.
		/// MypreferencesDeleteByKey mypreferences
		/// </summary>
		/// <param name="key">The key of the preference.</param>
		public async Task MypreferencesDeleteByKeyAsync(string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mypreferences?key=" + (key==null? "" : Uri.EscapeDataString(key));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the value of a preference of the user.
		/// MypreferencesGetByKey mypreferences
		/// </summary>
		/// <param name="key">The key of the preference.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task MypreferencesGetByKeyAsync(string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mypreferences?key=" + (key==null? "" : Uri.EscapeDataString(key));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a preference for the user or updates its value. An arbitrary preference can be created with the value containing up to 255 characters. In addition, the following keys define system preferences that can be set or created:
		/// MypreferencesPutByKey mypreferences
		/// </summary>
		/// <param name="key">The key of the preference. Maximum length is 255 characters.</param>
		public async Task MypreferencesPutByKeyAsync(string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mypreferences?key=" + (key==null? "" : Uri.EscapeDataString(key));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the locale of the current user, which restores the default setting.
		/// MypreferencesLocaleDelete mypreferences/locale
		/// </summary>
		public async Task MypreferencesLocaleDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mypreferences/locale";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the locale for the current user.
		/// MypreferencesLocaleGet mypreferences/locale
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task MypreferencesLocaleGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mypreferences/locale";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the locale of the current user. The requested locale must be one supported by the instance of Jira.
		/// MypreferencesLocalePut mypreferences/locale
		/// </summary>
		public async Task MypreferencesLocalePutAsync(MypreferencesLocalePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mypreferences/locale";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns details for the authenticated user.
		/// MyselfGetByExpand myself
		/// </summary>
		/// <param name="expand">Use expand to include additional information about user in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task MyselfGetByExpandAsync(string expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "myself?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a paginated list of notification schemes in order by display name.
		/// NotificationschemeGetByExpandAndMaxResultsAndStartAt notificationscheme
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="maxResults">The maximum number of items to return per page. Max is 50.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset). The base index is 0.</param>
		/// <returns>Returned if the request is successful. Only returns notification schemes that the user has permission to access. An empty list is returned if the requesting user lacks permission to access all notification schemes.</returns>
		public async Task NotificationschemeGetByExpandAndMaxResultsAndStartAtAsync(string expand, int maxResults, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "notificationscheme?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&maxResults="+maxResults+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a notification scheme, including the list of events and the recipients who will receive notifications for those events.
		/// NotificationschemeGetByExpandAndId notificationscheme/{id}
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="id">The ID of the notification scheme. Use Get notification schemes paginated to get a list of notification scheme IDs.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task NotificationschemeGetByExpandAndIdAsync(string expand, int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "notificationscheme/"+id+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all permissions, including:
		/// PermissionsGet permissions
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task PermissionsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissions";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all the projects where the user is granted a list of project permissions.
		/// PermissionsProjectPost permissions/project
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task PermissionsProjectPostAsync(PermissionsProjectPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissions/project";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all permission schemes.
		/// PermissionschemeGetByExpand permissionscheme
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that permissions are included when you specify any value:</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task PermissionschemeGetByExpandAsync(string expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissionscheme?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new permission scheme. You can create a permission scheme with or without defining a set of permission grants. Permissions required: Administer Jira global permission.
		/// PermissionschemePostByExpand permissionscheme
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that permissions are always included when you specify any value:</param>
		public async Task PermissionschemePostByExpandAsync(string expand, PermissionschemePostByExpandBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissionscheme?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a permission scheme. Permissions required: Administer Jira global permission.
		/// PermissionschemeDeleteBySchemeId permissionscheme/{schemeId}
		/// </summary>
		/// <param name="schemeId">The ID of the permission scheme being deleted (e.g., 10000).</param>
		public async Task PermissionschemeDeleteBySchemeIdAsync(int schemeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissionscheme/"+schemeId;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a permission scheme. Permissions required: Permission to log in to Jira.
		/// PermissionschemeGetByExpandAndSchemeId permissionscheme/{schemeId}
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that permissions are included when you specify any value:</param>
		/// <param name="schemeId">The ID of the permission scheme to return (e.g., 10000).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task PermissionschemeGetByExpandAndSchemeIdAsync(string expand, int schemeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissionscheme/"+schemeId+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a permission scheme. Below are some important things to note when using this resource:
		/// PermissionschemePutByExpandAndSchemeId permissionscheme/{schemeId}
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that permissions are always included when you specify any value:</param>
		/// <param name="schemeId">The ID of the permission scheme to update (e.g., 10000).</param>
		/// <returns>Returned if the scheme is updated successfully.</returns>
		public async Task PermissionschemePutByExpandAndSchemeIdAsync(string expand, int schemeId, PermissionschemePutByExpandAndSchemeIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissionscheme/"+schemeId+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all permission grants for a permission scheme. Permissions required: Permission to log in to Jira.
		/// PermissionschemePermissionGetByExpandAndSchemeId permissionscheme/{schemeId}/permission
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that permissions are always included when you specify any value:</param>
		/// <param name="schemeId">The ID of the permission scheme (e.g., 10010).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task PermissionschemePermissionGetByExpandAndSchemeIdAsync(string expand, int schemeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissionscheme/"+schemeId+"/permission?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new permission grant in the given permission scheme. Permissions required: Administer Jira global permission.
		/// PermissionschemePermissionPostByExpandAndSchemeId permissionscheme/{schemeId}/permission
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that permissions are always included when you specify any value:</param>
		/// <param name="schemeId">The ID of the permission scheme in which to create a new permission grant.</param>
		public async Task PermissionschemePermissionPostByExpandAndSchemeIdAsync(string expand, int schemeId, PermissionschemePermissionPostByExpandAndSchemeIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissionscheme/"+schemeId+"/permission?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a permission grant from a permission scheme. See About permission schemes and grants for more details. Permissions required: Administer Jira global permission.
		/// PermissionschemePermissionDeleteByPermissionIdAndSchemeId permissionscheme/{schemeId}/permission/{permissionId}
		/// </summary>
		/// <param name="permissionId">The ID of the permission grant to delete (e.g., 10847).</param>
		/// <param name="schemeId">The ID of the permission scheme to delete the permission grant from (e.g., 10000).</param>
		public async Task PermissionschemePermissionDeleteByPermissionIdAndSchemeIdAsync(int permissionId, int schemeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissionscheme/"+schemeId+"/permission/"+permissionId;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a permission grant. Permissions required: Permission to log in to Jira.
		/// PermissionschemePermissionGetByExpandAndPermissionIdAndSchemeId permissionscheme/{schemeId}/permission/{permissionId}
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that permissions are always included when you specify any value:</param>
		/// <param name="permissionId">The ID of the permission grant (e.g., 10000).</param>
		/// <param name="schemeId">The ID of the permission scheme (e.g., 10010).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task PermissionschemePermissionGetByExpandAndPermissionIdAndSchemeIdAsync(string expand, int permissionId, int schemeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissionscheme/"+schemeId+"/permission/"+permissionId+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the list of all issue priorities.
		/// PriorityGet priority
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task PriorityGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "priority";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an issue priority.
		/// PriorityGetById priority/{id}
		/// </summary>
		/// <param name="id">The ID of the issue priority.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task PriorityGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "priority/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all projects visible to the currently logged in user. Deprecated, use Get projects paginated that supports search and pagination. For projects to be visible, the authenticated user must be granted either Browse projects or Administer projects permissions. If no user is logged in, it returns all projects that are visible for anonymous users.
		/// ProjectGetByExpandAndRecent project
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="recent">Returns the most recently accessed projects for the current user. You may specify the number of results to return up to a maximum of 20. If no user is logged in, then the recently accessed projects will be returned based on the current HTTP session.</param>
		/// <returns>Returns a list of projects visible to the current user or visible with anonymous access if no user is logged in.</returns>
		public async Task ProjectGetByExpandAndRecentAsync(string expand, int recent, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&recent="+recent;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new project.
		/// ProjectPost project
		/// </summary>
		public async Task ProjectPostAsync(ProjectPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns projects visible to the currently logged in user. For projects to be visible, the authenticated user must be granted either Browse projects or Administer projects permissions. If no user is logged in, then all projects visible to anonymous users are returned.
		/// ProjectSearchGetByActionAndCategoryIdAndExpandAndMaxResultsAndOrderByAndQueryAndStartAtAndTypeKey project/search
		/// </summary>
		/// <param name="action">Filter results by projects for which the calling user has permission to perform the given action. The view action corresponds with the Browse projects project permission, and the edit action corresponds with Administer project permissions.</param>
		/// <param name="categoryId">The ID of the project's category. A complete list of category IDs can be found using the Get all project categories resource.</param>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="maxResults">The maximum number of items to return per page. Max 50.</param>
		/// <param name="orderBy">Order the results by a particular field. If the orderBy field is not set, then projects are listed in ascending order by project key:</param>
		/// <param name="query">Filter the results using a literal string. Projects with a matching key or name are returned (case insensitive).</param>
		/// <param name="startAt">The starting index of the first item returned in the page of results (page offset). The base index is 0.</param>
		/// <param name="typeKey">Orders results by the project type. This parameter accepts multiple values separated by a comma. Valid values are business, service_desk, and software.</param>
		/// <returns>Returned if the request is successful. Returns a single page of projects.</returns>
		public async Task ProjectSearchGetByActionAndCategoryIdAndExpandAndMaxResultsAndOrderByAndQueryAndStartAtAndTypeKeyAsync(string action, int categoryId, string expand, int maxResults, string orderBy, string query, int startAt, string typeKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/search?action=" + (action==null? "" : Uri.EscapeDataString(action))+"&categoryId="+categoryId+"&expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : Uri.EscapeDataString(orderBy))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&startAt="+startAt+"&typeKey=" + (typeKey==null? "" : Uri.EscapeDataString(typeKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all project types, whether or not the instance has a valid license for each type.
		/// ProjectTypeGet project/type
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectTypeGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/type";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a project type.
		/// ProjectTypeGetByProjectTypeKey project/type/{projectTypeKey}
		/// </summary>
		/// <param name="projectTypeKey">The key of the project type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectTypeGetByProjectTypeKeyAsync(string projectTypeKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/type/"+ (projectTypeKey==null? "" : Uri.EscapeDataString(projectTypeKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a project type if it is accessible to the logged in user.
		/// ProjectTypeAccessibleGetByProjectTypeKey project/type/{projectTypeKey}/accessible
		/// </summary>
		/// <param name="projectTypeKey">The key of the project type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectTypeAccessibleGetByProjectTypeKeyAsync(string projectTypeKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/type/"+ (projectTypeKey==null? "" : Uri.EscapeDataString(projectTypeKey))+"/accessible";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing project.
		/// ProjectDeleteByProjectIdOrKey project/{projectIdOrKey}
		/// </summary>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		public async Task ProjectDeleteByProjectIdOrKeyAsync(string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the project details for the specified project.
		/// ProjectGetByExpandAndProjectIdOrKey project/{projectIdOrKey}
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that the project description, issue types, and project lead are included in all responses by default:</param>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if successful.</returns>
		public async Task ProjectGetByExpandAndProjectIdOrKeyAsync(string expand, string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the project details of an existing project.
		/// ProjectPutByExpandAndProjectIdOrKey project/{projectIdOrKey}
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that the project description, issue types, and project lead are included in all responses by default:</param>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the project was updated successfully.</returns>
		public async Task ProjectPutByExpandAndProjectIdOrKeyAsync(string expand, string projectIdOrKey, ProjectPutByExpandAndProjectIdOrKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the avatar displayed for a project.
		/// ProjectAvatarPutByProjectIdOrKey project/{projectIdOrKey}/avatar
		/// </summary>
		/// <param name="projectIdOrKey">The ID or (case-sensitive) key of the project.</param>
		public async Task ProjectAvatarPutByProjectIdOrKeyAsync(string projectIdOrKey, ProjectAvatarPutByProjectIdOrKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/avatar";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a custom avatar from a project. Note that system avatars cannot be deleted.
		/// ProjectAvatarDeleteByIdAndProjectIdOrKey project/{projectIdOrKey}/avatar/{id}
		/// </summary>
		/// <param name="id">The ID of the avatar.</param>
		/// <param name="projectIdOrKey">The project ID or (case-sensitive) key.</param>
		public async Task ProjectAvatarDeleteByIdAndProjectIdOrKeyAsync(int id, string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/avatar/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Loads an avatar for a project.
		/// ProjectAvatar2PostByProjectIdOrKeyAndSizeAndXAndY project/{projectIdOrKey}/avatar2
		/// </summary>
		/// <param name="projectIdOrKey">The ID or (case-sensitive) key of the project.</param>
		/// <param name="size">The length of each side of the crop region.</param>
		/// <param name="x">The X coordinate of the top-left corner of the crop region.</param>
		/// <param name="y">The Y coordinate of the top-left corner of the crop region.</param>
		public async Task ProjectAvatar2PostByProjectIdOrKeyAndSizeAndXAndYAsync(string projectIdOrKey, int size, int x, int y, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/avatar2&size="+size+"&x="+x+"&y="+y;
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all project avatars, grouped by system and custom avatars.
		/// ProjectAvatarsGetByProjectIdOrKey project/{projectIdOrKey}/avatars
		/// </summary>
		/// <param name="projectIdOrKey">The ID or (case-sensitive) key of the project.</param>
		/// <returns>Returned if request is successful.</returns>
		public async Task ProjectAvatarsGetByProjectIdOrKeyAsync(string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/avatars";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a paginated representation of all components existing in a single project. See the Get project components resource if you want to get a full list of versions without pagination.
		/// ProjectComponentGetByMaxResultsAndOrderByAndProjectIdOrKeyAndQueryAndStartAt project/{projectIdOrKey}/component
		/// </summary>
		/// <param name="maxResults">The maximum number of components to return per page. Max 50.</param>
		/// <param name="orderBy">Order the results by a particular field:</param>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <param name="query">Filter the results using a literal string. Components with a matching name or description are returned (case insensitive).</param>
		/// <param name="startAt">The starting index of the returned list of components. The base index is 0.</param>
		/// <returns>Returns a single page of components.</returns>
		public async Task ProjectComponentGetByMaxResultsAndOrderByAndProjectIdOrKeyAndQueryAndStartAtAsync(int maxResults, string orderBy, string projectIdOrKey, string query, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/component?maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : Uri.EscapeDataString(orderBy))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all components existing in a single project. See the Get project components paginated resource if you want to get a full list of components with pagination.
		/// ProjectComponentsGetByProjectIdOrKey project/{projectIdOrKey}/components
		/// </summary>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the project exists and the user has permission to view its components.</returns>
		public async Task ProjectComponentsGetByProjectIdOrKeyAsync(string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/components";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all project property keys for the project.
		/// ProjectPropertiesGetByProjectIdOrKey project/{projectIdOrKey}/properties
		/// </summary>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the request was successful.</returns>
		public async Task ProjectPropertiesGetByProjectIdOrKeyAsync(string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/properties";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes the property from the project.
		/// ProjectPropertiesDeleteByProjectIdOrKeyAndPropertyKey project/{projectIdOrKey}/properties/{propertyKey}
		/// </summary>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <param name="propertyKey">The project property key. Use Get project property keys to get a list of all project property keys.</param>
		public async Task ProjectPropertiesDeleteByProjectIdOrKeyAndPropertyKeyAsync(string projectIdOrKey, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the value of the project property.
		/// ProjectPropertiesGetByProjectIdOrKeyAndPropertyKey project/{projectIdOrKey}/properties/{propertyKey}
		/// </summary>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <param name="propertyKey">The project property key. Use Get project property keys to get a list of all project property keys.</param>
		/// <returns>Returned if the request was successful.</returns>
		public async Task ProjectPropertiesGetByProjectIdOrKeyAndPropertyKeyAsync(string projectIdOrKey, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the value of the project property. You can use project properties to store custom data against the project.
		/// ProjectPropertiesPutByProjectIdOrKeyAndPropertyKey project/{projectIdOrKey}/properties/{propertyKey}
		/// </summary>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <param name="propertyKey">The key of the project property. The maximum length is 255 bytes.</param>
		/// <returns>Returned if the project property is successfully updated.</returns>
		public async Task ProjectPropertiesPutByProjectIdOrKeyAndPropertyKeyAsync(string projectIdOrKey, string propertyKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of project roles for the project.
		/// ProjectRoleGetByProjectIdOrKey project/{projectIdOrKey}/role
		/// </summary>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectRoleGetByProjectIdOrKeyAsync(string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/role";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes actors from a project role for the project.
		/// ProjectRoleDeleteByGroupAndIdAndProjectIdOrKeyAndUser project/{projectIdOrKey}/role/{id}
		/// </summary>
		/// <param name="group">The name of the group to remove from the project role.</param>
		/// <param name="id">The ID of the project role. Use Get all project roles to get a list of project role IDs.</param>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <param name="user">The user account ID of the user to remove from the project role.</param>
		public async Task ProjectRoleDeleteByGroupAndIdAndProjectIdOrKeyAndUserAsync(string group, int id, string projectIdOrKey, string user, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/role/"+id+"?group=" + (group==null? "" : Uri.EscapeDataString(group))+"&user=" + (user==null? "" : Uri.EscapeDataString(user));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the project role's details and actors associated with the project. The list of actors is sorted by display name.
		/// ProjectRoleGetByIdAndProjectIdOrKey project/{projectIdOrKey}/role/{id}
		/// </summary>
		/// <param name="id">The ID of the project role. Use Get all project roles to get a list of project role IDs.</param>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectRoleGetByIdAndProjectIdOrKeyAsync(int id, string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/role/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds additional actors to a project role for the project.
		/// ProjectRolePostByIdAndProjectIdOrKey project/{projectIdOrKey}/role/{id}
		/// </summary>
		/// <param name="id">The ID of the project role. Use Get all project roles to get a list of project role IDs.</param>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Example response (application/json)</returns>
		public async Task ProjectRolePostByIdAndProjectIdOrKeyAsync(int id, string projectIdOrKey, ProjectRolePostByIdAndProjectIdOrKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/role/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Associates actors with the project role for the project, replacing all existing actors.
		/// ProjectRolePutByIdAndProjectIdOrKey project/{projectIdOrKey}/role/{id}
		/// </summary>
		/// <param name="id">The ID of the project role. Use Get all project roles to get a list of project role IDs.</param>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the request is successful. The complete list of actors for the project is returned.</returns>
		public async Task ProjectRolePutByIdAndProjectIdOrKeyAsync(int id, string projectIdOrKey, ProjectRolePutByIdAndProjectIdOrKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/role/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all project roles and the details for each role. Note that the list of project roles is common to all projects.
		/// ProjectRoledetailsGetByProjectIdOrKey project/{projectIdOrKey}/roledetails
		/// </summary>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectRoledetailsGetByProjectIdOrKeyAsync(string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/roledetails";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the valid statuses for a project. The statuses are grouped by issue type, as each project has a set of valid issue types and each issue type has a set of valid statuses.
		/// ProjectStatusesGetByProjectIdOrKey project/{projectIdOrKey}/statuses
		/// </summary>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returns a list of issue types and valid statuses for each type.</returns>
		public async Task ProjectStatusesGetByProjectIdOrKeyAsync(string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/statuses";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the project type.
		/// ProjectTypePutByNewProjectTypeKeyAndProjectIdOrKey project/{projectIdOrKey}/type/{newProjectTypeKey}
		/// </summary>
		/// <param name="newProjectTypeKey">The key of the new project type.</param>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the project type was updated successfully.</returns>
		public async Task ProjectTypePutByNewProjectTypeKeyAndProjectIdOrKeyAsync(string newProjectTypeKey, string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/type/"+ (newProjectTypeKey==null? "" : Uri.EscapeDataString(newProjectTypeKey));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a paginated representation of all versions existing in a single project. See the Get project versions resource if you want to get a full list of versions without pagination.
		/// ProjectVersionGetByExpandAndMaxResultsAndOrderByAndProjectIdOrKeyAndQueryAndStartAtAndStatus project/{projectIdOrKey}/version
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="maxResults">The maximum number of versions to return per page. Max 50.</param>
		/// <param name="orderBy">Order the results by a particular field:</param>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <param name="query">Filter the results using a literal string. Versions with matching name or description are returned (case insensitive).</param>
		/// <param name="startAt">The starting index of the returned list of versions (page offset). The base index is 0.</param>
		/// <param name="status">A comma separated string used to filter the results by version status.</param>
		/// <returns>Returns a single page of versions.</returns>
		public async Task ProjectVersionGetByExpandAndMaxResultsAndOrderByAndProjectIdOrKeyAndQueryAndStartAtAndStatusAsync(string expand, int maxResults, string orderBy, string projectIdOrKey, string query, int startAt, string status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/version?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : Uri.EscapeDataString(orderBy))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&startAt="+startAt+"&status=" + (status==null? "" : Uri.EscapeDataString(status));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all versions existing in a single project. The response is not paginated. Use Get project versions paginated if you want to get the versions in a project with pagination.
		/// ProjectVersionsGetByExpandAndProjectIdOrKey project/{projectIdOrKey}/versions
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="projectIdOrKey">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if successful.</returns>
		public async Task ProjectVersionsGetByExpandAndProjectIdOrKeyAsync(string expand, string projectIdOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectIdOrKey==null? "" : Uri.EscapeDataString(projectIdOrKey))+"/versions?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the issue security scheme associated with the project.
		/// ProjectIssuesecuritylevelschemeGetByProjectKeyOrId project/{projectKeyOrId}/issuesecuritylevelscheme
		/// </summary>
		/// <param name="projectKeyOrId">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectIssuesecuritylevelschemeGetByProjectKeyOrIdAsync(string projectKeyOrId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectKeyOrId==null? "" : Uri.EscapeDataString(projectKeyOrId))+"/issuesecuritylevelscheme";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a notification scheme associated with the project. See the Get notification scheme resource for more information about notification schemes.
		/// ProjectNotificationschemeGetByExpandAndProjectKeyOrId project/{projectKeyOrId}/notificationscheme
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="projectKeyOrId">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectNotificationschemeGetByExpandAndProjectKeyOrIdAsync(string expand, string projectKeyOrId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectKeyOrId==null? "" : Uri.EscapeDataString(projectKeyOrId))+"/notificationscheme?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the permission scheme associated with the project.
		/// ProjectPermissionschemeGetByExpandAndProjectKeyOrId project/{projectKeyOrId}/permissionscheme
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that permissions are included when you specify any value:</param>
		/// <param name="projectKeyOrId">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectPermissionschemeGetByExpandAndProjectKeyOrIdAsync(string expand, string projectKeyOrId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectKeyOrId==null? "" : Uri.EscapeDataString(projectKeyOrId))+"/permissionscheme?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Associates a permission scheme with a particular project. See Managing project permissions for more information about permission schemes.
		/// ProjectPermissionschemePutByExpandAndProjectKeyOrId project/{projectKeyOrId}/permissionscheme
		/// </summary>
		/// <param name="expand">Use expand to include additional information in the response. This parameter accepts multiple values separated by a comma. Note that permissions are included when you specify any value:</param>
		/// <param name="projectKeyOrId">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectPermissionschemePutByExpandAndProjectKeyOrIdAsync(string expand, string projectKeyOrId, ProjectPermissionschemePutByExpandAndProjectKeyOrIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectKeyOrId==null? "" : Uri.EscapeDataString(projectKeyOrId))+"/permissionscheme?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all issue security levels for the project that the currently authenticated user has access to. If the user does not have permission to see an issue security level, then that level is not returned. If the user lacks the Set Issue Security permission, then an empty list is returned.
		/// ProjectSecuritylevelGetByProjectKeyOrId project/{projectKeyOrId}/securitylevel
		/// </summary>
		/// <param name="projectKeyOrId">The project ID or project key (case sensitive).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectSecuritylevelGetByProjectKeyOrIdAsync(string projectKeyOrId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project/"+ (projectKeyOrId==null? "" : Uri.EscapeDataString(projectKeyOrId))+"/securitylevel";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all project categories.
		/// ProjectCategoryGet projectCategory
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectCategoryGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectCategory";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a project category.
		/// ProjectCategoryPost projectCategory
		/// </summary>
		public async Task ProjectCategoryPostAsync(ProjectCategoryPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectCategory";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a project category.
		/// ProjectCategoryDeleteById projectCategory/{id}
		/// </summary>
		/// <param name="id">ID of the project category to delete.</param>
		public async Task ProjectCategoryDeleteByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectCategory/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a project category.
		/// ProjectCategoryGetById projectCategory/{id}
		/// </summary>
		/// <param name="id">The ID of the project category.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectCategoryGetByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectCategory/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a project category.
		/// ProjectCategoryPutById projectCategory/{id}
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectCategoryPutByIdAsync(int id, ProjectCategoryPutByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectCategory/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Validates a project key by confirming the key is a valid string and not in use.
		/// ProjectvalidateKeyGetByKey projectvalidate/key
		/// </summary>
		/// <param name="key">The project key.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectvalidateKeyGetByKeyAsync(string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectvalidate/key?key=" + (key==null? "" : Uri.EscapeDataString(key));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Validates a project key and, if the key is invalid or in use, generates a valid random string for the project key.
		/// ProjectvalidateValidProjectKeyGetByKey projectvalidate/validProjectKey
		/// </summary>
		/// <param name="key">The project key.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectvalidateValidProjectKeyGetByKeyAsync(string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectvalidate/validProjectKey?key=" + (key==null? "" : Uri.EscapeDataString(key));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Checks that a project name isn't in use. If the name isn't in use, the passed string is returned. If the name is in use, this operation attempts to generate a valid project name based on the one supplied, usually by adding a sequence number. If a valid project name cannot be generated, a 404 response is returned.
		/// ProjectvalidateValidProjectNameGetByName projectvalidate/validProjectName
		/// </summary>
		/// <param name="name">The project name.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ProjectvalidateValidProjectNameGetByNameAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectvalidate/validProjectName?name=" + (name==null? "" : Uri.EscapeDataString(name));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of all issue resolution values.
		/// ResolutionGet resolution
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ResolutionGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "resolution";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an issue resolution value.
		/// ResolutionGetById resolution/{id}
		/// </summary>
		/// <param name="id">The ID of the issue resolution value.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ResolutionGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "resolution/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of all project roles, complete with project role details and default actors.
		/// RoleGet role
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task RoleGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new project role with no default actors. You can use the Add default actors to project role the project method to add default actors to the project role after creating it.
		/// RolePost role
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task RolePostAsync(RolePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a project role. You must specify a replacement project role if you wish to delete a project role that is in use.
		/// RoleDeleteByIdAndSwap role/{id}
		/// </summary>
		/// <param name="id">The ID of the project role to delete. Use Get all project roles to get a list of project role IDs.</param>
		/// <param name="swap">The ID of the project role that will replace the one being deleted.</param>
		public async Task RoleDeleteByIdAndSwapAsync(int id, int swap, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role/"+id+"?swap="+swap;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the project role details and the default actors associated with the role. The list of default actors is sorted by display name.
		/// RoleGetById role/{id}
		/// </summary>
		/// <param name="id">The ID of the project role. Use Get all project roles to get a list of project role IDs.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task RoleGetByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update either the project role's name or its description.
		/// RolePostById role/{id}
		/// </summary>
		/// <param name="id">The ID of the project role. Use Get all project roles to get a list of project role IDs.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task RolePostByIdAsync(int id, RolePostByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update the project role's name and description. You must include both a name and a description in the request.
		/// RolePutById role/{id}
		/// </summary>
		/// <param name="id">The ID of the project role. Use Get all project roles to get a list of project role IDs.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task RolePutByIdAsync(int id, RolePutByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes default actors from the project role. You may remove either a group or user, but you cannot remove a group and a user in the same request.
		/// RoleActorsDeleteByGroupAndIdAndUser role/{id}/actors
		/// </summary>
		/// <param name="group">The group name of the group to be removed as a default actor.</param>
		/// <param name="id">The ID of the project role. Use Get all project roles to get a list of project role IDs.</param>
		/// <param name="user">The user account ID of the user to remove as a default actor.</param>
		/// <returns>Returned if the request was successful.</returns>
		public async Task RoleActorsDeleteByGroupAndIdAndUserAsync(string group, int id, string user, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role/"+id+"/actors?group=" + (group==null? "" : Uri.EscapeDataString(group))+"&user=" + (user==null? "" : Uri.EscapeDataString(user));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the default actors for the project role.
		/// RoleActorsGetById role/{id}/actors
		/// </summary>
		/// <param name="id">The ID of the project role. Use Get all project roles to get a list of project role IDs.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task RoleActorsGetByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role/"+id+"/actors";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds default actors to the given role. You may add either groups or users, but you cannot add groups and users in the same request.
		/// RoleActorsPostById role/{id}/actors
		/// </summary>
		/// <param name="id">The ID of the project role. Use Get all project roles to get a list of project role IDs.</param>
		/// <returns>Returned if the request was successful.</returns>
		public async Task RoleActorsPostByIdAsync(int id, RoleActorsPostByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role/"+id+"/actors";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all screens.
		/// ScreensGetByMaxResultsAndStartAt screens
		/// </summary>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 100.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ScreensGetByMaxResultsAndStartAtAsync(int maxResults, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens?maxResults="+maxResults+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a field to the default tab of the default screen.
		/// ScreensAddToDefaultPostByFieldId screens/addToDefault/{fieldId}
		/// </summary>
		/// <param name="fieldId">The ID of the field.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ScreensAddToDefaultPostByFieldIdAsync(string fieldId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/addToDefault/"+ (fieldId==null? "" : Uri.EscapeDataString(fieldId));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the fields that can be added to a tab on a screen.
		/// ScreensAvailableFieldsGetByScreenId screens/{screenId}/availableFields
		/// </summary>
		/// <param name="screenId">The ID of the screen.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ScreensAvailableFieldsGetByScreenIdAsync(int screenId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/"+screenId+"/availableFields";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the list of tabs for a screen.
		/// ScreensTabsGetByProjectKeyAndScreenId screens/{screenId}/tabs
		/// </summary>
		/// <param name="projectKey">The key of the project.</param>
		/// <param name="screenId">The ID of the screen.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ScreensTabsGetByProjectKeyAndScreenIdAsync(string projectKey, int screenId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/"+screenId+"/tabs?projectKey=" + (projectKey==null? "" : Uri.EscapeDataString(projectKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a tab for a screen.
		/// ScreensTabsPostByScreenId screens/{screenId}/tabs
		/// </summary>
		/// <param name="screenId">The ID of the screen.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ScreensTabsPostByScreenIdAsync(int screenId, ScreensTabsPostByScreenIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/"+screenId+"/tabs";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a screen tab.
		/// ScreensTabsDeleteByScreenIdAndTabId screens/{screenId}/tabs/{tabId}
		/// </summary>
		/// <param name="screenId">The ID of the screen.</param>
		/// <param name="tabId">The ID of the screen tab.</param>
		public async Task ScreensTabsDeleteByScreenIdAndTabIdAsync(int screenId, int tabId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/"+screenId+"/tabs/"+tabId;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the name of a screen tab.
		/// ScreensTabsPutByScreenIdAndTabId screens/{screenId}/tabs/{tabId}
		/// </summary>
		/// <param name="screenId">The ID of the screen.</param>
		/// <param name="tabId">The ID of the screen tab.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ScreensTabsPutByScreenIdAndTabIdAsync(int screenId, int tabId, ScreensTabsPutByScreenIdAndTabIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/"+screenId+"/tabs/"+tabId;
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all fields for a screen tab.
		/// ScreensTabsFieldsGetByProjectKeyAndScreenIdAndTabId screens/{screenId}/tabs/{tabId}/fields
		/// </summary>
		/// <param name="projectKey">The key of the project.</param>
		/// <param name="screenId">The ID of the screen.</param>
		/// <param name="tabId">The ID of the screen tab.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ScreensTabsFieldsGetByProjectKeyAndScreenIdAndTabIdAsync(string projectKey, int screenId, int tabId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/"+screenId+"/tabs/"+tabId+"/fields?projectKey=" + (projectKey==null? "" : Uri.EscapeDataString(projectKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a field to a screen tab.
		/// ScreensTabsFieldsPostByScreenIdAndTabId screens/{screenId}/tabs/{tabId}/fields
		/// </summary>
		/// <param name="screenId">The ID of the screen.</param>
		/// <param name="tabId">The ID of the screen tab.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task ScreensTabsFieldsPostByScreenIdAndTabIdAsync(int screenId, int tabId, ScreensTabsFieldsPostByScreenIdAndTabIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/"+screenId+"/tabs/"+tabId+"/fields";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes a field from a screen tab.
		/// ScreensTabsFieldsDeleteByIdAndScreenIdAndTabId screens/{screenId}/tabs/{tabId}/fields/{id}
		/// </summary>
		/// <param name="id">The ID of the field.</param>
		/// <param name="screenId">The ID of the screen.</param>
		/// <param name="tabId">The ID of the screen tab.</param>
		public async Task ScreensTabsFieldsDeleteByIdAndScreenIdAndTabIdAsync(string id, int screenId, int tabId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/"+screenId+"/tabs/"+tabId+"/fields/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Moves a screen tab field.
		/// ScreensTabsFieldsMovePostByIdAndScreenIdAndTabId screens/{screenId}/tabs/{tabId}/fields/{id}/move
		/// </summary>
		/// <param name="id">The ID of the field.</param>
		/// <param name="screenId">The ID of the screen.</param>
		/// <param name="tabId">The ID of the screen tab.</param>
		public async Task ScreensTabsFieldsMovePostByIdAndScreenIdAndTabIdAsync(string id, int screenId, int tabId, ScreensTabsFieldsMovePostByIdAndScreenIdAndTabIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/"+screenId+"/tabs/"+tabId+"/fields/"+ (id==null? "" : Uri.EscapeDataString(id))+"/move";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Moves a screen tab.
		/// ScreensTabsMovePostByPosAndScreenIdAndTabId screens/{screenId}/tabs/{tabId}/move/{pos}
		/// </summary>
		/// <param name="pos">The position of tab. The base index is 0.</param>
		/// <param name="screenId">The ID of the screen.</param>
		/// <param name="tabId">The ID of the screen tab.</param>
		public async Task ScreensTabsMovePostByPosAndScreenIdAndTabIdAsync(int pos, int screenId, int tabId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "screens/"+screenId+"/tabs/"+tabId+"/move/"+pos;
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Searches for issues using JQL. Permissions required: Permission to access Jira.
		/// SearchGetByExpandAndFieldsAndFieldsByKeysAndJqlAndMaxResultsAndPropertiesAndStartAtAndValidateQuery search
		/// </summary>
		/// <param name="expand">Use expand to include additional information about issues in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="fields">A comma-separated list of fields to return for each issue, use it to retrieve a subset of fields. Allowed values:</param>
		/// <param name="fieldsByKeys">Reference fields by their key (rather than ID).</param>
		/// <param name="jql">The JQL that defines the search. If no JQL expression is provided, all issues are returned. Note that username and userkey have been deprecated as search terms for this parameter. See the migration guide for details. Use accountId instead.</param>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 100.</param>
		/// <param name="properties">A comma-separated list of up to 5 issue properties to include in the results.</param>
		/// <param name="startAt">The index of the first item to return in the page of results (page offset).</param>
		/// <param name="validateQuery">Determines how to validate the JQL query and treat the validation results. Supported values are:</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task SearchGetByExpandAndFieldsAndFieldsByKeysAndJqlAndMaxResultsAndPropertiesAndStartAtAndValidateQueryAsync(string expand, string[] fields, bool fieldsByKeys, string jql, int maxResults, string[] properties, int startAt, string validateQuery, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&"+String.Join("&", fields.Select(z => $"fields={Uri.EscapeDataString(z.ToString())}"))+"&fieldsByKeys="+fieldsByKeys+"&jql=" + (jql==null? "" : Uri.EscapeDataString(jql))+"&maxResults="+maxResults+"&"+String.Join("&", properties.Select(z => $"properties={Uri.EscapeDataString(z.ToString())}"))+"&startAt="+startAt+"&validateQuery=" + (validateQuery==null? "" : Uri.EscapeDataString(validateQuery));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Searches for issues using JQL. Permissions required: Permission to access Jira.
		/// SearchPost search
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task SearchPostAsync(SearchPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns details of an issue security level.
		/// SecuritylevelGetById securitylevel/{id}
		/// </summary>
		/// <param name="id">The ID of the issue security level.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task SecuritylevelGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "securitylevel/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns information about the Jira instance.
		/// ServerInfoGet serverInfo
		/// </summary>
		/// <returns>Returns if the request is successful.</returns>
		public async Task ServerInfoGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "serverInfo";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the default issue navigator columns.
		/// SettingsColumnsGet settings/columns
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task SettingsColumnsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "settings/columns";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the default issue navigator columns.
		/// SettingsColumnsPut settings/columns
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task SettingsColumnsPutAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "settings/columns";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of all statuses associated with workflows.
		/// StatusGet status
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task StatusGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "status";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a status. The status must be associated with a workflow to be returned.
		/// StatusGetByIdOrName status/{idOrName}
		/// </summary>
		/// <param name="idOrName">The ID or name of the status.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task StatusGetByIdOrNameAsync(string idOrName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "status/"+ (idOrName==null? "" : Uri.EscapeDataString(idOrName));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of all status categories.
		/// StatuscategoryGet statuscategory
		/// </summary>
		/// <returns>Returned if the request is successful.</returns>
		public async Task StatuscategoryGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "statuscategory";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a status category. Status categories provided a mechanism for categorizing statuses.
		/// StatuscategoryGetByIdOrKey statuscategory/{idOrKey}
		/// </summary>
		/// <param name="idOrKey">The ID or key of the status category.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task StatuscategoryGetByIdOrKeyAsync(string idOrKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "statuscategory/"+ (idOrKey==null? "" : Uri.EscapeDataString(idOrKey));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the status of a long-running asynchronous task.
		/// TaskGetByTaskId task/{taskId}
		/// </summary>
		/// <param name="taskId">The ID of the task.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task TaskGetByTaskIdAsync(string taskId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "task/"+ (taskId==null? "" : Uri.EscapeDataString(taskId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Cancels a task.
		/// TaskCancelPostByTaskId task/{taskId}/cancel
		/// </summary>
		/// <param name="taskId">The ID of the task.</param>
		public async Task TaskCancelPostByTaskIdAsync(string taskId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "task/"+ (taskId==null? "" : Uri.EscapeDataString(taskId))+"/cancel";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the system and custom avatars for a project or issue type.
		/// Universal_avatarTypeOwnerGetByEntityIdAndType universal_avatar/type/{type}/owner/{entityId}
		/// </summary>
		/// <param name="entityId">The ID of the entity item.</param>
		/// <param name="type">The type of the entity. Valid values are project and issuetype.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task Universal_avatarTypeOwnerGetByEntityIdAndTypeAsync(string entityId, string type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "universal_avatar/type/"+ (type==null? "" : Uri.EscapeDataString(type))+"/owner/"+ (entityId==null? "" : Uri.EscapeDataString(entityId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Loads a custom avatar for a project or issue type.
		/// Universal_avatarTypeOwnerPostByEntityIdAndSizeAndTypeAndXAndY universal_avatar/type/{type}/owner/{entityId}
		/// </summary>
		/// <param name="entityId">The ID of the entity item.</param>
		/// <param name="size">The length of each side of the crop region.</param>
		/// <param name="type">The type of the entity. Valid values are project and issuetype.</param>
		/// <param name="x">The X coordinate of the top-left corner of the crop region.</param>
		/// <param name="y">The Y coordinate of the top-left corner of the crop region.</param>
		public async Task Universal_avatarTypeOwnerPostByEntityIdAndSizeAndTypeAndXAndYAsync(string entityId, int size, string type, int x, int y, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "universal_avatar/type/"+ (type==null? "" : Uri.EscapeDataString(type))+"/owner/"+ (entityId==null? "" : Uri.EscapeDataString(entityId))+"&size="+size+"&x="+x+"&y="+y;
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an avatar from a project or issue type.
		/// Universal_avatarTypeOwnerAvatarDeleteByIdAndOwningObjectIdAndType universal_avatar/type/{type}/owner/{owningObjectId}/avatar/{id}
		/// </summary>
		/// <param name="id">The ID of the avatar.</param>
		/// <param name="owningObjectId">The ID of the entity item.</param>
		/// <param name="type">The type of the entity. Valid values are project and issuetype.</param>
		public async Task Universal_avatarTypeOwnerAvatarDeleteByIdAndOwningObjectIdAndTypeAsync(int id, string owningObjectId, string type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "universal_avatar/type/"+ (type==null? "" : Uri.EscapeDataString(type))+"/owner/"+ (owningObjectId==null? "" : Uri.EscapeDataString(owningObjectId))+"/avatar/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a user. Permissions required: Site administration (i.e., member of the site-admin group).
		/// UserDeleteByAccountIdAndKeyAndUsername user
		/// </summary>
		/// <param name="accountId">The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192. Required, unless username or key is specified.</param>
		/// <param name="key">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The key of the user. For example, admin. Required, unless accountId or username is specified.</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The username of the user. For example, admin. Required, unless accountId or key is specified.</param>
		public async Task UserDeleteByAccountIdAndKeyAndUsernameAsync(string accountId, string key, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&key=" + (key==null? "" : Uri.EscapeDataString(key))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a user. Permissions required: None.
		/// UserGetByAccountIdAndExpandAndKeyAndUsername user
		/// </summary>
		/// <param name="accountId">The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192. Required, unless username or key is specified.</param>
		/// <param name="expand">Use expand to include additional information about users in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="key">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The key of the user. For example, admin. Required, unless accountId or username is specified.</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The username of the user. For example, admin. Required, unless accountId or key is specified.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserGetByAccountIdAndExpandAndKeyAndUsernameAsync(string accountId, string expand, string key, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&key=" + (key==null? "" : Uri.EscapeDataString(key))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a user. This resource is retained for legacy compatibility. As soon as a more suitable alternative is available this resource will be deprecated. The option is provided to set or generate a password for the user. When using the option to generate a password, by omitting password from the request, include "notification": "true" to ensure the user is sent an email advising them that their account has been created. This email includes a link for the user to set their password. If the notification isn't sent for a generated password, the user will need to be sent a reset password request from Jira. Permissions required: Administer Jira global permission
		/// UserPost user
		/// </summary>
		public async Task UserPostAsync(UserPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of users who fulfill both of these criteria:
		/// UserAssignableMultiProjectSearchGetByMaxResultsAndProjectKeysAndQueryAndStartAtAndUsername user/assignable/multiProjectSearch
		/// </summary>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 1000.</param>
		/// <param name="projectKeys">A comma-separated list of project keys (case sensitive).</param>
		/// <param name="query">A query string that is matched against user attributes, such as key, name, displayName, and emailAddress, to find relevant users. The string can match any part of the attribute's value. For example, query=john matches a user with a displayName of John Smith and a user with an emailAddress of jane.johnson@example.com.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use query instead. See the migration guide for details. A query string used to search username, display name, and email address. The string is matched to the starting letters of any word in the searched fields. For example, ar matches to the username archie but not mark.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserAssignableMultiProjectSearchGetByMaxResultsAndProjectKeysAndQueryAndStartAtAndUsernameAsync(int maxResults, string projectKeys, string query, int startAt, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/assignable/multiProjectSearch?maxResults="+maxResults+"&projectKeys=" + (projectKeys==null? "" : Uri.EscapeDataString(projectKeys))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&startAt="+startAt+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of users that can be assigned to an issue. Use this method to find the list of users who can be assigned to:
		/// UserAssignableSearchGetByActionDescriptorIdAndIssueKeyAndMaxResultsAndProjectAndQueryAndStartAtAndUsername user/assignable/search
		/// </summary>
		/// <param name="actionDescriptorId">The ID of the transition.</param>
		/// <param name="issueKey">The key of the issue. Required, unless project is specified.</param>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 1000.</param>
		/// <param name="project">The project ID or project key (case sensitive). Required, unless issueKey is specified.</param>
		/// <param name="query">A query string that is matched against user attributes, such as key, name, displayName, and emailAddress, to find relevant users. The string can match any part of the attribute's value. For example, query=john matches a user with a displayName of John Smith and a user with an emailAddress of jane.johnson@example.com. Required, unless username is specified.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use query instead. See the migration guide for details. A query string used to search username, display name, and email address. The string is matched to the starting letters of any word in the searched fields. For example, ar matches to the username archie but not mark. Required, unless accountId is specified.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserAssignableSearchGetByActionDescriptorIdAndIssueKeyAndMaxResultsAndProjectAndQueryAndStartAtAndUsernameAsync(int actionDescriptorId, string issueKey, int maxResults, string project, string query, int startAt, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/assignable/search?actionDescriptorId="+actionDescriptorId+"&issueKey=" + (issueKey==null? "" : Uri.EscapeDataString(issueKey))+"&maxResults="+maxResults+"&project=" + (project==null? "" : Uri.EscapeDataString(project))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&startAt="+startAt+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns details of users specified in a list of usernames or keys. Permissions required: Administer Jira global permission. Users with permission to access Jira can call this method, but empty search results are returned.
		/// UserBulkGetByKeyAndMaxResultsAndStartAtAndUsername user/bulk
		/// </summary>
		/// <param name="key">Comma-separated list of user keys. Required if username isn't provided.</param>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 200.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <param name="username">Comma-separated list of usernames. Required if key isn't provided.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserBulkGetByKeyAndMaxResultsAndStartAtAndUsernameAsync(string[] key, int maxResults, int startAt, string[] username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/bulk?"+String.Join("&", key.Select(z => $"key={Uri.EscapeDataString(z.ToString())}"))+"&maxResults="+maxResults+"&startAt="+startAt+"&"+String.Join("&", username.Select(z => $"username={Uri.EscapeDataString(z.ToString())}"));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resets the default issue table columns for the user to the system default. If a username is not passed, the calling user's default columns are reset. Permissions required:
		/// UserColumnsDeleteByAccountIdAndUsername user/columns
		/// </summary>
		/// <param name="accountId">The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192. Required, unless username is specified.</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The username of the user. For example, admin. Required, unless accountId is specified.</param>
		public async Task UserColumnsDeleteByAccountIdAndUsernameAsync(string accountId, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/columns?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the default issue table columns for the user. If a username is not passed in the request, the calling user's details are returned. Permissions required:
		/// UserColumnsGetByAccountIdAndUsername user/columns
		/// </summary>
		/// <param name="accountId">The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192. Required, unless username is specified.</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The username of the user. For example, admin. Required, unless accountId is specified.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserColumnsGetByAccountIdAndUsernameAsync(string accountId, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/columns?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the default issue table columns for the user. If a username is not passed, the calling user's default columns are set. If no column details are sent, then all default columns are removed. The parameters for this resource are expressed as HTML form data. For example, in curl: curl -X PUT -d username=<username> -d columns=summary -d columns=description <url> Permissions required:
		/// UserColumnsPutByAccountId user/columns
		/// </summary>
		/// <param name="accountId">The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192. Required, unless username is specified.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserColumnsPutByAccountIdAsync(string accountId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/columns?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the groups to which a user belongs. Permissions required: Browse users and groups global permission.
		/// UserGroupsGetByAccountIdAndKeyAndUsername user/groups
		/// </summary>
		/// <param name="accountId">The account ID of the user.</param>
		/// <param name="key">The key of the user.</param>
		/// <param name="username">The username of the user. Deprecated in favour of accountId.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserGroupsGetByAccountIdAndKeyAndUsernameAsync(string accountId, string key, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/groups?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&key=" + (key==null? "" : Uri.EscapeDataString(key))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of users who fulfill both of these criteria:
		/// UserPermissionSearchGetByIssueKeyAndMaxResultsAndPermissionsAndProjectKeyAndQueryAndStartAtAndUsername user/permission/search
		/// </summary>
		/// <param name="issueKey">The issue key for the issue.</param>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 1000.</param>
		/// <param name="permissions">A comma-separated list of permissions. The valid permissions are:</param>
		/// <param name="projectKey">The project key for the project (case sensitive).</param>
		/// <param name="query">A query string that is matched against user attributes, such as key, name, displayName, and emailAddress, to find relevant users. The string can match any part of the attribute's value. For example, query=john matches a user with a displayName of John Smith and a user with an emailAddress of jane.johnson@example.com.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use query instead. See the migration guide for details. A query string used to search username, display name, and email address. The string is matched to the starting letters of any word in the searched fields. For example, ar matches to the username archie but not mark.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserPermissionSearchGetByIssueKeyAndMaxResultsAndPermissionsAndProjectKeyAndQueryAndStartAtAndUsernameAsync(string issueKey, int maxResults, string permissions, string projectKey, string query, int startAt, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/permission/search?issueKey=" + (issueKey==null? "" : Uri.EscapeDataString(issueKey))+"&maxResults="+maxResults+"&permissions=" + (permissions==null? "" : Uri.EscapeDataString(permissions))+"&projectKey=" + (projectKey==null? "" : Uri.EscapeDataString(projectKey))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&startAt="+startAt+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of users whose attributes match the query term. The returned object includes the html field where the matched query term is highlighted with the HTML strong tag. A list of account IDs can be provided to exclude users from the results. Permissions required: Browse users and groups global permission. Users with permission to access Jira can call this method, but will only get search results for an exact name match.
		/// UserPickerGetByExcludeAndExcludeAccountIdsAndMaxResultsAndQueryAndShowAvatar user/picker
		/// </summary>
		/// <param name="exclude">This parameter has been deprecated due to privacy changes. Use excludeAccountIds instead. See the migration guide for details. A comma-separated list of usernames to exclude from the search results.</param>
		/// <param name="excludeAccountIds">A comma-separated list of account IDs to exclude from the search results.</param>
		/// <param name="maxResults">The maximum number of items to return. Maximum is 1000. The total number of matched users is returned in total.</param>
		/// <param name="query">A search input that is matched against appropriate user attributes to find relevant users.</param>
		/// <param name="showAvatar">Include the URI to the user's avatar.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserPickerGetByExcludeAndExcludeAccountIdsAndMaxResultsAndQueryAndShowAvatarAsync(string[] exclude, string[] excludeAccountIds, int maxResults, string query, bool showAvatar, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/picker?"+String.Join("&", exclude.Select(z => $"exclude={Uri.EscapeDataString(z.ToString())}"))+"&"+String.Join("&", excludeAccountIds.Select(z => $"excludeAccountIds={Uri.EscapeDataString(z.ToString())}"))+"&maxResults="+maxResults+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&showAvatar="+showAvatar;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the keys of all properties for a user. Permissions required:
		/// UserPropertiesGetByAccountIdAndUserKeyAndUsername user/properties
		/// </summary>
		/// <param name="accountId">The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192. Required, unless username or key is specified.</param>
		/// <param name="userKey">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The key of the user. For example, admin. Required, unless accountId or username is specified.</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The username of the user. For example, admin. Required, unless accountId or key is specified.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserPropertiesGetByAccountIdAndUserKeyAndUsernameAsync(string accountId, string userKey, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/properties?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&userKey=" + (userKey==null? "" : Uri.EscapeDataString(userKey))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a property from a user. Permissions required:
		/// UserPropertiesDeleteByAccountIdAndPropertyKeyAndUserKeyAndUsername user/properties/{propertyKey}
		/// </summary>
		/// <param name="accountId">The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192. Required, unless username or key is specified.</param>
		/// <param name="propertyKey">The key of the user's property.</param>
		/// <param name="userKey">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The key of the user. For example, admin.</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The username of the user. For example, admin. Required, unless accountId or key is specified.</param>
		public async Task UserPropertiesDeleteByAccountIdAndPropertyKeyAndUserKeyAndUsernameAsync(string accountId, string propertyKey, string userKey, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey))+"?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&userKey=" + (userKey==null? "" : Uri.EscapeDataString(userKey))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the value of a user's property. If no property key is provided Get user property keys is called. Permissions required:
		/// UserPropertiesGetByAccountIdAndPropertyKeyAndUserKeyAndUsername user/properties/{propertyKey}
		/// </summary>
		/// <param name="accountId">The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192. Required, unless username or key is specified.</param>
		/// <param name="propertyKey">The key of the user's property.</param>
		/// <param name="userKey">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The key of the user. For example, admin.</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The username of the user. For example, admin. Required, unless accountId or key is specified.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserPropertiesGetByAccountIdAndPropertyKeyAndUserKeyAndUsernameAsync(string accountId, string propertyKey, string userKey, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey))+"?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&userKey=" + (userKey==null? "" : Uri.EscapeDataString(userKey))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the value of a user's property. Use this resource to store custom data against a user. Permissions required:
		/// UserPropertiesPutByAccountIdAndPropertyKeyAndUserKeyAndUsername user/properties/{propertyKey}
		/// </summary>
		/// <param name="accountId">The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192. Required, unless username or key is specified.</param>
		/// <param name="propertyKey">The key of the user's property. The maximum length of the key is 255 bytes.</param>
		/// <param name="userKey">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The key of the user. For example, admin. Required, unless accountId or username is specified.</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use accountId instead. See the migration guide for details.The username of the user. For example, admin. Required, unless accountId or key is specified.</param>
		/// <returns>Returned if the user property is updated.</returns>
		public async Task UserPropertiesPutByAccountIdAndPropertyKeyAndUserKeyAndUsernameAsync(string accountId, string propertyKey, string userKey, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/properties/"+ (propertyKey==null? "" : Uri.EscapeDataString(propertyKey))+"?accountId=" + (accountId==null? "" : Uri.EscapeDataString(accountId))+"&userKey=" + (userKey==null? "" : Uri.EscapeDataString(userKey))+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of users that match the search string and property. Permissions required: Browse users and groups global permission. Users with permission to access Jira can call this method, but empty search results are returned.
		/// UserSearchGetByIncludeActiveAndIncludeInactiveAndMaxResultsAndPropertyAndQueryAndStartAtAndUsername user/search
		/// </summary>
		/// <param name="includeActive">Include active users.</param>
		/// <param name="includeInactive">Include inactive users.</param>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 1000.</param>
		/// <param name="property">A query string used to search properties. Property keys are specified by path, so property keys containing dot (.) or equals (=) characters cannot be used. The query string cannot be specified using a JSON object. Example: To search for the value of nested from {"something":{"nested":1,"other":2}} use thepropertykey.something.nested=1.</param>
		/// <param name="query">A query string that is matched against user attributes (key, name, displayName, and emailAddress) to find relevant users. The string can match any part of the attribute's value. For example, query=john matches a user with a displayName of John Smith and a user with an emailAddress of jane.johnson@example.com. Required, unless username is specified.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use query instead. See the migration guide for details. A query string used to search username, display name, and email address. The string is matched to the starting letters of any word in the searched fields. For example, ar matches to the username archie but not mark. Required, unless accountId is specified.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserSearchGetByIncludeActiveAndIncludeInactiveAndMaxResultsAndPropertyAndQueryAndStartAtAndUsernameAsync(bool includeActive, bool includeInactive, int maxResults, string property, string query, int startAt, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/search?includeActive="+includeActive+"&includeInactive="+includeInactive+"&maxResults="+maxResults+"&property=" + (property==null? "" : Uri.EscapeDataString(property))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&startAt="+startAt+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Finds users using a structured query and returns user details. Permissions required: Browse users and groups global permission. The available queries statements are:
		/// UserSearchQueryGetByIncludeInactiveAndMaxResultsAndQueryAndStartAt user/search/query
		/// </summary>
		/// <param name="includeInactive">Include inactive users in the results.</param>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 1000.</param>
		/// <param name="query">The search query.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserSearchQueryGetByIncludeInactiveAndMaxResultsAndQueryAndStartAtAsync(bool includeInactive, int maxResults, string query, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/search/query?includeInactive="+includeInactive+"&maxResults="+maxResults+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Finds users using a structured query and returns a list of user keys. Permissions required: Browse users and groups global permission. The available query statements are:
		/// UserSearchQueryKeyGetByIncludeInactiveAndMaxResultsAndQueryAndStartAt user/search/query/key
		/// </summary>
		/// <param name="includeInactive">Include inactive users in the results.</param>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 1000.</param>
		/// <param name="query">The search query.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserSearchQueryKeyGetByIncludeInactiveAndMaxResultsAndQueryAndStartAtAsync(bool includeInactive, int maxResults, string query, int startAt, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/search/query/key?includeInactive="+includeInactive+"&maxResults="+maxResults+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&startAt="+startAt;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of users who fulfill both of these criteria:
		/// UserViewissueSearchGetByIssueKeyAndMaxResultsAndProjectKeyAndQueryAndStartAtAndUsername user/viewissue/search
		/// </summary>
		/// <param name="issueKey">The issue key for the issue. Required, unless projectKey is specified.</param>
		/// <param name="maxResults">The maximum number of items to return per page. Maximum is 1000.</param>
		/// <param name="projectKey">The project key for the project (case sensitive). Required, unless issueKey is specified.</param>
		/// <param name="query">A query string that is matched against user attributes, such as key, name, displayName, and emailAddress, to find relevant users. The string can match any part of the attribute's value. For example, query=john matches a user with a displayName of John Smith and a user with an emailAddress of jane.johnson@example.com. Required, unless username is specified.</param>
		/// <param name="startAt">The index of the first item to return in a page of results (page offset).</param>
		/// <param name="username">This parameter has been deprecated due to privacy changes. Use query instead. See the migration guide for details. A query string used to search username, display name, and email address. The string is matched to the starting letters of any word in the searched fields. For example, ar matches to the username archie but not mark. Required, unless accountId is specified.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task UserViewissueSearchGetByIssueKeyAndMaxResultsAndProjectKeyAndQueryAndStartAtAndUsernameAsync(string issueKey, int maxResults, string projectKey, string query, int startAt, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/viewissue/search?issueKey=" + (issueKey==null? "" : Uri.EscapeDataString(issueKey))+"&maxResults="+maxResults+"&projectKey=" + (projectKey==null? "" : Uri.EscapeDataString(projectKey))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&startAt="+startAt+"&username=" + (username==null? "" : Uri.EscapeDataString(username));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a project version. Permissions required: Administer Jira global permission or Administer Projects project permission.
		/// VersionPost version
		/// </summary>
		public async Task VersionPostAsync(VersionPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// the global ID of the remote resource that is linked to the versions
		/// VersionRemotelinkGetByGlobalId version/remotelink
		/// </summary>
		/// <param name="globalId">the global ID of the remote resource that is linked to the versions</param>
		/// <returns>Contains a list of remote version links. Any existing links that the user does not have permission to see will be filtered out. The user must have BROWSE permission for the project to see links to its versions.</returns>
		public async Task VersionRemotelinkGetByGlobalIdAsync(string globalId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/remotelink?globalId=" + (globalId==null? "" : Uri.EscapeDataString(globalId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a project version. Deprecated, use Delete and replace version that supports swapping version values in custom fields, in addition to the swapping for fixVersion and affectedVersion provided in this resource. Alternative versions can be provided to update issues that use the deleted version in fixVersion or affectedVersion. If alternatives are not provided, occurrences of fixVersion and affectedVersion that contain the deleted version are cleared. Permissions required: Administer Jira global permission or Administer Projects project permission.
		/// VersionDeleteByIdAndMoveAffectedIssuesToAndMoveFixIssuesTo version/{id}
		/// </summary>
		/// <param name="id">The ID of the version.</param>
		/// <param name="moveAffectedIssuesTo">The ID of the version to update affectedVersion to when the field contains the deleted version. The replacement version must be in the same project as the version being deleted and cannot be the version being deleted.</param>
		/// <param name="moveFixIssuesTo">The ID of the version to update fixVersion to when the field contains the deleted version. The replacement version must be in the same project as the version being deleted and cannot be the version being deleted.</param>
		public async Task VersionDeleteByIdAndMoveAffectedIssuesToAndMoveFixIssuesToAsync(string id, string moveAffectedIssuesTo, string moveFixIssuesTo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (id==null? "" : Uri.EscapeDataString(id))+"&moveAffectedIssuesTo=" + (moveAffectedIssuesTo==null? "" : Uri.EscapeDataString(moveAffectedIssuesTo))+"&moveFixIssuesTo=" + (moveFixIssuesTo==null? "" : Uri.EscapeDataString(moveFixIssuesTo));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a project version. Permissions required: Browse projects project permission
		/// VersionGetByExpandAndId version/{id}
		/// </summary>
		/// <param name="expand">Use expand to include additional information about version in the response. This parameter accepts multiple values separated by a comma:</param>
		/// <param name="id">The ID of the version.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task VersionGetByExpandAndIdAsync(string expand, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (id==null? "" : Uri.EscapeDataString(id))+"?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modifies a project version. Permissions required: Administer Jira global permission or Administer Projects project permission.
		/// VersionPutById version/{id}
		/// </summary>
		/// <param name="id">The ID of the version.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task VersionPutByIdAsync(string id, VersionPutByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Merges two project versions. The merge is completed by deleting the version specified in id and replacing any occurrences of its ID in fixVersion with the version ID specified in moveIssuesTo. Consider using Delete and replace version instead. This resource supports swapping version values in fixVersion, affectedVersion, and custom fields. Permissions required: Administer Jira global permission or Administer Projects project permission.
		/// VersionMergetoPutByIdAndMoveIssuesTo version/{id}/mergeto/{moveIssuesTo}
		/// </summary>
		/// <param name="id">The ID of the version to delete.</param>
		/// <param name="moveIssuesTo">The ID of the version to merge into.</param>
		public async Task VersionMergetoPutByIdAndMoveIssuesToAsync(string id, string moveIssuesTo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (id==null? "" : Uri.EscapeDataString(id))+"/mergeto/"+ (moveIssuesTo==null? "" : Uri.EscapeDataString(moveIssuesTo));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modifies the version's sequence within the project, which affects the display order of the versions in Jira. Permissions required: Administer Jira global permission or Administer Projects project permission.
		/// VersionMovePostById version/{id}/move
		/// </summary>
		/// <param name="id">The ID of the version to be moved.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task VersionMovePostByIdAsync(string id, VersionMovePostByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (id==null? "" : Uri.EscapeDataString(id))+"/move";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the following counts for a version:
		/// VersionRelatedIssueCountsGetById version/{id}/relatedIssueCounts
		/// </summary>
		/// <param name="id">The ID of the version.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task VersionRelatedIssueCountsGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (id==null? "" : Uri.EscapeDataString(id))+"/relatedIssueCounts";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a project version. Permissions required: Administer Jira global permission or Administer Projects project permission. Alternative versions can be provided to update issues that use the deleted version in fixVersion, affectedVersion, or any version picker custom fields. If alternatives are not provided, occurrences of fixVersion, affectedVersion, and any version picker custom field, that contain the deleted version, are cleared. Any replacement version must be in the same project as the version being deleted and cannot be the version being deleted.
		/// VersionRemoveAndSwapPostById version/{id}/removeAndSwap
		/// </summary>
		/// <param name="id">The ID of the version.</param>
		public async Task VersionRemoveAndSwapPostByIdAsync(string id, VersionRemoveAndSwapPostByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (id==null? "" : Uri.EscapeDataString(id))+"/removeAndSwap";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns counts of the issues and unresolved issues for the project version. Permissions required: Browse projects project permission
		/// VersionUnresolvedIssueCountGetById version/{id}/unresolvedIssueCount
		/// </summary>
		/// <param name="id">The ID of the version.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task VersionUnresolvedIssueCountGetByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (id==null? "" : Uri.EscapeDataString(id))+"/unresolvedIssueCount";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The version for which to delete ALL existing remote version links
		/// VersionRemotelinkDeleteByVersionId version/{versionId}/remotelink
		/// </summary>
		/// <param name="versionId">The version for which to delete ALL existing remote version links</param>
		public async Task VersionRemotelinkDeleteByVersionIdAsync(string versionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (versionId==null? "" : Uri.EscapeDataString(versionId))+"/remotelink";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// a String containing the version ID
		/// VersionRemotelinkGetByVersionId version/{versionId}/remotelink
		/// </summary>
		/// <param name="versionId">a String containing the version ID</param>
		/// <returns>Returned if the version exists and the currently authenticated user has permission to view it, which is restricted to those users with BROWSE permission for the project. Contains a full representation of the remote version links.</returns>
		public async Task VersionRemotelinkGetByVersionIdAsync(string versionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (versionId==null? "" : Uri.EscapeDataString(versionId))+"/remotelink";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a remote version link via POST. The link's global ID will be taken from the JSON payload if provided; otherwise, it will be generated.
		/// VersionRemotelinkPostByVersionId version/{versionId}/remotelink
		/// </summary>
		public async Task VersionRemotelinkPostByVersionIdAsync(string versionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (versionId==null? "" : Uri.EscapeDataString(versionId))+"/remotelink";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The version ID of the remote link
		/// VersionRemotelinkDeleteByGlobalIdAndVersionId version/{versionId}/remotelink/{globalId}
		/// </summary>
		/// <param name="globalId">The global ID of the remote link</param>
		/// <param name="versionId">The version ID of the remote link</param>
		public async Task VersionRemotelinkDeleteByGlobalIdAndVersionIdAsync(string globalId, string versionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (versionId==null? "" : Uri.EscapeDataString(versionId))+"/remotelink/"+ (globalId==null? "" : Uri.EscapeDataString(globalId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// A REST sub-resource representing a remote version link
		/// VersionRemotelinkGetByGlobalIdAndVersionId version/{versionId}/remotelink/{globalId}
		/// </summary>
		/// <param name="globalId">The id of the remote issue link to be returned. If {@code null} (not provided) all remote links for the issue are returned.</param>
		/// <param name="versionId">a String containing the version id</param>
		/// <returns>Example response (application/json)</returns>
		public async Task VersionRemotelinkGetByGlobalIdAndVersionIdAsync(string globalId, string versionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (versionId==null? "" : Uri.EscapeDataString(versionId))+"/remotelink/"+ (globalId==null? "" : Uri.EscapeDataString(globalId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// VersionRemotelinkPostByGlobalIdAndVersionId version/{versionId}/remotelink/{globalId}
		/// </summary>
		public async Task VersionRemotelinkPostByGlobalIdAndVersionIdAsync(string globalId, string versionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (versionId==null? "" : Uri.EscapeDataString(versionId))+"/remotelink/"+ (globalId==null? "" : Uri.EscapeDataString(globalId));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all workflows in Jira or a single workflow.
		/// WorkflowGetByWorkflowName workflow
		/// </summary>
		/// <param name="workflowName">The name of the workflow to be returned. Only one workflow can be specified.</param>
		/// <returns>Returned if the requested workflows are returned.</returns>
		public async Task WorkflowGetByWorkflowNameAsync(string workflowName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflow?workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a property from a workflow transition. Transition properties are used to change the behavior of a transition. For more information, see Transition properties and Workflow properties.
		/// WorkflowTransitionsPropertiesDeleteByKeyAndTransitionIdAndWorkflowModeAndWorkflowName workflow/transitions/{transitionId}/properties
		/// </summary>
		/// <param name="key">The name of the transition property to delete, also known as the name of the property.</param>
		/// <param name="transitionId">The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition.</param>
		/// <param name="workflowMode">The workflow status. Set to live for inactive workflows or draft for draft workflows. Active workflows cannot be edited.</param>
		/// <param name="workflowName">The name of the workflow that the transition belongs to.</param>
		/// <returns>200 response</returns>
		public async Task WorkflowTransitionsPropertiesDeleteByKeyAndTransitionIdAndWorkflowModeAndWorkflowNameAsync(string key, int transitionId, string workflowMode, string workflowName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflow/transitions/"+transitionId+"/properties?key=" + (key==null? "" : Uri.EscapeDataString(key))+"&workflowMode=" + (workflowMode==null? "" : Uri.EscapeDataString(workflowMode))+"&workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the properties on a workflow transition. Transition properties are used to change the behavior of a transition. For more information, see Transition properties and Workflow properties.
		/// WorkflowTransitionsPropertiesGetByIncludeReservedKeysAndKeyAndTransitionIdAndWorkflowModeAndWorkflowName workflow/transitions/{transitionId}/properties
		/// </summary>
		/// <param name="includeReservedKeys">Some properties with keys that have the jira. prefix are reserved, i.e., not editable. To include these properties in the results, set this parameter to true.</param>
		/// <param name="key">The key of the property being returned, also known as the name of the property. If this parameter is not specified, all properties on the transition are returned.</param>
		/// <param name="transitionId">The ID of the transition. To get the ID, view the workflow in text mode in the Jira administration console. The ID is shown next to the transition.</param>
		/// <param name="workflowMode">The workflow status. Set to live for active and inactive workflows, or draft for draft workflows.</param>
		/// <param name="workflowName">The name of the workflow that the transition belongs to.</param>
		/// <returns>200 response</returns>
		public async Task WorkflowTransitionsPropertiesGetByIncludeReservedKeysAndKeyAndTransitionIdAndWorkflowModeAndWorkflowNameAsync(bool includeReservedKeys, string key, int transitionId, string workflowMode, string workflowName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflow/transitions/"+transitionId+"/properties?includeReservedKeys="+includeReservedKeys+"&key=" + (key==null? "" : Uri.EscapeDataString(key))+"&workflowMode=" + (workflowMode==null? "" : Uri.EscapeDataString(workflowMode))+"&workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a property to a workflow transition. Transition properties are used to change the behavior of a transition. For more information, see Transition properties and Workflow properties.
		/// WorkflowTransitionsPropertiesPostByKeyAndTransitionIdAndWorkflowModeAndWorkflowName workflow/transitions/{transitionId}/properties
		/// </summary>
		/// <param name="key">The key of the property being added, also known as the name of the property. Set this to the same value as the key defined in the request body.</param>
		/// <param name="transitionId">The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition.</param>
		/// <param name="workflowMode">The workflow status. Set to live for inactive workflows or draft for draft workflows. Active workflows cannot be edited.</param>
		/// <param name="workflowName">The name of the workflow that the transition belongs to.</param>
		/// <returns>200 response</returns>
		public async Task WorkflowTransitionsPropertiesPostByKeyAndTransitionIdAndWorkflowModeAndWorkflowNameAsync(string key, int transitionId, string workflowMode, string workflowName, WorkflowTransitionsPropertiesPostByKeyAndTransitionIdAndWorkflowModeAndWorkflowNameBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflow/transitions/"+transitionId+"/properties?key=" + (key==null? "" : Uri.EscapeDataString(key))+"&workflowMode=" + (workflowMode==null? "" : Uri.EscapeDataString(workflowMode))+"&workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a workflow transition by changing the property value. Trying to update a property that does not exist results in a new property being added to the transition. Transition properties are used to change the behavior of a transition. For more information, see Transition properties and Workflow properties.
		/// WorkflowTransitionsPropertiesPutByKeyAndTransitionIdAndWorkflowModeAndWorkflowName workflow/transitions/{transitionId}/properties
		/// </summary>
		/// <param name="key">The key of the property being updated, also known as the name of the property. Set this to the same value as the key defined in the request body.</param>
		/// <param name="transitionId">The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition.</param>
		/// <param name="workflowMode">The workflow status. Set to live for inactive workflows or draft for draft workflows. Active workflows cannot be edited.</param>
		/// <param name="workflowName">The name of the workflow that the transition belongs to.</param>
		/// <returns>200 response</returns>
		public async Task WorkflowTransitionsPropertiesPutByKeyAndTransitionIdAndWorkflowModeAndWorkflowNameAsync(string key, int transitionId, string workflowMode, string workflowName, WorkflowTransitionsPropertiesPutByKeyAndTransitionIdAndWorkflowModeAndWorkflowNameBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflow/transitions/"+transitionId+"/properties?key=" + (key==null? "" : Uri.EscapeDataString(key))+"&workflowMode=" + (workflowMode==null? "" : Uri.EscapeDataString(workflowMode))+"&workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a workflow scheme.
		/// WorkflowschemePost workflowscheme
		/// </summary>
		public async Task WorkflowschemePostAsync(WorkflowschemePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a workflow scheme. Note that a workflow scheme cannot be deleted if it is active (that is, being used by at least one project).
		/// WorkflowschemeDeleteById workflowscheme/{id}
		/// </summary>
		/// <param name="id">The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID will be shown in the URL as schemeId (for example, schemeId=10301).</param>
		public async Task WorkflowschemeDeleteByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a workflow scheme.
		/// WorkflowschemeGetByIdAndReturnDraftIfExists workflowscheme/{id}
		/// </summary>
		/// <param name="id">The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID will be shown in the URL as schemeId (for example, schemeId=10301).</param>
		/// <param name="returnDraftIfExists">Returns the workflow scheme's draft rather than scheme itself, if set to true. If the workflow scheme does not have a draft, then the workflow scheme is returned.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeGetByIdAndReturnDraftIfExistsAsync(int id, bool returnDraftIfExists, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"?returnDraftIfExists="+returnDraftIfExists;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a workflow scheme, including the name, default workflow, issue type to project mappings, and more. If the workflow scheme is active (that is, being used by at least one project), then a draft workflow scheme is created or updated instead, provided that updateDraftIfNeeded is set to true.
		/// WorkflowschemePutById workflowscheme/{id}
		/// </summary>
		/// <param name="id">The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID will be shown in the URL as schemeId (for example, schemeId=10301).</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemePutByIdAsync(int id, WorkflowschemePutByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id;
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a draft workflow scheme from an active workflow scheme, by copying the active workflow scheme. Note that an active workflow scheme can only have one draft workflow scheme at any given time.
		/// WorkflowschemeCreatedraftPostById workflowscheme/{id}/createdraft
		/// </summary>
		/// <param name="id">The ID of the active workflow scheme that the draft is created from.</param>
		public async Task WorkflowschemeCreatedraftPostByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/createdraft";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resets the default workflow for a workflow scheme. That is, the default workflow is set to Jira's system workflow (the jira workflow).
		/// WorkflowschemeDefaultDeleteByIdAndUpdateDraftIfNeeded workflowscheme/{id}/default
		/// </summary>
		/// <param name="id">The ID of the workflow scheme.</param>
		/// <param name="updateDraftIfNeeded">Set to true to create or update the draft of a workflow scheme and delete the mapping from the draft, when the workflow scheme cannot be edited. Defaults to false.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDefaultDeleteByIdAndUpdateDraftIfNeededAsync(int id, bool updateDraftIfNeeded, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/default?updateDraftIfNeeded="+updateDraftIfNeeded;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the default workflow for a workflow scheme. The default workflow is the workflow that is assigned any issue types that have not been mapped to any other workflow. The default workflow has All Unassigned Issue Types listed in its issue types for the workflow scheme in Jira.
		/// WorkflowschemeDefaultGetByIdAndReturnDraftIfExists workflowscheme/{id}/default
		/// </summary>
		/// <param name="id">The ID of the workflow scheme.</param>
		/// <param name="returnDraftIfExists">Set to true to return the default workflow for the workflow scheme's draft rather than scheme itself. If the workflow scheme does not have a draft, then the default workflow for the workflow scheme is returned.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDefaultGetByIdAndReturnDraftIfExistsAsync(int id, bool returnDraftIfExists, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/default?returnDraftIfExists="+returnDraftIfExists;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the default workflow for a workflow scheme.
		/// WorkflowschemeDefaultPutById workflowscheme/{id}/default
		/// </summary>
		/// <param name="id">The ID of the workflow scheme.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDefaultPutByIdAsync(int id, WorkflowschemeDefaultPutByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/default";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a draft workflow scheme.
		/// WorkflowschemeDraftDeleteById workflowscheme/{id}/draft
		/// </summary>
		/// <param name="id">The ID of the active workflow scheme that the draft was originally created from.</param>
		public async Task WorkflowschemeDraftDeleteByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the draft workflow scheme for an active workflow scheme. Draft workflow schemes allow changes to be made to the active workflow schemes: When an active workflow scheme is updated, a draft copy is created. The draft is modified, then the changes in the draft are copied back to the active workflow scheme. See Configuring workflow schemes for more information.Note that:
		/// WorkflowschemeDraftGetById workflowscheme/{id}/draft
		/// </summary>
		/// <param name="id">The ID of the active workflow scheme that the draft was originally created from.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftGetByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a draft workflow scheme. If a draft workflow scheme does not exist for the active workflow scheme, then a draft is created. Note that an active workflow scheme can only have one draft workflow scheme at any given time.
		/// WorkflowschemeDraftPutById workflowscheme/{id}/draft
		/// </summary>
		/// <param name="id">The ID of the active workflow scheme that the draft was originally created from.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftPutByIdAsync(int id, WorkflowschemeDraftPutByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Resets the default workflow for a workflow scheme's draft. That is, the default workflow is set to Jira's system workflow (the jira workflow).
		/// WorkflowschemeDraftDefaultDeleteById workflowscheme/{id}/draft/default
		/// </summary>
		/// <param name="id">The ID of the workflow scheme that the draft belongs to.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftDefaultDeleteByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft/default";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the default workflow for a workflow scheme's draft. The default workflow is the workflow that is assigned any issue types that have not been mapped to any other workflow. The default workflow has All Unassigned Issue Types listed in its issue types for the workflow scheme in Jira.
		/// WorkflowschemeDraftDefaultGetById workflowscheme/{id}/draft/default
		/// </summary>
		/// <param name="id">The ID of the workflow scheme that the draft belongs to.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftDefaultGetByIdAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft/default";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the default workflow for a workflow scheme's draft.
		/// WorkflowschemeDraftDefaultPutById workflowscheme/{id}/draft/default
		/// </summary>
		/// <param name="id">The ID of the workflow scheme that the draft belongs to.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftDefaultPutByIdAsync(int id, WorkflowschemeDraftDefaultPutByIdBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft/default";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the issue type-workflow mapping for an issue type in a workflow scheme's draft.
		/// WorkflowschemeDraftIssuetypeDeleteByIdAndIssueType workflowscheme/{id}/draft/issuetype/{issueType}
		/// </summary>
		/// <param name="id">The ID of the workflow scheme that the draft belongs to.</param>
		/// <param name="issueType">The ID of the issue type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftIssuetypeDeleteByIdAndIssueTypeAsync(int id, string issueType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft/issuetype/"+ (issueType==null? "" : Uri.EscapeDataString(issueType));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the issue type-workflow mapping for an issue type in a workflow scheme's draft.
		/// WorkflowschemeDraftIssuetypeGetByIdAndIssueType workflowscheme/{id}/draft/issuetype/{issueType}
		/// </summary>
		/// <param name="id">The ID of the workflow scheme that the draft belongs to.</param>
		/// <param name="issueType">The ID of the issue type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftIssuetypeGetByIdAndIssueTypeAsync(int id, string issueType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft/issuetype/"+ (issueType==null? "" : Uri.EscapeDataString(issueType));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the workflow for an issue type in a workflow scheme's draft.
		/// WorkflowschemeDraftIssuetypePutByIdAndIssueType workflowscheme/{id}/draft/issuetype/{issueType}
		/// </summary>
		/// <param name="id">The ID of the workflow scheme that the draft belongs to.</param>
		/// <param name="issueType">The ID of the issue type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftIssuetypePutByIdAndIssueTypeAsync(int id, string issueType, WorkflowschemeDraftIssuetypePutByIdAndIssueTypeBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft/issuetype/"+ (issueType==null? "" : Uri.EscapeDataString(issueType));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the workflow-issue type mapping for a workflow in a workflow scheme's draft.
		/// WorkflowschemeDraftWorkflowDeleteByIdAndWorkflowName workflowscheme/{id}/draft/workflow
		/// </summary>
		/// <param name="id">The ID of the workflow scheme that the draft belongs to.</param>
		/// <param name="workflowName">The name of the workflow.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftWorkflowDeleteByIdAndWorkflowNameAsync(int id, string workflowName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft/workflow?workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the workflow-issue type mappings for a workflow scheme's draft.
		/// WorkflowschemeDraftWorkflowGetByIdAndWorkflowName workflowscheme/{id}/draft/workflow
		/// </summary>
		/// <param name="id">The ID of the workflow scheme that the draft belongs to.</param>
		/// <param name="workflowName">The name of a workflow in the scheme. Limits the results to the workflow-issue type mapping for the specified workflow.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftWorkflowGetByIdAndWorkflowNameAsync(int id, string workflowName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft/workflow?workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the issue types for a workflow in a workflow scheme's draft. The workflow can also be set as the default workflow for the draft workflow scheme. Unmapped issues types are mapped to the default workflow.
		/// WorkflowschemeDraftWorkflowPutByIdAndWorkflowName workflowscheme/{id}/draft/workflow
		/// </summary>
		/// <param name="id">The ID of the workflow scheme that the draft belongs to.</param>
		/// <param name="workflowName">The name of the workflow.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeDraftWorkflowPutByIdAndWorkflowNameAsync(int id, string workflowName, WorkflowschemeDraftWorkflowPutByIdAndWorkflowNameBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/draft/workflow?workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the issue type-workflow mapping for an issue type in a workflow scheme.
		/// WorkflowschemeIssuetypeDeleteByIdAndIssueTypeAndUpdateDraftIfNeeded workflowscheme/{id}/issuetype/{issueType}
		/// </summary>
		/// <param name="id">The ID of the workflow scheme.</param>
		/// <param name="issueType">The ID of the issue type.</param>
		/// <param name="updateDraftIfNeeded">Set to true to create or update the draft of a workflow scheme and update the mapping in the draft, when the workflow scheme cannot be edited. Defaults to false.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeIssuetypeDeleteByIdAndIssueTypeAndUpdateDraftIfNeededAsync(int id, string issueType, bool updateDraftIfNeeded, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/issuetype/"+ (issueType==null? "" : Uri.EscapeDataString(issueType))+"&updateDraftIfNeeded="+updateDraftIfNeeded;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the issue type-workflow mapping for an issue type in a workflow scheme.
		/// WorkflowschemeIssuetypeGetByIdAndIssueTypeAndReturnDraftIfExists workflowscheme/{id}/issuetype/{issueType}
		/// </summary>
		/// <param name="id">The ID of the workflow scheme.</param>
		/// <param name="issueType">The ID of the issue type.</param>
		/// <param name="returnDraftIfExists">Returns the mapping from the workflow scheme's draft rather than the workflow scheme, if set to true. If no draft exists, the mapping from the workflow scheme is returned.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeIssuetypeGetByIdAndIssueTypeAndReturnDraftIfExistsAsync(int id, string issueType, bool returnDraftIfExists, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/issuetype/"+ (issueType==null? "" : Uri.EscapeDataString(issueType))+"&returnDraftIfExists="+returnDraftIfExists;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the workflow for an issue type in a workflow scheme.
		/// WorkflowschemeIssuetypePutByIdAndIssueType workflowscheme/{id}/issuetype/{issueType}
		/// </summary>
		/// <param name="id">The ID of the workflow scheme.</param>
		/// <param name="issueType">The ID of the issue type.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeIssuetypePutByIdAndIssueTypeAsync(int id, string issueType, WorkflowschemeIssuetypePutByIdAndIssueTypeBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/issuetype/"+ (issueType==null? "" : Uri.EscapeDataString(issueType));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the workflow-issue type mapping for a workflow in a workflow scheme.
		/// WorkflowschemeWorkflowDeleteByIdAndUpdateDraftIfNeededAndWorkflowName workflowscheme/{id}/workflow
		/// </summary>
		/// <param name="id">The ID of the workflow scheme.</param>
		/// <param name="updateDraftIfNeeded">Set to true to create or update the draft of a workflow scheme and delete the mapping from the draft, when the workflow scheme cannot be edited. Defaults to false.</param>
		/// <param name="workflowName">The name of the workflow.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeWorkflowDeleteByIdAndUpdateDraftIfNeededAndWorkflowNameAsync(int id, bool updateDraftIfNeeded, string workflowName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/workflow?updateDraftIfNeeded="+updateDraftIfNeeded+"&workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the workflow-issue type mappings for a workflow scheme.
		/// WorkflowschemeWorkflowGetByIdAndReturnDraftIfExistsAndWorkflowName workflowscheme/{id}/workflow
		/// </summary>
		/// <param name="id">The ID of the workflow scheme.</param>
		/// <param name="returnDraftIfExists">Returns the mapping from the workflow scheme's draft rather than the workflow scheme, if set to true. If no draft exists, the mapping from the workflow scheme is returned.</param>
		/// <param name="workflowName">The name of a workflow in the scheme. Limits the results to the workflow-issue type mapping for the specified workflow.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeWorkflowGetByIdAndReturnDraftIfExistsAndWorkflowNameAsync(int id, bool returnDraftIfExists, string workflowName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/workflow?returnDraftIfExists="+returnDraftIfExists+"&workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the issue types for a workflow in a workflow scheme. The workflow can also be set as the default workflow for the workflow scheme. Unmapped issues types are mapped to the default workflow.
		/// WorkflowschemeWorkflowPutByIdAndWorkflowName workflowscheme/{id}/workflow
		/// </summary>
		/// <param name="id">The ID of the workflow scheme.</param>
		/// <param name="workflowName">The name of the workflow.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorkflowschemeWorkflowPutByIdAndWorkflowNameAsync(int id, string workflowName, WorkflowschemeWorkflowPutByIdAndWorkflowNameBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "workflowscheme/"+id+"/workflow?workflowName=" + (workflowName==null? "" : Uri.EscapeDataString(workflowName));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of IDs and delete timestamps for worklogs deleted after a date and time.
		/// WorklogDeletedGetBySince worklog/deleted
		/// </summary>
		/// <param name="since">The date and time, in UNIX timestamp format, after which deleted worklogs are returned.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorklogDeletedGetBySinceAsync(int since, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "worklog/deleted?since="+since;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns worklog details for a list of worklog IDs.
		/// WorklogListPostByExpand worklog/list
		/// </summary>
		/// <param name="expand">Use expand to include additional information about worklogs in the response. This parameter accepts properties that returns the properties of each worklog.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorklogListPostByExpandAsync(string expand, WorklogListPostByExpandBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "worklog/list?expand=" + (expand==null? "" : Uri.EscapeDataString(expand));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of IDs and update timestamps for worklogs updated after a date and time.
		/// WorklogUpdatedGetByExpandAndSince worklog/updated
		/// </summary>
		/// <param name="expand">Use expand to include additional information about worklogs in the response. This parameter accepts properties that returns the properties of each worklog.</param>
		/// <param name="since">The date and time, in UNIX timestamp format, after which updated worklogs are returned.</param>
		/// <returns>Returned if the request is successful.</returns>
		public async Task WorklogUpdatedGetByExpandAndSinceAsync(string expand, int since, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "worklog/updated?expand=" + (expand==null? "" : Uri.EscapeDataString(expand))+"&since="+since;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Application_propertiesPutByIdBody
	{
		
		/// <summary>
		/// The ID of the application property, for example jira.newsletter.tip.delay.days.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// The new value, for example -1.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CommentListPostByExpandBody
	{
		
		/// <summary>
		/// The list of comment IDs. Maximum of 1000 IDs can be specified. Required
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public int[] Ids { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ComponentPostBody
	{
		
		/// <summary>
		/// A user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Assignee { get; set; }
		
		/// <summary>
		/// The nominal user type used to determine the assignee for issues created with this component. See realAssigneeType for details on how the type of the user, and hence the user, assigned to issues is determined. Can take the following values:
		/// </summary>
		public ComponentPostBodyAssigneeType AssigneeType { get; set; }
		
		/// <summary>
		/// The description for the component. Optional when creating or updating a component.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// A user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Lead { get; set; }
		
		/// <summary>
		/// The accountId of the component's lead user. The accountId uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192.Optional when creating or updating a component.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LeadAccountId { get; set; }
		
		/// <summary>
		/// This property has been deprecated in favour of leadAccountId due to privacy changes. See the migration guide for details.The username of the component's lead user. Optional when creating or updating a component.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LeadUserName { get; set; }
		
		/// <summary>
		/// The unique name for the component in the project. Required when creating a component. Optional when updating a component. Maximum length 255 chars.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The key of the project to which the component is assigned. Required when creating a component. Can't be updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Project { get; set; }
		
		/// <summary>
		/// Not used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProjectId { get; set; }
		
		/// <summary>
		/// A user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RealAssignee { get; set; }
	}
	
	public enum ComponentPostBodyAssigneeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROJECT_DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPONENT_LEAD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROJECT_LEAD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNASSIGNED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ComponentPutByIdBody
	{
		
		/// <summary>
		/// A user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Assignee { get; set; }
		
		/// <summary>
		/// The nominal user type used to determine the assignee for issues created with this component. See realAssigneeType for details on how the type of the user, and hence the user, assigned to issues is determined. Can take the following values:
		/// </summary>
		public ComponentPutByIdBodyAssigneeType AssigneeType { get; set; }
		
		/// <summary>
		/// The description for the component. Optional when creating or updating a component.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// A user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Lead { get; set; }
		
		/// <summary>
		/// The accountId of the component's lead user. The accountId uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192.Optional when creating or updating a component.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LeadAccountId { get; set; }
		
		/// <summary>
		/// This property has been deprecated in favour of leadAccountId due to privacy changes. See the migration guide for details.The username of the component's lead user. Optional when creating or updating a component.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LeadUserName { get; set; }
		
		/// <summary>
		/// The unique name for the component in the project. Required when creating a component. Optional when updating a component. Maximum length 255 chars.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The key of the project to which the component is assigned. Required when creating a component. Can't be updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Project { get; set; }
		
		/// <summary>
		/// Not used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProjectId { get; set; }
		
		/// <summary>
		/// A user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RealAssignee { get; set; }
	}
	
	public enum ComponentPutByIdBodyAssigneeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROJECT_DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPONENT_LEAD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROJECT_LEAD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNASSIGNED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ConfigurationTimetrackingPutBody
	{
		
		/// <summary>
		/// The key for the time tracking provider (for example, JIRA).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// The name of the time tracking provider (for example, JIRA provided time tracking).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ConfigurationTimetrackingOptionsPutBody
	{
		
		/// <summary>
		/// The unit of time that will be applied to logged time by default.
		/// </summary>
		public ConfigurationTimetrackingOptionsPutBodyDefaultUnit DefaultUnit { get; set; }
		
		/// <summary>
		/// The format that will appear on an issue's Time Spent field.
		/// </summary>
		public ConfigurationTimetrackingOptionsPutBodyTimeFormat TimeFormat { get; set; }
		
		/// <summary>
		/// The number of days in a working week (for example, 5.5). This value is specified in days.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> WorkingDaysPerWeek { get; set; }
		
		/// <summary>
		/// The number of hours in a working day (for example, 7.6). This value is specified in hours.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> WorkingHoursPerDay { get; set; }
	}
	
	public enum ConfigurationTimetrackingOptionsPutBodyDefaultUnit
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		minute = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		day = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		week = 3,
	}
	
	public enum ConfigurationTimetrackingOptionsPutBodyTimeFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pretty = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		days = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hours = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ExpressionEvalPostByExpandBody
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Context { get; set; }
		
		/// <summary>
		/// The Jira expression to evaluate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Expression { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FieldPostBody
	{
		
		/// <summary>
		/// The description of the custom field, which is displayed in the UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the custom field, which is displayed in the UI. This is not the unique identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The searcher defines the way the field is searched in Jira. For example, com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher.The search UI (basic search and JQL search) will display different operations and values for the field, based on the field searcher. You must specify a searcher that is valid for the field type, as listed below (abbreviated values shown):
		/// </summary>
		public FieldPostBodySearcherKey SearcherKey { get; set; }
		
		/// <summary>
		/// The type of the custom field. For example, com.atlassian.jira.plugin.system.customfieldtypes:grouppicker.
		/// </summary>
		public FieldPostBodyType Type { get; set; }
	}
	
	public enum FieldPostBodySearcherKey
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:cascadingselectsearcher")]
		com_atlassian_jira_plugin_system_customfieldtypescascadingselectsearcher = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:daterange")]
		com_atlassian_jira_plugin_system_customfieldtypesdaterange = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:datetimerange")]
		com_atlassian_jira_plugin_system_customfieldtypesdatetimerange = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:exactnumber")]
		com_atlassian_jira_plugin_system_customfieldtypesexactnumber = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:exacttextsearcher")]
		com_atlassian_jira_plugin_system_customfieldtypesexacttextsearcher = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher")]
		com_atlassian_jira_plugin_system_customfieldtypesgrouppickersearcher = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:labelsearcher")]
		com_atlassian_jira_plugin_system_customfieldtypeslabelsearcher = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher")]
		com_atlassian_jira_plugin_system_customfieldtypesmultiselectsearcher = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:numberrange")]
		com_atlassian_jira_plugin_system_customfieldtypesnumberrange = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:projectsearcher")]
		com_atlassian_jira_plugin_system_customfieldtypesprojectsearcher = 9,
	}
	
	public enum FieldPostBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect")]
		com_atlassian_jira_plugin_system_customfieldtypescascadingselect = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:datepicker")]
		com_atlassian_jira_plugin_system_customfieldtypesdatepicker = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:datetime")]
		com_atlassian_jira_plugin_system_customfieldtypesdatetime = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:float")]
		com_atlassian_jira_plugin_system_customfieldtypesfloat = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:grouppicker")]
		com_atlassian_jira_plugin_system_customfieldtypesgrouppicker = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:importid")]
		com_atlassian_jira_plugin_system_customfieldtypesimportid = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:labels")]
		com_atlassian_jira_plugin_system_customfieldtypeslabels = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes")]
		com_atlassian_jira_plugin_system_customfieldtypesmulticheckboxes = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:multigrouppicker")]
		com_atlassian_jira_plugin_system_customfieldtypesmultigrouppicker = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira.plugin.system.customfieldtypes:multiselect")]
		com_atlassian_jira_plugin_system_customfieldtypesmultiselect = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FieldOptionPostByFieldKeyBody
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Config { get; set; }
		
		/// <summary>
		/// The properties can be any arbitrary key value pairs. These properties can be searched using JQL, if the extractions (see https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/) are defined in the descriptor for the issue field module.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Properties { get; set; }
		
		/// <summary>
		/// The option's name, which is displayed in the UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FieldOptionPutByFieldKeyAndOptionIdBody
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Config { get; set; }
		
		/// <summary>
		/// The properties can be any arbitrary key value pairs. These properties can be searched using JQL, if the extractions (see https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/) are defined in the descriptor for the issue field module.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Properties { get; set; }
		
		/// <summary>
		/// The option's name, which is displayed in the UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FilterPostByExpandBody
	{
		
		/// <summary>
		/// A description of the filter (e.g., This filter returns open bugs for the Example project).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the filter (e.g., Open bugs for Example project). Must be unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// A user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Owner { get; set; }
		
		/// <summary>
		/// The groups and projects that the filter is shared with. This can be specified when updating a filter, but not when creating a filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] SharePermissions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SharedUsers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Subscriptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FilterDefaultShareScopePutBody
	{
		
		/// <summary>
		/// The scope of the default sharing for new filters and dashboards:
		/// </summary>
		public FilterDefaultShareScopePutBodyScope Scope { get; set; }
	}
	
	public enum FilterDefaultShareScopePutBodyScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTHENTICATED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FilterPutByExpandAndIdBody
	{
		
		/// <summary>
		/// A description of the filter (e.g., This filter returns open bugs for the Example project).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the filter (e.g., Open bugs for Example project). Must be unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// A user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Owner { get; set; }
		
		/// <summary>
		/// The groups and projects that the filter is shared with. This can be specified when updating a filter, but not when creating a filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] SharePermissions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SharedUsers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Subscriptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FilterPermissionPostByIdBody
	{
		
		/// <summary>
		/// The name of the group to share the filter with. Set type to group.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Groupname { get; set; }
		
		/// <summary>
		/// The ID of the project to share the filter with. Set type to project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProjectId { get; set; }
		
		/// <summary>
		/// The ID of the project role to share the filter with. Set type to projectRole and the projectId for the project that the role is in.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProjectRoleId { get; set; }
		
		/// <summary>
		/// The type of the share permission.Specify the type as follows:
		/// </summary>
		public FilterPermissionPostByIdBodyType Type { get; set; }
	}
	
	public enum FilterPermissionPostByIdBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		project = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		group = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		projectRole = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		global = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		authenticated = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GroupPostBody
	{
		
		/// <summary>
		/// The name of the group.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GroupUserPostByGroupnameBody
	{
		
		/// <summary>
		/// The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AccountId { get; set; }
		
		/// <summary>
		/// This property has been deprecated in favour of accountId due to privacy changes. See the migration guide for details.The username of the user. For example, admin.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssuePostByUpdateHistoryBody
	{
		
		/// <summary>
		/// List of issue screen field to update, specifying the sub-field to update and its value. This field provides a straightforward option when setting a single sub-field. When multiple sub-fields or other operations are required, use update. Fields included in here cannot be included in update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Fields { get; set; }
		
		/// <summary>
		/// Details of issue history metadata. Deprecated.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string HistoryMetadata { get; set; }
		
		/// <summary>
		/// Details of issue properties to be add or update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Properties { get; set; }
		
		/// <summary>
		/// Details of an issue transition.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Transition { get; set; }
		
		/// <summary>
		/// List of operations to perform on issue screen fields. Note that fields included in here cannot be included in fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Update { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueBulkPostBody
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] IssueUpdates { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssuePropertiesPutByPropertyKeyBody
	{
		
		/// <summary>
		/// Bulk operation filter details.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Filter { get; set; }
		
		/// <summary>
		/// The value of the property. The value must be a valid, non-empty JSON blob. The maximum length is 32768 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssuePutByIssueIdOrKeyAndNotifyUsersAndOverrideEditableFlagAndOverrideScreenSecurityBody
	{
		
		/// <summary>
		/// List of issue screen field to update, specifying the sub-field to update and its value. This field provides a straightforward option when setting a single sub-field. When multiple sub-fields or other operations are required, use update. Fields included in here cannot be included in update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Fields { get; set; }
		
		/// <summary>
		/// Details of issue history metadata. Deprecated.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string HistoryMetadata { get; set; }
		
		/// <summary>
		/// Details of issue properties to be add or update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Properties { get; set; }
		
		/// <summary>
		/// Details of an issue transition.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Transition { get; set; }
		
		/// <summary>
		/// List of operations to perform on issue screen fields. Note that fields included in here cannot be included in fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Update { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueAssigneePutByIssueIdOrKeyBody
	{
		
		/// <summary>
		/// The accountId of the user, which uniquely identifies the user across all Atlassian products. For example, 384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AccountId { get; set; }
		
		/// <summary>
		/// Indicates whether the user is active.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The application roles the user is assigned to.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ApplicationRoles { get; set; }
		
		/// <summary>
		/// The avatars of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AvatarUrls { get; set; }
		
		/// <summary>
		/// The display name of the user. Depending on the user’s privacy setting, this may return an alternative value.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The email address of the user. Depending on the user’s privacy setting, this may be returned as null.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string EmailAddress { get; set; }
		
		/// <summary>
		/// The groups that the user belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Groups { get; set; }
		
		/// <summary>
		/// This property has been deprecated in favour of accountId due to privacy changes. See the migration guide for details.The key of the user. For example, admin.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// The locale of the user. Depending on the user’s privacy setting, this may be returned as null.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Locale { get; set; }
		
		/// <summary>
		/// This property has been deprecated in favour of accountId due to privacy changes. See the migration guide for details.The username of the user. For example, admin.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The time zone specified in the user's profile. Depending on the user’s privacy setting, this may be returned as null.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TimeZone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueCommentPostByExpandAndIssueIdOrKeyBody
	{
		
		/// <summary>
		/// The comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Body { get; set; }
		
		/// <summary>
		/// Indicates whether the comment is visible in Jira Service Desk. Optional on create and update. Defaults to true. If the site doesn't use Jira Service Desk or the project isn't a Jira Service Desk projectthis parameter defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> JsdPublic { get; set; }
		
		/// <summary>
		/// A list of comment properties. Optional on create and update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Properties { get; set; }
		
		/// <summary>
		/// The group or role to which this comment is visible. Optional on create and update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueCommentPutByExpandAndIdAndIssueIdOrKeyBody
	{
		
		/// <summary>
		/// The comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Body { get; set; }
		
		/// <summary>
		/// Indicates whether the comment is visible in Jira Service Desk. Optional on create and update. Defaults to true. If the site doesn't use Jira Service Desk or the project isn't a Jira Service Desk projectthis parameter defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> JsdPublic { get; set; }
		
		/// <summary>
		/// A list of comment properties. Optional on create and update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Properties { get; set; }
		
		/// <summary>
		/// The group or role to which this comment is visible. Optional on create and update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueNotifyPostByIssueIdOrKeyBody
	{
		
		/// <summary>
		/// The HTML body of the email notification for the issue.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string HtmlBody { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Restrict { get; set; }
		
		/// <summary>
		/// The subject of the email notification for the issue. If this is not specified, then the subject is set to the issue key and summary.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Subject { get; set; }
		
		/// <summary>
		/// The plain text body of the email notification for the issue.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TextBody { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueRemotelinkPostByIssueIdOrKeyBody
	{
		
		/// <summary>
		/// The application the linked item is in.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Application { get; set; }
		
		/// <summary>
		/// The global ID of the link, such as the ID of the item on the remote system. The maximum length is 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string GlobalId { get; set; }
		
		/// <summary>
		/// The linked item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Object { get; set; }
		
		/// <summary>
		/// Description of the relationship between the issue and the linked item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Relationship { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueRemotelinkPutByIssueIdOrKeyAndLinkIdBody
	{
		
		/// <summary>
		/// The application the linked item is in.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Application { get; set; }
		
		/// <summary>
		/// The global ID of the link, such as the ID of the item on the remote system. The maximum length is 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string GlobalId { get; set; }
		
		/// <summary>
		/// The linked item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Object { get; set; }
		
		/// <summary>
		/// Description of the relationship between the issue and the linked item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Relationship { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueTransitionsPostByIssueIdOrKeyBody
	{
		
		/// <summary>
		/// List of issue screen field to update, specifying the sub-field to update and its value. This field provides a straightforward option when setting a single sub-field. When multiple sub-fields or other operations are required, use update. Fields included in here cannot be included in update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Fields { get; set; }
		
		/// <summary>
		/// Details of issue history metadata. Deprecated.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string HistoryMetadata { get; set; }
		
		/// <summary>
		/// Details of issue properties to be add or update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Properties { get; set; }
		
		/// <summary>
		/// Details of an issue transition.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Transition { get; set; }
		
		/// <summary>
		/// List of operations to perform on issue screen fields. Note that fields included in here cannot be included in fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Update { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueWorklogPostByAdjustEstimateAndExpandAndIssueIdOrKeyAndNewEstimateAndNotifyUsersAndOverrideEditableFlagAndReduceByBody
	{
		
		/// <summary>
		/// User details. Read only.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Author { get; set; }
		
		/// <summary>
		/// A comment about the worklog. Optional when creating or updating a worklog.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		/// <summary>
		/// Details of properties for the worklog. Optional when creating or updating a worklog.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Properties { get; set; }
		
		/// <summary>
		/// The datetime on which the worklog effort was started. Required when creating a worklog. Optional when updating a worklog.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Started { get; set; }
		
		/// <summary>
		/// The time spent working on the issue as days (#d), hours (#h), or minutes (#m or #). Required when creating a worklog if timeSpentSeconds isn't provided. Optional when updating a worklog. Cannot be provided if timeSpentSecond is provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TimeSpent { get; set; }
		
		/// <summary>
		/// The time in seconds spent working on the issue. Required when creating a worklog if timeSpent isn't provided. Optional when updating a worklog. Cannot be provided if timeSpent is provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TimeSpentSeconds { get; set; }
		
		/// <summary>
		/// User details. Read only.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UpdateAuthor { get; set; }
		
		/// <summary>
		/// The group or role to which this item is visible.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueWorklogPutByAdjustEstimateAndExpandAndIdAndIssueIdOrKeyAndNewEstimateAndNotifyUsersAndOverrideEditableFlagBody
	{
		
		/// <summary>
		/// User details. Read only.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Author { get; set; }
		
		/// <summary>
		/// A comment about the worklog. Optional when creating or updating a worklog.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		/// <summary>
		/// Details of properties for the worklog. Optional when creating or updating a worklog.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Properties { get; set; }
		
		/// <summary>
		/// The datetime on which the worklog effort was started. Required when creating a worklog. Optional when updating a worklog.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Started { get; set; }
		
		/// <summary>
		/// The time spent working on the issue as days (#d), hours (#h), or minutes (#m or #). Required when creating a worklog if timeSpentSeconds isn't provided. Optional when updating a worklog. Cannot be provided if timeSpentSecond is provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TimeSpent { get; set; }
		
		/// <summary>
		/// The time in seconds spent working on the issue. Required when creating a worklog if timeSpent isn't provided. Optional when updating a worklog. Cannot be provided if timeSpent is provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TimeSpentSeconds { get; set; }
		
		/// <summary>
		/// User details. Read only.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UpdateAuthor { get; set; }
		
		/// <summary>
		/// The group or role to which this item is visible.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueLinkPostBody
	{
		
		/// <summary>
		/// A comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		/// <summary>
		/// The ID or key of a linked issue.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string InwardIssue { get; set; }
		
		/// <summary>
		/// The ID or key of a linked issue.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OutwardIssue { get; set; }
		
		/// <summary>
		/// This bean is used as follows:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueLinkTypePostBody
	{
		
		/// <summary>
		/// The ID of the issue link type and is used as follows:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// The description of the issue link type inward link and is used as follows:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Inward { get; set; }
		
		/// <summary>
		/// The name of the issue link type and is used as follows:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The description of the issue link type outward link and is used as follows:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Outward { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssueLinkTypePutByIssueLinkTypeIdBody
	{
		
		/// <summary>
		/// The ID of the issue link type and is used as follows:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// The description of the issue link type inward link and is used as follows:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Inward { get; set; }
		
		/// <summary>
		/// The name of the issue link type and is used as follows:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The description of the issue link type outward link and is used as follows:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Outward { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssuetypePostBody
	{
		
		/// <summary>
		/// The description of the issue type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The unique name for the issue type. Maximum length 60 characters. Required.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Whether the issue type is subtype or standard. Defaults to standard.
		/// </summary>
		public IssuetypePostBodyType Type { get; set; }
	}
	
	public enum IssuetypePostBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		subtask = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		standard = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IssuetypePutByIdBody
	{
		
		/// <summary>
		/// The ID of an issue type avatar.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AvatarId { get; set; }
		
		/// <summary>
		/// The description of the issue type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The unique name for the issue type. Maximum length 60 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class JqlPdcleanerPostBody
	{
		
		/// <summary>
		/// The query strings having personal data that need to be migrated. There should be at most 100 queries.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] QueryStrings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MypreferencesLocalePutBody
	{
		
		/// <summary>
		/// The locale code. The Java the locale format is used: a two character language code (ISO 639), an underscore, and two letter country code (ISO 3166). For example, en_US represents a locale of English (United States). Required on create.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Locale { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PermissionsProjectPostBody
	{
		
		/// <summary>
		/// A list of permission keys.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Permissions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PermissionschemePostByExpandBody
	{
		
		/// <summary>
		/// A description for the permission scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the permission scheme. Must be unique. Required when creating or updating a permission scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The permission scheme to create or update. See About permission schemes and grants for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Permissions { get; set; }
		
		/// <summary>
		/// The scope of the permission scheme
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Scope { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PermissionschemePutByExpandAndSchemeIdBody
	{
		
		/// <summary>
		/// A description for the permission scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the permission scheme. Must be unique. Required when creating or updating a permission scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The permission scheme to create or update. See About permission schemes and grants for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Permissions { get; set; }
		
		/// <summary>
		/// The scope of the permission scheme
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Scope { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PermissionschemePermissionPostByExpandAndSchemeIdBody
	{
		
		/// <summary>
		/// The user or group being granted the permission. It consists of a type and a type-dependent parameter. See holderfor more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Holder { get; set; }
		
		/// <summary>
		/// The permission to grant. Choose from the list of built-in permissions or from any custom permissions that have been added by apps. For more information about custom permissions, see the project permission and global permission module documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Permission { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ProjectPostBody
	{
		
		/// <summary>
		/// The default assignee when creating issues for this project.
		/// </summary>
		public ProjectPostBodyAssigneeType AssigneeType { get; set; }
		
		/// <summary>
		/// An integer value for the project's avatar.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AvatarId { get; set; }
		
		/// <summary>
		/// The ID of the project's category. A complete list of category IDs can be found using the Get all project categories resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> CategoryId { get; set; }
		
		/// <summary>
		/// A brief description of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The ID of the issue security scheme for the project, which enables you to control who can and cannot view issues. Use the Get issue security schemes resource to get all issue security scheme IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IssueSecurityScheme { get; set; }
		
		/// <summary>
		/// Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. Max length is 10 characters. Required when creating a project. Optional when updating a project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Sets the username of the project lead. Either lead or leadAccountId should be setwhen creating a project. Optional when updating a project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Lead { get; set; }
		
		/// <summary>
		/// Sets the project lead account id.Either lead or leadAccountId should be setwhen creating a project. Optional when updating a project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LeadAccountId { get; set; }
		
		/// <summary>
		/// The name of the project. Required when creating a project. Optional when updating a project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the notification scheme for the project. Use the Get notification schemes resource to get a list of notification scheme IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NotificationScheme { get; set; }
		
		/// <summary>
		/// The ID of the permission scheme for the project. Use the Get all permission schemes resource to see a list of all permission scheme IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PermissionScheme { get; set; }
		
		/// <summary>
		/// A prebuilt configuration for a project. The type of the projectTemplateKey must match with the type of the projectTypeKey. Required when creating a project. Not applicable for the Update project resource.
		/// </summary>
		public ProjectPostBodyProjectTemplateKey ProjectTemplateKey { get; set; }
		
		/// <summary>
		/// The project type, which dictates the application-specific feature set. Required when creating a project. Not applicable for the Update project resource. See the Update project type resource instead.
		/// </summary>
		public ProjectPostBodyProjectTypeKey ProjectTypeKey { get; set; }
		
		/// <summary>
		/// A link to information about this project, such as project documentation
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
	}
	
	public enum ProjectPostBodyAssigneeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROJECT_LEAD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNASSIGNED = 1,
	}
	
	public enum ProjectPostBodyProjectTemplateKey
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.pyxis.greenhopper.jira:gh-simplified-agility")]
		com_pyxis_greenhopper_jiragh_simplified_agility = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.pyxis.greenhopper.jira:gh-simplified-basic")]
		com_pyxis_greenhopper_jiragh_simplified_basic = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.pyxis.greenhopper.jira:gh-simplified-kanban")]
		com_pyxis_greenhopper_jiragh_simplified_kanban = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.pyxis.greenhopper.jira:gh-simplified-scrum")]
		com_pyxis_greenhopper_jiragh_simplified_scrum = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.servicedesk:simplified-it-service-desk")]
		com_atlassian_servicedesksimplified_it_service_desk = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.servicedesk:simplified-internal-service-desk")]
		com_atlassian_servicedesksimplified_internal_service_desk = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.servicedesk:simplified-external-service-desk")]
		com_atlassian_servicedesksimplified_external_service_desk = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira-core-project-templates:jira-core-simplified-content-management")]
		com_atlassian_jira_core_project_templatesjira_core_simplified_content_management = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira-core-project-templates:jira-core-simplified-document-approval")]
		com_atlassian_jira_core_project_templatesjira_core_simplified_document_approval = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira-core-project-templates:jira-core-simplified-lead-tracking")]
		com_atlassian_jira_core_project_templatesjira_core_simplified_lead_tracking = 9,
	}
	
	public enum ProjectPostBodyProjectTypeKey
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		software = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		service_desk = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		business = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ProjectPutByExpandAndProjectIdOrKeyBody
	{
		
		/// <summary>
		/// The default assignee when creating issues for this project.
		/// </summary>
		public ProjectPutByExpandAndProjectIdOrKeyBodyAssigneeType AssigneeType { get; set; }
		
		/// <summary>
		/// An integer value for the project's avatar.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AvatarId { get; set; }
		
		/// <summary>
		/// The ID of the project's category. A complete list of category IDs can be found using the Get all project categories resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> CategoryId { get; set; }
		
		/// <summary>
		/// A brief description of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The ID of the issue security scheme for the project, which enables you to control who can and cannot view issues. Use the Get issue security schemes resource to get all issue security scheme IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IssueSecurityScheme { get; set; }
		
		/// <summary>
		/// Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. Max length is 10 characters. Required when creating a project. Optional when updating a project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Sets the username of the project lead. Either lead or leadAccountId should be setwhen creating a project. Optional when updating a project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Lead { get; set; }
		
		/// <summary>
		/// Sets the project lead account id.Either lead or leadAccountId should be setwhen creating a project. Optional when updating a project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LeadAccountId { get; set; }
		
		/// <summary>
		/// The name of the project. Required when creating a project. Optional when updating a project.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the notification scheme for the project. Use the Get notification schemes resource to get a list of notification scheme IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NotificationScheme { get; set; }
		
		/// <summary>
		/// The ID of the permission scheme for the project. Use the Get all permission schemes resource to see a list of all permission scheme IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PermissionScheme { get; set; }
		
		/// <summary>
		/// A prebuilt configuration for a project. The type of the projectTemplateKey must match with the type of the projectTypeKey. Required when creating a project. Not applicable for the Update project resource.
		/// </summary>
		public ProjectPutByExpandAndProjectIdOrKeyBodyProjectTemplateKey ProjectTemplateKey { get; set; }
		
		/// <summary>
		/// The project type, which dictates the application-specific feature set. Required when creating a project. Not applicable for the Update project resource. See the Update project type resource instead.
		/// </summary>
		public ProjectPutByExpandAndProjectIdOrKeyBodyProjectTypeKey ProjectTypeKey { get; set; }
		
		/// <summary>
		/// A link to information about this project, such as project documentation
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
	}
	
	public enum ProjectPutByExpandAndProjectIdOrKeyBodyAssigneeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROJECT_LEAD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNASSIGNED = 1,
	}
	
	public enum ProjectPutByExpandAndProjectIdOrKeyBodyProjectTemplateKey
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.pyxis.greenhopper.jira:gh-simplified-agility")]
		com_pyxis_greenhopper_jiragh_simplified_agility = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.pyxis.greenhopper.jira:gh-simplified-basic")]
		com_pyxis_greenhopper_jiragh_simplified_basic = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.pyxis.greenhopper.jira:gh-simplified-kanban")]
		com_pyxis_greenhopper_jiragh_simplified_kanban = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.pyxis.greenhopper.jira:gh-simplified-scrum")]
		com_pyxis_greenhopper_jiragh_simplified_scrum = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.servicedesk:simplified-it-service-desk")]
		com_atlassian_servicedesksimplified_it_service_desk = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.servicedesk:simplified-internal-service-desk")]
		com_atlassian_servicedesksimplified_internal_service_desk = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.servicedesk:simplified-external-service-desk")]
		com_atlassian_servicedesksimplified_external_service_desk = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira-core-project-templates:jira-core-simplified-content-management")]
		com_atlassian_jira_core_project_templatesjira_core_simplified_content_management = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira-core-project-templates:jira-core-simplified-document-approval")]
		com_atlassian_jira_core_project_templatesjira_core_simplified_document_approval = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="com.atlassian.jira-core-project-templates:jira-core-simplified-lead-tracking")]
		com_atlassian_jira_core_project_templatesjira_core_simplified_lead_tracking = 9,
	}
	
	public enum ProjectPutByExpandAndProjectIdOrKeyBodyProjectTypeKey
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		software = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		service_desk = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		business = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ProjectAvatarPutByProjectIdOrKeyBody
	{
		
		/// <summary>
		/// The ID of the avatar. Required when setting the project avatar, otherwise read only.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ProjectRolePostByIdAndProjectIdOrKeyBody
	{
		
		/// <summary>
		/// The name of the group to add.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Group { get; set; }
		
		/// <summary>
		/// The user account ID of the user to add.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ProjectRolePutByIdAndProjectIdOrKeyBody
	{
		
		/// <summary>
		/// The actors to add to the project role for the project. Provide the group name or account ID. User key may be provided instead of account ID when not in GDPR-strict mode, however this is deprecated behavior. Add groups using atlassian-group-role-actor. Add users using atlassian-user-role-actor.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CategorisedActors { get; set; }
		
		/// <summary>
		/// The ID of the project role. Use Get all project roles to get a list of project role IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ProjectPermissionschemePutByExpandAndProjectKeyOrIdBody
	{
		
		/// <summary>
		/// The ID of the permission scheme to associate with the project. Use the Get all permission schemes resource to get a list of permission scheme IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ProjectCategoryPostBody
	{
		
		/// <summary>
		/// The description of the project category. Required on create, optional on update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the project category. Required on create, optional on update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ProjectCategoryPutByIdBody
	{
		
		/// <summary>
		/// The description of the project category. Required on create, optional on update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the project category. Required on create, optional on update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RolePostBody
	{
		
		/// <summary>
		/// A description of the project role. Required when fully updating a project role. Optional when creating or partially updating a project role.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the project role. Must be unique. Cannot begin or end with whitespace. Max length is 255 characters. Required when creating a project role. Optional when partially updating a project role.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RolePostByIdBody
	{
		
		/// <summary>
		/// A description of the project role. Required when fully updating a project role. Optional when creating or partially updating a project role.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the project role. Must be unique. Cannot begin or end with whitespace. Max length is 255 characters. Required when creating a project role. Optional when partially updating a project role.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RolePutByIdBody
	{
		
		/// <summary>
		/// A description of the project role. Required when fully updating a project role. Optional when creating or partially updating a project role.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the project role. Must be unique. Cannot begin or end with whitespace. Max length is 255 characters. Required when creating a project role. Optional when partially updating a project role.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RoleActorsPostByIdBody
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Group { get; set; }
		
		/// <summary>
		/// The user account ID of the user to add as a default actor. When not in GDPR-strict-mode this may be user key instead, however this behaviour is deprecated. You can add multiple users separated by a comma (for example, "user":["12345678-9abc-def1-2345-6789abcdef12", "abcdef12-3456-789a-bcde-f123456789ab"]).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ScreensTabsPostByScreenIdBody
	{
		
		/// <summary>
		/// The name of the screen tab. Required on create and update. Maximum length is 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ScreensTabsPutByScreenIdAndTabIdBody
	{
		
		/// <summary>
		/// The name of the screen tab. Required on create and update. Maximum length is 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ScreensTabsFieldsPostByScreenIdAndTabIdBody
	{
		
		/// <summary>
		/// The ID of the field to add.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string FieldId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ScreensTabsFieldsMovePostByIdAndScreenIdAndTabIdBody
	{
		
		/// <summary>
		/// The ID of the screen tab field after which to place the moved screen tab field. Required if position isn't provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string After { get; set; }
		
		/// <summary>
		/// The named position to which the screen tab field should be moved. Required if after isn't provided.
		/// </summary>
		public ScreensTabsFieldsMovePostByIdAndScreenIdAndTabIdBodyPosition Position { get; set; }
	}
	
	public enum ScreensTabsFieldsMovePostByIdAndScreenIdAndTabIdBodyPosition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Earlier = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Later = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		First = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Last = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SearchPostBody
	{
		
		/// <summary>
		/// Use expand to include additional information about issues in the response. This parameter accepts multiple values separated by a comma:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Expand { get; set; }
		
		/// <summary>
		/// A comma-separated list of fields to return for each issue, use it to retrieve a subset of fields. Allowed values
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Fields { get; set; }
		
		/// <summary>
		/// Reference fields by their key (rather than ID). The default is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> FieldsByKeys { get; set; }
		
		/// <summary>
		/// A JQL expression.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Jql { get; set; }
		
		/// <summary>
		/// The maximum number of items to return per page. The default is 50 and maximum is 100.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// A comma-separated list of up to 5 issue properties to include in the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Properties { get; set; }
		
		/// <summary>
		/// The index of the first item to return in the page of results (page offset). The base index is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartAt { get; set; }
		
		/// <summary>
		/// Determines how to validate the JQL query and treat the validation results. Supported values:
		/// </summary>
		public SearchPostBodyValidateQuery ValidateQuery { get; set; }
	}
	
	public enum SearchPostBodyValidateQuery
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		strict = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		warn = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		@true = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		@false = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UserPostBody
	{
		
		/// <summary>
		/// Deprecated, do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ApplicationKeys { get; set; }
		
		/// <summary>
		/// The display name for the user. Required.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The email address for the user. Required.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string EmailAddress { get; set; }
		
		/// <summary>
		/// The key for the user. Read-only. This property has been deprecated due to privacy changes.See the migration guide for details.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// The username for the user. This property has been deprecated due to privacy changes. See the migration guide for details.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Sends the user an email confirmation that they have been added to Jira. Default is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Notification { get; set; }
		
		/// <summary>
		/// A password for the user. If a password is not set, a random password is generated.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Password { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VersionPostBody
	{
		
		/// <summary>
		/// Indicates that the version is archived. Optional when creating or updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Archived { get; set; }
		
		/// <summary>
		/// The description of the version. Optional when creating or updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IssuesStatusForFixVersion { get; set; }
		
		/// <summary>
		/// The URL of the self link to the version to which all unfixed issues are moved when a version is released. Not applicable when creating a version. Optional when updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MoveUnfixedIssuesTo { get; set; }
		
		/// <summary>
		/// The unique name of the version. Required when creating a version. Optional when updating a version. Maximum length 255 chars.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// If the expand option operations is used, returns the list of operations available for this version. Read only.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Operations { get; set; }
		
		/// <summary>
		/// Deprecated. Use projectId.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Project { get; set; }
		
		/// <summary>
		/// The ID of the project to which this version is attached. Required when creating a version. Not applicable when updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProjectId { get; set; }
		
		/// <summary>
		/// The release date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ReleaseDate { get; set; }
		
		/// <summary>
		/// Indicates that the version is released. If the version is released a request to release again is ignored. Not applicable when creating a version. Optional when updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Released { get; set; }
		
		/// <summary>
		/// If the expand option remotelinks is used, returns the list of remote links stored against this version. Read only.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Remotelinks { get; set; }
		
		/// <summary>
		/// The start date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string StartDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VersionPutByIdBody
	{
		
		/// <summary>
		/// Indicates that the version is archived. Optional when creating or updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Archived { get; set; }
		
		/// <summary>
		/// The description of the version. Optional when creating or updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IssuesStatusForFixVersion { get; set; }
		
		/// <summary>
		/// The URL of the self link to the version to which all unfixed issues are moved when a version is released. Not applicable when creating a version. Optional when updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MoveUnfixedIssuesTo { get; set; }
		
		/// <summary>
		/// The unique name of the version. Required when creating a version. Optional when updating a version. Maximum length 255 chars.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// If the expand option operations is used, returns the list of operations available for this version. Read only.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Operations { get; set; }
		
		/// <summary>
		/// Deprecated. Use projectId.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Project { get; set; }
		
		/// <summary>
		/// The ID of the project to which this version is attached. Required when creating a version. Not applicable when updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProjectId { get; set; }
		
		/// <summary>
		/// The release date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ReleaseDate { get; set; }
		
		/// <summary>
		/// Indicates that the version is released. If the version is released a request to release again is ignored. Not applicable when creating a version. Optional when updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Released { get; set; }
		
		/// <summary>
		/// If the expand option remotelinks is used, returns the list of remote links stored against this version. Read only.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Remotelinks { get; set; }
		
		/// <summary>
		/// The start date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string StartDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VersionMovePostByIdBody
	{
		
		/// <summary>
		/// The URI (self link) of the version after which to place the moved version. Cannot be used with position.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string After { get; set; }
		
		/// <summary>
		/// An absolute position in which to place the moved version. Cannot be used with after.
		/// </summary>
		public VersionMovePostByIdBodyPosition Position { get; set; }
	}
	
	public enum VersionMovePostByIdBodyPosition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Earlier = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Later = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		First = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Last = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VersionRemoveAndSwapPostByIdBody
	{
		
		/// <summary>
		/// A JSON array of custom field IDs (customFieldId) and version IDs (moveTo) to update when the fields contain the deleted version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] CustomFieldReplacementList { get; set; }
		
		/// <summary>
		/// The ID of the version to update affectedVersion to when the field contains the deleted version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MoveAffectedIssuesTo { get; set; }
		
		/// <summary>
		/// The ID of the version to update fixVersion to when the field contains the deleted version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MoveFixIssuesTo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowTransitionsPropertiesPostByKeyAndTransitionIdAndWorkflowModeAndWorkflowNameBody
	{
		
		/// <summary>
		/// The key of the transition property. Also known as the name of the transition property.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// The value of the transition property.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowTransitionsPropertiesPutByKeyAndTransitionIdAndWorkflowModeAndWorkflowNameBody
	{
		
		/// <summary>
		/// The key of the transition property. Also known as the name of the transition property.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// The value of the transition property.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowschemePostBody
	{
		
		/// <summary>
		/// The name of the default workflow for the workflow scheme. The default workflow has All Unassigned Issue Types assigned to it in Jira. If defaultWorkflow is not specified when creating a workflow scheme, it is set to Jira Workflow (jira).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DefaultWorkflow { get; set; }
		
		/// <summary>
		/// The description of the workflow scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The issue type-project mappings, where each mapping is an issue type ID and project name pair. Note that an issue type can only be mapped to one project in a workflow scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IssueTypeMappings { get; set; }
		
		/// <summary>
		/// The name of the workflow scheme. The name must be unique. Maximum length 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Indicates whether to create or update a draft workflow scheme when updating an active workflow scheme. An active workflow scheme is a workflow scheme that is used by at least one project. The following examples show how this property works:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UpdateDraftIfNeeded { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowschemePutByIdBody
	{
		
		/// <summary>
		/// The name of the default workflow for the workflow scheme. The default workflow has All Unassigned Issue Types assigned to it in Jira. If defaultWorkflow is not specified when creating a workflow scheme, it is set to Jira Workflow (jira).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DefaultWorkflow { get; set; }
		
		/// <summary>
		/// The description of the workflow scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The issue type-project mappings, where each mapping is an issue type ID and project name pair. Note that an issue type can only be mapped to one project in a workflow scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IssueTypeMappings { get; set; }
		
		/// <summary>
		/// The name of the workflow scheme. The name must be unique. Maximum length 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Indicates whether to create or update a draft workflow scheme when updating an active workflow scheme. An active workflow scheme is a workflow scheme that is used by at least one project. The following examples show how this property works:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UpdateDraftIfNeeded { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowschemeDefaultPutByIdBody
	{
		
		/// <summary>
		/// Indicates whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new default workflow. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UpdateDraftIfNeeded { get; set; }
		
		/// <summary>
		/// The name of the workflow to set as the default workflow. For example, jira.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Workflow { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowschemeDraftPutByIdBody
	{
		
		/// <summary>
		/// The name of the default workflow for the workflow scheme. The default workflow has All Unassigned Issue Types assigned to it in Jira. If defaultWorkflow is not specified when creating a workflow scheme, it is set to Jira Workflow (jira).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DefaultWorkflow { get; set; }
		
		/// <summary>
		/// The description of the workflow scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The issue type-project mappings, where each mapping is an issue type ID and project name pair. Note that an issue type can only be mapped to one project in a workflow scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IssueTypeMappings { get; set; }
		
		/// <summary>
		/// The name of the workflow scheme. The name must be unique. Maximum length 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Indicates whether to create or update a draft workflow scheme when updating an active workflow scheme. An active workflow scheme is a workflow scheme that is used by at least one project. The following examples show how this property works:
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UpdateDraftIfNeeded { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowschemeDraftDefaultPutByIdBody
	{
		
		/// <summary>
		/// Indicates whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new default workflow. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UpdateDraftIfNeeded { get; set; }
		
		/// <summary>
		/// The name of the workflow to set as the default workflow. For example, jira.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Workflow { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowschemeDraftIssuetypePutByIdAndIssueTypeBody
	{
		
		/// <summary>
		/// The ID of the issue type. Not required if updating the issue type-workflow mapping.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IssueType { get; set; }
		
		/// <summary>
		/// Set to true to create or update the draft of a workflow scheme and update the mapping in the draft, when the workflow scheme cannot be edited. Defaults to false. Only applicable when updating the workflow-issue types mapping.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UpdateDraftIfNeeded { get; set; }
		
		/// <summary>
		/// The name of the workflow. For example, jira.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Workflow { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowschemeDraftWorkflowPutByIdAndWorkflowNameBody
	{
		
		/// <summary>
		/// Indicates whether the workflow is the default workflow for the workflow scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DefaultMapping { get; set; }
		
		/// <summary>
		/// The list of issue type IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] IssueTypes { get; set; }
		
		/// <summary>
		/// Indicates whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new workflow-issue types mapping. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UpdateDraftIfNeeded { get; set; }
		
		/// <summary>
		/// The name of the workflow. For example, jira. Optional if updating the workflow-issue types mapping.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Workflow { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowschemeIssuetypePutByIdAndIssueTypeBody
	{
		
		/// <summary>
		/// The ID of the issue type. Not required if updating the issue type-workflow mapping.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IssueType { get; set; }
		
		/// <summary>
		/// Set to true to create or update the draft of a workflow scheme and update the mapping in the draft, when the workflow scheme cannot be edited. Defaults to false. Only applicable when updating the workflow-issue types mapping.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UpdateDraftIfNeeded { get; set; }
		
		/// <summary>
		/// The name of the workflow. For example, jira.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Workflow { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorkflowschemeWorkflowPutByIdAndWorkflowNameBody
	{
		
		/// <summary>
		/// Indicates whether the workflow is the default workflow for the workflow scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DefaultMapping { get; set; }
		
		/// <summary>
		/// The list of issue type IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] IssueTypes { get; set; }
		
		/// <summary>
		/// Indicates whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new workflow-issue types mapping. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UpdateDraftIfNeeded { get; set; }
		
		/// <summary>
		/// The name of the workflow. For example, jira. Optional if updating the workflow-issue types mapping.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Workflow { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class WorklogListPostByExpandBody
	{
		
		/// <summary>
		/// A list of worklog IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public int[] Ids { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
