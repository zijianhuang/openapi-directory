//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddFlowOutputsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Output[] Outputs { get; set; }
	}
	
	/// <summary>
	/// The output that you want to add to this flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddOutputRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] CidrAllowList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Destination { get; set; }
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Encryption Encryption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxLatency { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AddOutputRequestProtocol Protocol { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RemoteId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SmoothingLatency { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
		
		/// <summary>
		/// The settings for attaching a VPC interface to an output.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public VpcInterfaceAttachment VpcInterfaceAttachment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AddOutputRequestProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-push = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp-fec = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-pull = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rist = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddFlowSourcesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Source[] Sources { get; set; }
	}
	
	/// <summary>
	/// The settings for the source of the flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SetSourceRequest
	{
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Encryption Decryption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EntitlementArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IngestPort { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxBitrate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxLatency { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SetSourceRequestProtocol Protocol { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcInterfaceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string WhitelistCidr { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SetSourceRequestProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-push = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp-fec = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-pull = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rist = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddFlowVpcInterfacesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcInterface[] VpcInterfaces { get; set; }
	}
	
	/// <summary>
	/// Desired VPC Interface for a Flow
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VpcInterfaceRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RoleArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__string[] SecurityGroupIds { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SubnetId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateFlowResponse
	{
		
		/// <summary>
		/// The settings for a flow, including its source, outputs, and entitlements.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Flow Flow { get; set; }
	}
	
	/// <summary>
	/// The entitlements that you want to grant on a flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GrantEntitlementRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DataTransferSubscriberFeePercent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Encryption Encryption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__string[] Subscribers { get; set; }
	}
	
	/// <summary>
	/// Information about the encryption of the flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Encryption
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public EncryptionAlgorithm Algorithm { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ConstantInitializationVector { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DeviceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionKeyType KeyType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Region { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourceId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SecretArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum EncryptionAlgorithm
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aes128 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aes192 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aes256 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum EncryptionKeyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		speke = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		static-key = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum Protocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-push = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp-fec = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-pull = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rist = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum State
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteFlowResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeleteFlowResponseStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DeleteFlowResponseStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDBY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeFlowResponse
	{
		
		/// <summary>
		/// The settings for a flow, including its source, outputs, and entitlements.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Flow Flow { get; set; }
		
		/// <summary>
		/// Messages that provide the state of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Messages Messages { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GrantFlowEntitlementsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Entitlement[] Entitlements { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListEntitlementsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ListedEntitlement[] Entitlements { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListFlowsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ListedFlow[] Flows { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RemoveFlowOutputResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OutputArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RemoveFlowSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RemoveFlowVpcInterfaceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] NonDeletedNetworkInterfaceIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcInterfaceName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RevokeFlowEntitlementResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string EntitlementArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartFlowResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StartFlowResponseStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum StartFlowResponseStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDBY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StopFlowResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StopFlowResponseStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum StopFlowResponseStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDBY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowResponse
	{
		
		/// <summary>
		/// The settings for a flow, including its source, outputs, and entitlements.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Flow Flow { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowEntitlementResponse
	{
		
		/// <summary>
		/// The settings for a flow entitlement.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Entitlement Entitlement { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum Algorithm
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aes128 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aes192 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aes256 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum KeyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		speke = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		static-key = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowOutputResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		/// <summary>
		/// The settings for an output.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Output Output { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		/// <summary>
		/// The settings for the source of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Source Source { get; set; }
	}
	
	/// <summary>
	/// A request to add outputs to the specified flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddFlowOutputsRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AddOutputRequest[] Outputs { get; set; }
	}
	
	/// <summary>
	/// A request to add sources to the flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddFlowSourcesRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SetSourceRequest[] Sources { get; set; }
	}
	
	/// <summary>
	/// A request to add VPC interfaces to the flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddFlowVpcInterfacesRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public VpcInterfaceRequest[] VpcInterfaces { get; set; }
	}
	
	/// <summary>
	/// The settings for attaching a VPC interface to an output.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VpcInterfaceAttachment
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcInterfaceName { get; set; }
	}
	
	/// <summary>
	/// The settings for source failover
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FailoverConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> RecoveryWindow { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FailoverConfigState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FailoverConfigState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
	}
	
	/// <summary>
	/// Creates a new flow. The request must include one source. The request optionally can include outputs (up to 50) and entitlements (up to 50).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateFlowRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AvailabilityZone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GrantEntitlementRequest[] Entitlements { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AddOutputRequest[] Outputs { get; set; }
		
		/// <summary>
		/// The settings for the source of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SetSourceRequest Source { get; set; }
		
		/// <summary>
		/// The settings for source failover
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FailoverConfig SourceFailoverConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SetSourceRequest[] Sources { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcInterfaceRequest[] VpcInterfaces { get; set; }
	}
	
	/// <summary>
	/// The settings for a flow, including its source, outputs, and entitlements.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Flow
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AvailabilityZone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EgressIp { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Entitlement[] Entitlements { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Output[] Outputs { get; set; }
		
		/// <summary>
		/// The settings for the source of the flow.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Source Source { get; set; }
		
		/// <summary>
		/// The settings for source failover
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FailoverConfig SourceFailoverConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Source[] Sources { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FlowStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcInterface[] VpcInterfaces { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FlowStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDBY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum Status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDBY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 6,
	}
	
	/// <summary>
	/// Messages that provide the state of the flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Messages
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__string[] Errors { get; set; }
	}
	
	/// <summary>
	/// The settings for a flow entitlement.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Entitlement
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DataTransferSubscriberFeePercent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Encryption Encryption { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string EntitlementArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__string[] Subscribers { get; set; }
	}
	
	/// <summary>
	/// The settings for the source of the flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Source
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DataTransferSubscriberFeePercent { get; set; }
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Encryption Decryption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EntitlementArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IngestIp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IngestPort { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceArn { get; set; }
		
		/// <summary>
		/// Attributes related to the transport stream that are used in a source or output.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Transport Transport { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcInterfaceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string WhitelistCidr { get; set; }
	}
	
	/// <summary>
	/// A request to grant entitlements on a flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GrantFlowEntitlementsRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public GrantEntitlementRequest[] Entitlements { get; set; }
	}
	
	/// <summary>
	/// An entitlement that has been granted to you from other AWS accounts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListedEntitlement
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DataTransferSubscriberFeePercent { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string EntitlementArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string EntitlementName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENTITLED = 1,
	}
	
	/// <summary>
	/// Provides a summary of a flow, including its ARN, Availability Zone, and source type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListedFlow
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AvailabilityZone { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FlowArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedFlowSourceType SourceType { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedFlowStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListedFlowSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENTITLED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListedFlowStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDBY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 6,
	}
	
	/// <summary>
	/// Attributes related to the transport stream that are used in a source or output.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Transport
	{
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] CidrAllowList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxBitrate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxLatency { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TransportProtocol Protocol { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RemoteId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SmoothingLatency { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TransportProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-push = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp-fec = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-pull = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rist = 4,
	}
	
	/// <summary>
	/// The settings for an output.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Output
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DataTransferSubscriberFeePercent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Destination { get; set; }
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Encryption Encryption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EntitlementArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MediaLiveInputArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string OutputArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Attributes related to the transport stream that are used in a source or output.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Transport Transport { get; set; }
		
		/// <summary>
		/// The settings for attaching a VPC interface to an output.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public VpcInterfaceAttachment VpcInterfaceAttachment { get; set; }
	}
	
	/// <summary>
	/// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	/// <summary>
	/// Information about the encryption of the flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateEncryption
	{
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateEncryptionAlgorithm Algorithm { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ConstantInitializationVector { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DeviceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateEncryptionKeyType KeyType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Region { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SecretArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateEncryptionAlgorithm
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aes128 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aes192 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aes256 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateEncryptionKeyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		speke = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		static-key = 1,
	}
	
	/// <summary>
	/// The settings for source failover
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFailoverConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> RecoveryWindow { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateFailoverConfigState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateFailoverConfigState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
	}
	
	/// <summary>
	/// The entitlement fields that you want to update.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowEntitlementRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateEncryption Encryption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] Subscribers { get; set; }
	}
	
	/// <summary>
	/// The fields that you want to update in the output.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowOutputRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] CidrAllowList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Destination { get; set; }
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateEncryption Encryption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxLatency { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateFlowOutputRequestProtocol Protocol { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RemoteId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SmoothingLatency { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
		
		/// <summary>
		/// The settings for attaching a VPC interface to an output.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public VpcInterfaceAttachment VpcInterfaceAttachment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateFlowOutputRequestProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-push = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp-fec = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-pull = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rist = 4,
	}
	
	/// <summary>
	/// A request to update flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowRequest
	{
		
		/// <summary>
		/// The settings for source failover
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateFailoverConfig SourceFailoverConfig { get; set; }
	}
	
	/// <summary>
	/// A request to update the source of a flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowSourceRequest
	{
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateEncryption Decryption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EntitlementArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IngestPort { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxBitrate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxLatency { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateFlowSourceRequestProtocol Protocol { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcInterfaceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string WhitelistCidr { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateFlowSourceRequestProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-push = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp-fec = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-pull = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rist = 4,
	}
	
	/// <summary>
	/// The settings for a VPC Source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VpcInterface
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__string[] NetworkInterfaceIds { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RoleArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__string[] SecurityGroupIds { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SubnetId { get; set; }
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Adds outputs to an existing flow. You can create up to 50 outputs per flow.
		/// AddFlowOutputs /v1/flows/{flowArn}/outputs
		/// </summary>
		/// <param name="flowArn">The flow that you want to add outputs to.</param>
		public async Task AddFlowOutputsAsync(string flowArn, AddFlowOutputsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/outputs";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds Sources to flow
		/// AddFlowSources /v1/flows/{flowArn}/source
		/// </summary>
		/// <param name="flowArn">The flow that you want to mutate.</param>
		public async Task AddFlowSourcesAsync(string flowArn, AddFlowSourcesBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/source";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds VPC interfaces to flow
		/// AddFlowVpcInterfaces /v1/flows/{flowArn}/vpcInterfaces
		/// </summary>
		/// <param name="flowArn">The flow that you want to mutate.</param>
		public async Task AddFlowVpcInterfacesAsync(string flowArn, AddFlowVpcInterfacesBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/vpcInterfaces";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a new flow. The request must include one source. The request optionally can include outputs (up to 50) and entitlements (up to 50).
		/// CreateFlow /v1/flows
		/// </summary>
		public async Task CreateFlowAsync(CreateFlowBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Displays a list of flows that are associated with this account. This request returns a paginated result.
		/// ListFlows /v1/flows
		/// </summary>
		/// <param name="maxResults">The maximum number of results to return per API request. For example, you submit a ListFlows request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.</param>
		/// <param name="nextToken">The token that identifies which batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListFlowsResponse> ListFlowsAsync(int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListFlowsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a flow. Before you can delete a flow, you must stop the flow.
		/// DeleteFlow /v1/flows/{flowArn}
		/// </summary>
		/// <param name="flowArn">The ARN of the flow that you want to delete.</param>
		public async Task DeleteFlowAsync(string flowArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Displays the details of a flow. The response includes the flow ARN, name, and Availability Zone, as well as details about the source, outputs, and entitlements.
		/// DescribeFlow /v1/flows/{flowArn}
		/// </summary>
		/// <param name="flowArn">The ARN of the flow that you want to describe.</param>
		/// <returns>Success</returns>
		public async Task<DescribeFlowResponse> DescribeFlowAsync(string flowArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeFlowResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates flow
		/// UpdateFlow /v1/flows/{flowArn}
		/// </summary>
		/// <param name="flowArn">The flow that you want to update.</param>
		public async Task UpdateFlowAsync(string flowArn, UpdateFlowBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Grants entitlements to an existing flow.
		/// GrantFlowEntitlements /v1/flows/{flowArn}/entitlements
		/// </summary>
		/// <param name="flowArn">The flow that you want to grant entitlements on.</param>
		/// <returns>Success</returns>
		public async Task<GrantFlowEntitlementsResponse> GrantFlowEntitlementsAsync(string flowArn, GrantFlowEntitlementsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/entitlements";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GrantFlowEntitlementsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Displays a list of all entitlements that have been granted to this account. This request returns 20 results per page.
		/// ListEntitlements /v1/entitlements
		/// </summary>
		/// <param name="maxResults">The maximum number of results to return per API request. For example, you submit a ListEntitlements request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 20 results per page.</param>
		/// <param name="nextToken">The token that identifies which batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListEntitlementsResponse> ListEntitlementsAsync(int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/entitlements?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListEntitlementsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all tags on an AWS Elemental MediaConnect resource
		/// ListTagsForResource /tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource for which to list the tags.</param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Associates the specified tags to a resource with the specified resourceArn. If existing tags on a resource are not specified in the request parameters, they are not changed. When a resource is deleted, the tags associated with that resource are deleted as well.
		/// TagResource /tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource to which to add tags.</param>
		public async Task TagResourceAsync(string resourceArn, TagResourceBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes an output from an existing flow. This request can be made only on an output that does not have an entitlement associated with it. If the output has an entitlement, you must revoke the entitlement instead. When an entitlement is revoked from a flow, the service automatically removes the associated output.
		/// RemoveFlowOutput /v1/flows/{flowArn}/outputs/{outputArn}
		/// </summary>
		/// <param name="flowArn">The flow that you want to remove an output from.</param>
		/// <param name="outputArn">The ARN of the output that you want to remove.</param>
		public async Task RemoveFlowOutputAsync(string flowArn, string outputArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/outputs/"+ (outputArn==null? "" : Uri.EscapeDataString(outputArn));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing flow output.
		/// UpdateFlowOutput /v1/flows/{flowArn}/outputs/{outputArn}
		/// </summary>
		/// <param name="flowArn">The flow that is associated with the output that you want to update.</param>
		/// <param name="outputArn">The ARN of the output that you want to update.</param>
		public async Task UpdateFlowOutputAsync(string flowArn, string outputArn, UpdateFlowOutputBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/outputs/"+ (outputArn==null? "" : Uri.EscapeDataString(outputArn));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes a source from an existing flow. This request can be made only if there is more than one source on the flow.
		/// RemoveFlowSource /v1/flows/{flowArn}/source/{sourceArn}
		/// </summary>
		/// <param name="flowArn">The flow that you want to remove a source from.</param>
		/// <param name="sourceArn">The ARN of the source that you want to remove.</param>
		public async Task RemoveFlowSourceAsync(string flowArn, string sourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/source/"+ (sourceArn==null? "" : Uri.EscapeDataString(sourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the source of a flow.
		/// UpdateFlowSource /v1/flows/{flowArn}/source/{sourceArn}
		/// </summary>
		/// <param name="flowArn">The flow that is associated with the source that you want to update.</param>
		/// <param name="sourceArn">The ARN of the source that you want to update.</param>
		public async Task UpdateFlowSourceAsync(string flowArn, string sourceArn, UpdateFlowSourceBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/source/"+ (sourceArn==null? "" : Uri.EscapeDataString(sourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes a VPC Interface from an existing flow. This request can be made only on a VPC interface that does not have a Source or Output associated with it. If the VPC interface is referenced by a Source or Output, you must first delete or update the Source or Output to no longer reference the VPC interface.
		/// RemoveFlowVpcInterface /v1/flows/{flowArn}/vpcInterfaces/{vpcInterfaceName}
		/// </summary>
		/// <param name="flowArn">The flow that you want to remove a VPC interface from.</param>
		/// <param name="vpcInterfaceName">The name of the VPC interface that you want to remove.</param>
		/// <returns>Success</returns>
		public async Task<RemoveFlowVpcInterfaceResponse> RemoveFlowVpcInterfaceAsync(string flowArn, string vpcInterfaceName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/vpcInterfaces/"+ (vpcInterfaceName==null? "" : Uri.EscapeDataString(vpcInterfaceName));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RemoveFlowVpcInterfaceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Revokes an entitlement from a flow. Once an entitlement is revoked, the content becomes unavailable to the subscriber and the associated output is removed.
		/// RevokeFlowEntitlement /v1/flows/{flowArn}/entitlements/{entitlementArn}
		/// </summary>
		/// <param name="entitlementArn">The ARN of the entitlement that you want to revoke.</param>
		/// <param name="flowArn">The flow that you want to revoke an entitlement from.</param>
		public async Task RevokeFlowEntitlementAsync(string entitlementArn, string flowArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/entitlements/"+ (entitlementArn==null? "" : Uri.EscapeDataString(entitlementArn));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// You can change an entitlement's description, subscribers, and encryption. If you change the subscribers, the service will remove the outputs that are are used by the subscribers that are removed.
		/// UpdateFlowEntitlement /v1/flows/{flowArn}/entitlements/{entitlementArn}
		/// </summary>
		/// <param name="entitlementArn">The ARN of the entitlement that you want to update.</param>
		/// <param name="flowArn">The flow that is associated with the entitlement that you want to update.</param>
		public async Task UpdateFlowEntitlementAsync(string entitlementArn, string flowArn, UpdateFlowEntitlementBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn))+"/entitlements/"+ (entitlementArn==null? "" : Uri.EscapeDataString(entitlementArn));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Starts a flow.
		/// StartFlow /v1/flows/start/{flowArn}
		/// </summary>
		/// <param name="flowArn">The ARN of the flow that you want to start.</param>
		public async Task StartFlowAsync(string flowArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/start/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Stops a flow.
		/// StopFlow /v1/flows/stop/{flowArn}
		/// </summary>
		/// <param name="flowArn">The ARN of the flow that you want to stop.</param>
		public async Task StopFlowAsync(string flowArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/flows/stop/"+ (flowArn==null? "" : Uri.EscapeDataString(flowArn));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes specified tags from a resource.
		/// UntagResource /tags/{resourceArn}#tagKeys
		/// </summary>
		/// <param name="resourceArn">The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource from which to delete tags.</param>
		/// <param name="tagKeys">The keys of the tags to be removed.</param>
		public async Task UntagResourceAsync(string resourceArn, @__string[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn))+"#tagKeys&"+String.Join("&", tagKeys.Select(z => $"tagKeys={z}"));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddFlowOutputsBody
	{
		
		/// <summary>
		/// A list of outputs that you want to add.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AddOutputRequest[] Outputs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddFlowSourcesBody
	{
		
		/// <summary>
		/// A list of sources that you want to add.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SetSourceRequest[] Sources { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddFlowVpcInterfacesBody
	{
		
		/// <summary>
		/// A list of VPC interfaces that you want to add.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public VpcInterfaceRequest[] VpcInterfaces { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateFlowBody
	{
		
		/// <summary>
		/// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS Region.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AvailabilityZone { get; set; }
		
		/// <summary>
		/// The entitlements that you want to grant on a flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GrantEntitlementRequest[] Entitlements { get; set; }
		
		/// <summary>
		/// The name of the flow.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The outputs that you want to add to this flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AddOutputRequest[] Outputs { get; set; }
		
		/// <summary>
		/// The settings for the source of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Source { get; set; }
		
		/// <summary>
		/// The settings for source failover
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SourceFailoverConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SetSourceRequest[] Sources { get; set; }
		
		/// <summary>
		/// The VPC interfaces you want on the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public VpcInterfaceRequest[] VpcInterfaces { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowBody
	{
		
		/// <summary>
		/// The settings for source failover
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SourceFailoverConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GrantFlowEntitlementsBody
	{
		
		/// <summary>
		/// The list of entitlements that you want to grant.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public GrantEntitlementRequest[] Entitlements { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceBody
	{
		
		/// <summary>
		/// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowOutputBody
	{
		
		/// <summary>
		/// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public @__string[] CidrAllowList { get; set; }
		
		/// <summary>
		/// A description of the output. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the end user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The IP address where you want to send the output.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Destination { get; set; }
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Encryption { get; set; }
		
		/// <summary>
		/// The maximum latency in milliseconds for Zixi-based streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxLatency { get; set; }
		
		/// <summary>
		/// The port to use when content is distributed to this output.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// The protocol to use for the output.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateFlowOutputBodyProtocol Protocol { get; set; }
		
		/// <summary>
		/// The remote ID for the Zixi-pull stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RemoteId { get; set; }
		
		/// <summary>
		/// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SmoothingLatency { get; set; }
		
		/// <summary>
		/// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
		
		/// <summary>
		/// The settings for attaching a VPC interface to an output.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string VpcInterfaceAttachment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateFlowOutputBodyProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-push = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp-fec = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-pull = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rist = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowSourceBody
	{
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Decryption { get; set; }
		
		/// <summary>
		/// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string EntitlementArn { get; set; }
		
		/// <summary>
		/// The port that the flow will be listening on for incoming content.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IngestPort { get; set; }
		
		/// <summary>
		/// The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxBitrate { get; set; }
		
		/// <summary>
		/// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxLatency { get; set; }
		
		/// <summary>
		/// The protocol that is used by the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateFlowSourceBodyProtocol Protocol { get; set; }
		
		/// <summary>
		/// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
		
		/// <summary>
		/// The name of the VPC Interface to configure this Source with.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string VpcInterfaceName { get; set; }
		
		/// <summary>
		/// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string WhitelistCidr { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateFlowSourceBodyProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-push = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp-fec = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zixi-pull = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rist = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFlowEntitlementBody
	{
		
		/// <summary>
		/// A description of the entitlement. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the subscriber or end user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Information about the encryption of the flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Encryption { get; set; }
		
		/// <summary>
		/// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public @__string[] Subscribers { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
