//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AcceptSharedDirectoryResult
	{
		
		/// <summary>
		/// Details about the shared directory in the directory owner account for which the share request in the directory consumer account has been accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SharedDirectory SharedDirectory { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AcceptSharedDirectoryRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SharedDirectoryId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddIpRoutesRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public IpRoute[] IpRoutes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UpdateSecurityGroupForDirectoryControllers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddTagsToResourceRequest
	{
		
		/// <summary>
		/// Pattern: ^[d]-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CancelSchemaExtensionRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^e-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SchemaExtensionId { get; set; }
	}
	
	/// <summary>
	/// Contains the results of the <a>ConnectDirectory</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ConnectDirectoryResult
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>ConnectDirectory</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ConnectDirectoryRequest
	{
		
		/// <summary>
		/// Pattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Pattern: ^[^\\/:*?\"\<\>|.]+[^\\/:*?\"<>|]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ShortName { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string Password { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: ^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Description { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConnectDirectoryRequestSize Size { get; set; }
		
		/// <summary>
		/// Contains information for the <a>ConnectDirectory</a> operation when an AD Connector directory is being created.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DirectoryConnectSettings ConnectSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ConnectDirectoryRequestSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Small = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Large = 1,
	}
	
	/// <summary>
	/// Contains the results of the <a>CreateAlias</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateAliasResult
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 62
		/// Min length: 1
		/// Pattern: ^(?!d-)([\da-zA-Z]+)([-]*[\da-zA-Z])*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(62, MinimumLength=1)]
		public string Alias { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>CreateAlias</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateAliasRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 62
		/// Min length: 1
		/// Pattern: ^(?!d-)([\da-zA-Z]+)([-]*[\da-zA-Z])*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(62, MinimumLength=1)]
		public string Alias { get; set; }
	}
	
	/// <summary>
	/// Contains the results for the <a>CreateComputer</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateComputerResult
	{
		
		/// <summary>
		/// Contains information about a computer account in a directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Computer Computer { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>CreateComputer</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateComputerRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 15
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(15, MinimumLength=1)]
		public string ComputerName { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 8
		/// Pattern: [\u0020-\u00FF]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=8)]
		public string Password { get; set; }
		
		/// <summary>
		/// Max length: 2000
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2000, MinimumLength=1)]
		public string OrganizationalUnitDistinguishedName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Attribute[] ComputerAttributes { get; set; }
	}
	
	/// <summary>
	/// Initiates the creation of a conditional forwarder for your AWS Directory Service for Microsoft Active Directory. Conditional forwarders are required in order to set up a trust relationship with another domain.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateConditionalForwarderRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+[.]?$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RemoteDomainName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public IpAddr[] DnsIpAddrs { get; set; }
	}
	
	/// <summary>
	/// Contains the results of the <a>CreateDirectory</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateDirectoryResult
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>CreateDirectory</a> operation. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateDirectoryRequest
	{
		
		/// <summary>
		/// Pattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Pattern: ^[^\\/:*?\"\<\>|.]+[^\\/:*?\"<>|]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ShortName { get; set; }
		
		/// <summary>
		/// Pattern: (?=^.{8,64}$)((?=.*\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[^A-Za-z0-9\s])(?=.*[a-z])|(?=.*[^A-Za-z0-9\s])(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9\s]))^.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Password { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: ^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Description { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateDirectoryRequestSize Size { get; set; }
		
		/// <summary>
		/// Contains VPC information for the <a>CreateDirectory</a> or <a>CreateMicrosoftAD</a> operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DirectoryVpcSettings VpcSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateDirectoryRequestSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Small = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Large = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateLogSubscriptionRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [-._/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
	}
	
	/// <summary>
	/// Result of a CreateMicrosoftAD request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateMicrosoftADResult
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
	}
	
	/// <summary>
	/// Creates an AWS Managed Microsoft AD directory.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateMicrosoftADRequest
	{
		
		/// <summary>
		/// Pattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Pattern: ^[^\\/:*?\"\<\>|.]+[^\\/:*?\"<>|]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ShortName { get; set; }
		
		/// <summary>
		/// Pattern: (?=^.{8,64}$)((?=.*\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[^A-Za-z0-9\s])(?=.*[a-z])|(?=.*[^A-Za-z0-9\s])(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9\s]))^.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Password { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: ^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Description { get; set; }
		
		/// <summary>
		/// Contains VPC information for the <a>CreateDirectory</a> or <a>CreateMicrosoftAD</a> operation.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DirectoryVpcSettings VpcSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CreateMicrosoftADRequestEdition Edition { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateMicrosoftADRequestEdition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enterprise = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard = 1,
	}
	
	/// <summary>
	/// Contains the results of the <a>CreateSnapshot</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateSnapshotResult
	{
		
		/// <summary>
		/// Pattern: ^s-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SnapshotId { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>CreateSnapshot</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateSnapshotRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: ^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The result of a CreateTrust request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateTrustResult
	{
		
		/// <summary>
		/// Pattern: ^t-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TrustId { get; set; }
	}
	
	/// <summary>
	/// <p>AWS Directory Service for Microsoft Active Directory allows you to configure trust relationships. For example, you can establish a trust between your AWS Managed Microsoft AD directory, and your existing on-premises Microsoft Active Directory. This would allow you to provide users and groups access to resources in either domain, with a single set of credentials.</p> <p>This action initiates the creation of the AWS side of a trust relationship between an AWS Managed Microsoft AD directory and an external domain.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateTrustRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+[.]?$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RemoteDomainName { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: (.|\s)*\S(.|\s)*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string TrustPassword { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateTrustRequestTrustDirection TrustDirection { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CreateTrustRequestTrustType TrustType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IpAddr[] ConditionalForwarderIpAddrs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CreateTrustRequestSelectiveAuth SelectiveAuth { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateTrustRequestTrustDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		One-Way: Outgoing = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		One-Way: Incoming = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Two-Way = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateTrustRequestTrustType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Forest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		External = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateTrustRequestSelectiveAuth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
	}
	
	/// <summary>
	/// Deletes a conditional forwarder.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteConditionalForwarderRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+[.]?$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RemoteDomainName { get; set; }
	}
	
	/// <summary>
	/// Contains the results of the <a>DeleteDirectory</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteDirectoryResult
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>DeleteDirectory</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteDirectoryRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteLogSubscriptionRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
	}
	
	/// <summary>
	/// Contains the results of the <a>DeleteSnapshot</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteSnapshotResult
	{
		
		/// <summary>
		/// Pattern: ^s-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SnapshotId { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>DeleteSnapshot</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteSnapshotRequest
	{
		
		/// <summary>
		/// Pattern: ^s-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SnapshotId { get; set; }
	}
	
	/// <summary>
	/// The result of a DeleteTrust request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteTrustResult
	{
		
		/// <summary>
		/// Pattern: ^t-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TrustId { get; set; }
	}
	
	/// <summary>
	/// Deletes the local side of an existing trust relationship between the AWS Managed Microsoft AD directory and the external domain.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteTrustRequest
	{
		
		/// <summary>
		/// Pattern: ^t-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TrustId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DeleteAssociatedConditionalForwarder { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeregisterCertificateRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^c-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
	}
	
	/// <summary>
	/// Removes the specified directory as a publisher to the specified SNS topic.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeregisterEventTopicRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9_-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string TopicName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeCertificateResult
	{
		
		/// <summary>
		/// Information about the certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Certificate Certificate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeCertificateRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^c-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
	}
	
	/// <summary>
	/// The result of a DescribeConditionalForwarder request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeConditionalForwardersResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ConditionalForwarder[] ConditionalForwarders { get; set; }
	}
	
	/// <summary>
	/// Describes a conditional forwarder.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeConditionalForwardersRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RemoteDomainName[] RemoteDomainNames { get; set; }
	}
	
	/// <summary>
	/// Contains the results of the <a>DescribeDirectories</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeDirectoriesResult
	{
		
		/// <summary>
		/// A list of directory descriptions.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DirectoryDescription[] DirectoryDescriptions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>DescribeDirectories</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeDirectoriesRequest
	{
		
		/// <summary>
		/// A list of directory identifiers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DirectoryId[] DirectoryIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeDomainControllersResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DomainController[] DomainControllers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeDomainControllersRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DomainControllerId[] DomainControllerIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	/// <summary>
	/// The result of a DescribeEventTopic request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeEventTopicsResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public EventTopic[] EventTopics { get; set; }
	}
	
	/// <summary>
	/// Describes event topics.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeEventTopicsRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TopicName[] TopicNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeLDAPSSettingsResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LDAPSSettingInfo[] LDAPSSettingsInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeLDAPSSettingsRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribeLDAPSSettingsRequestType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 50)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeLDAPSSettingsRequestType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Client = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeSharedDirectoriesResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SharedDirectory[] SharedDirectories { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeSharedDirectoriesRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string OwnerDirectoryId { get; set; }
		
		/// <summary>
		/// A list of directory identifiers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DirectoryId[] SharedDirectoryIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	/// <summary>
	/// Contains the results of the <a>DescribeSnapshots</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeSnapshotsResult
	{
		
		/// <summary>
		/// A list of descriptions of directory snapshots.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Snapshot[] Snapshots { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>DescribeSnapshots</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeSnapshotsRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// A list of directory snapshot identifiers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SnapshotId[] SnapshotIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	/// <summary>
	/// The result of a DescribeTrust request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeTrustsResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Trust[] Trusts { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Describes the trust relationships for a particular AWS Managed Microsoft AD directory. If no input parameters are are provided, such as directory ID or trust ID, this request describes all the trust relationships.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeTrustsRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TrustId[] TrustIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DisableLDAPSRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DisableLDAPSRequestType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DisableLDAPSRequestType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Client = 0,
	}
	
	/// <summary>
	/// Contains the inputs for the <a>DisableRadius</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DisableRadiusRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>DisableSso</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DisableSsoRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9._-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string UserName { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string Password { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EnableLDAPSRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public EnableLDAPSRequestType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum EnableLDAPSRequestType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Client = 0,
	}
	
	/// <summary>
	/// Contains the inputs for the <a>EnableRadius</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EnableRadiusRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Contains information about a Remote Authentication Dial In User Service (RADIUS) server.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RadiusSettings RadiusSettings { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>EnableSso</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EnableSsoRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9._-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string UserName { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string Password { get; set; }
	}
	
	/// <summary>
	/// Contains the results of the <a>GetDirectoryLimits</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetDirectoryLimitsResult
	{
		
		/// <summary>
		/// Contains directory limit information for a Region.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DirectoryLimits DirectoryLimits { get; set; }
	}
	
	/// <summary>
	/// Contains the results of the <a>GetSnapshotLimits</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetSnapshotLimitsResult
	{
		
		/// <summary>
		/// Contains manual snapshot limit information for a directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SnapshotLimits SnapshotLimits { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>GetSnapshotLimits</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetSnapshotLimitsRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListCertificatesResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CertificateInfo[] CertificatesInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListCertificatesRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 50)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListIpRoutesResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public IpRouteInfo[] IpRoutesInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListIpRoutesRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListLogSubscriptionsResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LogSubscription[] LogSubscriptions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListLogSubscriptionsRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListSchemaExtensionsResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SchemaExtensionInfo[] SchemaExtensionsInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListSchemaExtensionsRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsForResourceResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsForResourceRequest
	{
		
		/// <summary>
		/// Pattern: ^[d]-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RegisterCertificateResult
	{
		
		/// <summary>
		/// Pattern: ^c-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RegisterCertificateRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 8192
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(8192, MinimumLength=1)]
		public string CertificateData { get; set; }
	}
	
	/// <summary>
	/// Registers a new event topic.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RegisterEventTopicRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9_-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string TopicName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RejectSharedDirectoryResult
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SharedDirectoryId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RejectSharedDirectoryRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SharedDirectoryId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RemoveIpRoutesRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CidrIp[] CidrIps { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RemoveTagsFromResourceRequest
	{
		
		/// <summary>
		/// Pattern: ^[d]-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TagKey[] TagKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ResetUserPasswordRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// Pattern: ^(?!.*\\|.*"|.*\/|.*\[|.*\]|.*:|.*;|.*\||.*=|.*,|.*\+|.*\*|.*\?|.*<|.*>|.*@).*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string UserName { get; set; }
		
		/// <summary>
		/// Max length: 127
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(127, MinimumLength=1)]
		public string NewPassword { get; set; }
	}
	
	/// <summary>
	/// An object representing the inputs for the <a>RestoreFromSnapshot</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RestoreFromSnapshotRequest
	{
		
		/// <summary>
		/// Pattern: ^s-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SnapshotId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ShareDirectoryResult
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SharedDirectoryId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ShareDirectoryRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 1024
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024)]
		public string ShareNotes { get; set; }
		
		/// <summary>
		/// Identifier that contains details about the directory consumer account.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ShareTarget ShareTarget { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ShareDirectoryRequestShareMethod ShareMethod { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ShareDirectoryRequestShareMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATIONS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HANDSHAKE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartSchemaExtensionResult
	{
		
		/// <summary>
		/// Pattern: ^e-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SchemaExtensionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartSchemaExtensionRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool CreateSnapshotBeforeSchemaExtension { get; set; }
		
		/// <summary>
		/// Max length: 500000
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(500000, MinimumLength=1)]
		public string LdifContent { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: ^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UnshareDirectoryResult
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SharedDirectoryId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UnshareDirectoryRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Identifier that contains details about the directory consumer account with whom the directory is being unshared.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UnshareTarget UnshareTarget { get; set; }
	}
	
	/// <summary>
	/// Updates a conditional forwarder.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateConditionalForwarderRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+[.]?$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RemoteDomainName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public IpAddr[] DnsIpAddrs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateNumberOfDomainControllersRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int DesiredNumber { get; set; }
	}
	
	/// <summary>
	/// Contains the inputs for the <a>UpdateRadius</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateRadiusRequest
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Contains information about a Remote Authentication Dial In User Service (RADIUS) server.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RadiusSettings RadiusSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateTrustResult
	{
		
		/// <summary>
		/// The AWS request identifier.
		/// Pattern: ^([A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RequestId { get; set; }
		
		/// <summary>
		/// Pattern: ^t-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TrustId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateTrustRequest
	{
		
		/// <summary>
		/// Pattern: ^t-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TrustId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateTrustRequestSelectiveAuth SelectiveAuth { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateTrustRequestSelectiveAuth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
	}
	
	/// <summary>
	/// Result of a VerifyTrust request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VerifyTrustResult
	{
		
		/// <summary>
		/// Pattern: ^t-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TrustId { get; set; }
	}
	
	/// <summary>
	/// Initiates the verification of an existing trust relationship between an AWS Managed Microsoft AD directory and an external domain.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class VerifyTrustRequest
	{
		
		/// <summary>
		/// Pattern: ^t-[0-9a-f]{10}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TrustId { get; set; }
	}
	
	/// <summary>
	/// Details about the shared directory in the directory owner account for which the share request in the directory consumer account has been accepted.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SharedDirectory
	{
		
		/// <summary>
		/// Pattern: ^(\d{12})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OwnerAccountId { get; set; }
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OwnerDirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SharedDirectoryShareMethod ShareMethod { get; set; }
		
		/// <summary>
		/// Pattern: ^(\d{12})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SharedAccountId { get; set; }
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SharedDirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SharedDirectoryShareStatus ShareStatus { get; set; }
		
		/// <summary>
		/// Max length: 1024
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024)]
		public string ShareNotes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreatedDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastUpdatedDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SharedDirectoryShareMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATIONS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HANDSHAKE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SharedDirectoryShareStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Shared = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PendingAcceptance = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Rejected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Rejecting = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RejectFailed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Sharing = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ShareFailed = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 8,
	}
	
	/// <summary>
	/// Represents a named directory attribute.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Attribute
	{
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CertificateState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Registering = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Registered = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RegisterFailed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deregistering = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deregistered = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DeregisterFailed = 5,
	}
	
	/// <summary>
	/// Information about the certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Certificate
	{
		
		/// <summary>
		/// Pattern: ^c-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CertificateState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StateReason { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommonName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> RegisteredDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ExpiryDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CertificateState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Registering = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Registered = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RegisterFailed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deregistering = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deregistered = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DeregisterFailed = 5,
	}
	
	/// <summary>
	/// Contains general information about a certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CertificateInfo
	{
		
		/// <summary>
		/// Pattern: ^c-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommonName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CertificateInfoState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ExpiryDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CertificateInfoState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Registering = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Registered = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RegisterFailed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deregistering = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deregistered = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DeregisterFailed = 5,
	}
	
	/// <summary>
	/// Contains information about a computer account in a directory.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Computer
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string ComputerId { get; set; }
		
		/// <summary>
		/// Max length: 15
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(15, MinimumLength=1)]
		public string ComputerName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Attribute[] ComputerAttributes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ReplicationScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Domain = 0,
	}
	
	/// <summary>
	/// Points to a remote domain with which you are setting up a trust relationship. Conditional forwarders are required in order to set up a trust relationship with another domain.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ConditionalForwarder
	{
		
		/// <summary>
		/// Pattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+[.]?$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RemoteDomainName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IpAddr[] DnsIpAddrs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConditionalForwarderReplicationScope ReplicationScope { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ConditionalForwarderReplicationScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Domain = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectorySize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Small = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Large = 1,
	}
	
	/// <summary>
	/// Contains information for the <a>ConnectDirectory</a> operation when an AD Connector directory is being created.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DirectoryConnectSettings
	{
		
		/// <summary>
		/// Pattern: ^(vpc-[0-9a-f]{8}|vpc-[0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SubnetId[] SubnetIds { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public IpAddr[] CustomerDnsIps { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9._-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string CustomerUserName { get; set; }
	}
	
	/// <summary>
	/// Contains VPC information for the <a>CreateDirectory</a> or <a>CreateMicrosoftAD</a> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DirectoryVpcSettings
	{
		
		/// <summary>
		/// Pattern: ^(vpc-[0-9a-f]{8}|vpc-[0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SubnetId[] SubnetIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectoryEdition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enterprise = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TrustDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		One-Way: Outgoing = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		One-Way: Incoming = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Two-Way = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TrustType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Forest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		External = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SelectiveAuth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum LDAPSType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Client = 0,
	}
	
	/// <summary>
	/// Contains information about an AD Connector directory.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DirectoryConnectSettingsDescription
	{
		
		/// <summary>
		/// Pattern: ^(vpc-[0-9a-f]{8}|vpc-[0-9a-f]{17})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SubnetId[] SubnetIds { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9._-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string CustomerUserName { get; set; }
		
		/// <summary>
		/// Pattern: ^(sg-[0-9a-f]{8}|sg-[0-9a-f]{17})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SecurityGroupId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AvailabilityZone[] AvailabilityZones { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IpAddr[] ConnectIps { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectoryStage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Requested = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Created = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Inoperable = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Impaired = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Restoring = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RestoreFailed = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ShareStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Shared = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PendingAcceptance = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Rejected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Rejecting = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RejectFailed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Sharing = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ShareFailed = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ShareMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATIONS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HANDSHAKE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectoryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SimpleAD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADConnector = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MicrosoftAD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SharedMicrosoftAD = 3,
	}
	
	/// <summary>
	/// Contains information about the directory.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DirectoryVpcSettingsDescription
	{
		
		/// <summary>
		/// Pattern: ^(vpc-[0-9a-f]{8}|vpc-[0-9a-f]{17})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SubnetId[] SubnetIds { get; set; }
		
		/// <summary>
		/// Pattern: ^(sg-[0-9a-f]{8}|sg-[0-9a-f]{17})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SecurityGroupId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AvailabilityZone[] AvailabilityZones { get; set; }
	}
	
	/// <summary>
	/// Contains information about a Remote Authentication Dial In User Service (RADIUS) server.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RadiusSettings
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Server[] RadiusServers { get; set; }
		
		/// <summary>
		/// Minimum: 1025
		/// Maximum: 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1025, 65535)]
		public System.Nullable<System.Int32> RadiusPort { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 20
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 20)]
		public System.Nullable<System.Int32> RadiusTimeout { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// Maximum: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, 10)]
		public System.Nullable<System.Int32> RadiusRetries { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 8
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=8)]
		public string SharedSecret { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RadiusSettingsAuthenticationProtocol AuthenticationProtocol { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string DisplayLabel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UseSameUsername { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RadiusSettingsAuthenticationProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHAP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MS-CHAPv1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MS-CHAPv2 = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RadiusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Completed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 2,
	}
	
	/// <summary>
	/// Describes the directory owner account details that have been shared to the directory consumer account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class OwnerDirectoryDescription
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^(\d{12})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AccountId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IpAddr[] DnsIpAddrs { get; set; }
		
		/// <summary>
		/// Contains information about the directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DirectoryVpcSettingsDescription VpcSettings { get; set; }
		
		/// <summary>
		/// Contains information about a Remote Authentication Dial In User Service (RADIUS) server.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RadiusSettings RadiusSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OwnerDirectoryDescriptionRadiusStatus RadiusStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum OwnerDirectoryDescriptionRadiusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Completed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 2,
	}
	
	/// <summary>
	/// Contains information about an AWS Directory Service directory.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DirectoryDescription
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Pattern: ^[^\\/:*?\"\<\>|.]+[^\\/:*?\"<>|]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ShortName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DirectoryDescriptionSize Size { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DirectoryDescriptionEdition Edition { get; set; }
		
		/// <summary>
		/// Max length: 62
		/// Min length: 1
		/// Pattern: ^(?!d-)([\da-zA-Z]+)([-]*[\da-zA-Z])*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(62, MinimumLength=1)]
		public string Alias { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string AccessUrl { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: ^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IpAddr[] DnsIpAddrs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DirectoryDescriptionStage Stage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DirectoryDescriptionShareStatus ShareStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DirectoryDescriptionShareMethod ShareMethod { get; set; }
		
		/// <summary>
		/// Max length: 1024
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024)]
		public string ShareNotes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LaunchTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StageLastUpdatedDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DirectoryDescriptionType Type { get; set; }
		
		/// <summary>
		/// Contains information about the directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DirectoryVpcSettingsDescription VpcSettings { get; set; }
		
		/// <summary>
		/// Contains information about an AD Connector directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DirectoryConnectSettingsDescription ConnectSettings { get; set; }
		
		/// <summary>
		/// Contains information about a Remote Authentication Dial In User Service (RADIUS) server.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RadiusSettings RadiusSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DirectoryDescriptionRadiusStatus RadiusStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StageReason { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SsoEnabled { get; set; }
		
		/// <summary>
		/// Minimum: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> DesiredNumberOfDomainControllers { get; set; }
		
		/// <summary>
		/// Describes the directory owner account details that have been shared to the directory consumer account.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public OwnerDirectoryDescription OwnerDirectoryDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectoryDescriptionSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Small = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Large = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectoryDescriptionEdition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enterprise = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectoryDescriptionStage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Requested = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Created = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Inoperable = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Impaired = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Restoring = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RestoreFailed = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectoryDescriptionShareStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Shared = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PendingAcceptance = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Rejected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Rejecting = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RejectFailed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Sharing = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ShareFailed = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectoryDescriptionShareMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATIONS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HANDSHAKE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectoryDescriptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SimpleAD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADConnector = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MicrosoftAD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SharedMicrosoftAD = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DirectoryDescriptionRadiusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Completed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 2,
	}
	
	/// <summary>
	/// Contains directory limit information for a Region.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DirectoryLimits
	{
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CloudOnlyDirectoriesLimit { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CloudOnlyDirectoriesCurrentCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CloudOnlyDirectoriesLimitReached { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CloudOnlyMicrosoftADLimit { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CloudOnlyMicrosoftADCurrentCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CloudOnlyMicrosoftADLimitReached { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> ConnectedDirectoriesLimit { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> ConnectedDirectoriesCurrentCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ConnectedDirectoriesLimitReached { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DomainControllerStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Impaired = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Restoring = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 6,
	}
	
	/// <summary>
	/// Contains information about the domain controllers for a specified directory.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DomainController
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^dc-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DomainControllerId { get; set; }
		
		/// <summary>
		/// Pattern: ^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DnsIpAddr { get; set; }
		
		/// <summary>
		/// Pattern: ^(vpc-[0-9a-f]{8}|vpc-[0-9a-f]{17})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
		
		/// <summary>
		/// Pattern: ^(subnet-[0-9a-f]{8}|subnet-[0-9a-f]{17})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SubnetId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AvailabilityZone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DomainControllerStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StatusReason { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LaunchTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StatusLastUpdatedDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DomainControllerStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Impaired = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Restoring = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TopicStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Registered = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Topic not found = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 3,
	}
	
	/// <summary>
	/// Information about SNS topic and AWS Directory Service directory associations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EventTopic
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9_-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string TopicName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TopicArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreatedDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EventTopicStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum EventTopicStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Registered = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Topic not found = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 3,
	}
	
	/// <summary>
	/// Contains manual snapshot limit information for a directory.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SnapshotLimits
	{
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> ManualSnapshotsLimit { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> ManualSnapshotsCurrentCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ManualSnapshotsLimitReached { get; set; }
	}
	
	/// <summary>
	/// IP address block. This is often the address block of the DNS server used for your on-premises domain. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IpRoute
	{
		
		/// <summary>
		/// Pattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([1-9]|[1-2][0-9]|3[0-2]))$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CidrIp { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: ^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum IpRouteStatusMsg
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Adding = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Added = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Removing = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Removed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AddFailed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RemoveFailed = 5,
	}
	
	/// <summary>
	/// Information about one or more IP address blocks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IpRouteInfo
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([1-9]|[1-2][0-9]|3[0-2]))$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CidrIp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IpRouteInfoIpRouteStatusMsg IpRouteStatusMsg { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> AddedDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IpRouteStatusReason { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: ^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum IpRouteInfoIpRouteStatusMsg
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Adding = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Added = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Removing = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Removed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AddFailed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RemoveFailed = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum LDAPSStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabling = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EnableFailed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 3,
	}
	
	/// <summary>
	/// Contains general information about the LDAPS settings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class LDAPSSettingInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LDAPSSettingInfoLDAPSStatus LDAPSStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LDAPSStatusReason { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastUpdatedDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum LDAPSSettingInfoLDAPSStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabling = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EnableFailed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 3,
	}
	
	/// <summary>
	/// Represents a log subscription, which tracks real-time data from a chosen log group to a specified destination.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class LogSubscription
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [-._/#A-Za-z0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> SubscriptionCreatedDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RadiusAuthenticationProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHAP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MS-CHAPv1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MS-CHAPv2 = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SchemaExtensionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Initializing = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CreatingSnapshot = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpdatingSchema = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Replicating = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CancelInProgress = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RollbackInProgress = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cancelled = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Completed = 8,
	}
	
	/// <summary>
	/// Information about a schema extension.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SchemaExtensionInfo
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^e-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SchemaExtensionId { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: ^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SchemaExtensionInfoSchemaExtensionStatus SchemaExtensionStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SchemaExtensionStatusReason { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EndDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SchemaExtensionInfoSchemaExtensionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Initializing = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CreatingSnapshot = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpdatingSchema = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Replicating = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CancelInProgress = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RollbackInProgress = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cancelled = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Completed = 8,
	}
	
	/// <summary>
	/// Identifier that contains details about the directory consumer account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ShareTarget
	{
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string Id { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ShareTargetType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ShareTargetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCOUNT = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TargetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCOUNT = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SnapshotType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Auto = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Manual = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SnapshotStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Completed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 2,
	}
	
	/// <summary>
	/// Describes a directory snapshot.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Snapshot
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^s-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SnapshotId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SnapshotType Type { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: ^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SnapshotStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SnapshotType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Auto = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Manual = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SnapshotStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Completed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 2,
	}
	
	/// <summary>
	/// Metadata assigned to a directory consisting of a key-value pair.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Tag
	{
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: ^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string Key { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 0
		/// Pattern: ^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=0)]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TrustState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Created = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Verifying = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VerifyFailed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Verified = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updating = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpdateFailed = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updated = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 10,
	}
	
	/// <summary>
	/// Describes a trust relationship between an AWS Managed Microsoft AD directory and an external domain.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Trust
	{
		
		/// <summary>
		/// Pattern: ^d-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		/// <summary>
		/// Pattern: ^t-[0-9a-f]{10}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TrustId { get; set; }
		
		/// <summary>
		/// Pattern: ^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+[.]?$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RemoteDomainName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TrustTrustType TrustType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TrustTrustDirection TrustDirection { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TrustTrustState TrustState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreatedDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastUpdatedDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StateLastUpdatedDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TrustStateReason { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TrustSelectiveAuth SelectiveAuth { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TrustTrustType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Forest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		External = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TrustTrustDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		One-Way: Outgoing = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		One-Way: Incoming = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Two-Way = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TrustTrustState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Created = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Verifying = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VerifyFailed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Verified = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updating = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpdateFailed = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updated = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TrustSelectiveAuth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
	}
	
	/// <summary>
	/// Identifier that contains details about the directory consumer account with whom the directory is being unshared.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UnshareTarget
	{
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string Id { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UnshareTargetType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UnshareTargetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCOUNT = 0,
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Accepts a directory sharing request that was sent from the directory owner account.
		/// AcceptSharedDirectory /#X-Amz-Target=DirectoryService_20150416.AcceptSharedDirectory
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AcceptSharedDirectoryResult> AcceptSharedDirectoryAsync(AcceptSharedDirectoryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.AcceptSharedDirectory";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AcceptSharedDirectoryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>If the DNS server for your on-premises domain uses a publicly addressable IP address, you must add a CIDR address block to correctly route traffic to and from your Microsoft AD on Amazon Web Services. <i>AddIpRoutes</i> adds this address block. You can also use <i>AddIpRoutes</i> to facilitate routing traffic that uses public IP ranges from your Microsoft AD on AWS to a peer VPC. </p> <p>Before you call <i>AddIpRoutes</i>, ensure that all of the required permissions have been explicitly granted through a policy. For details about what permissions are required to run the <i>AddIpRoutes</i> operation, see <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/UsingWithDS_IAM_ResourcePermissions.html">AWS Directory Service API Permissions: Actions, Resources, and Conditions Reference</a>.</p>
		/// AddIpRoutes /#X-Amz-Target=DirectoryService_20150416.AddIpRoutes
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AddIpRoutesResult> AddIpRoutesAsync(AddIpRoutesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.AddIpRoutes";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AddIpRoutesResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds or overwrites one or more tags for the specified directory. Each directory can have a maximum of 50 tags. Each tag consists of a key and optional value. Tag keys must be unique to each resource.
		/// AddTagsToResource /#X-Amz-Target=DirectoryService_20150416.AddTagsToResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AddTagsToResourceResult> AddTagsToResourceAsync(AddTagsToResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.AddTagsToResource";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<AddTagsToResourceResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Cancels an in-progress schema extension to a Microsoft AD directory. Once a schema extension has started replicating to all domain controllers, the task can no longer be canceled. A schema extension can be canceled during any of the following states; <code>Initializing</code>, <code>CreatingSnapshot</code>, and <code>UpdatingSchema</code>.
		/// CancelSchemaExtension /#X-Amz-Target=DirectoryService_20150416.CancelSchemaExtension
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CancelSchemaExtensionResult> CancelSchemaExtensionAsync(CancelSchemaExtensionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.CancelSchemaExtension";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CancelSchemaExtensionResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates an AD Connector to connect to an on-premises directory.</p> <p>Before you call <code>ConnectDirectory</code>, ensure that all of the required permissions have been explicitly granted through a policy. For details about what permissions are required to run the <code>ConnectDirectory</code> operation, see <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/UsingWithDS_IAM_ResourcePermissions.html">AWS Directory Service API Permissions: Actions, Resources, and Conditions Reference</a>.</p>
		/// ConnectDirectory /#X-Amz-Target=DirectoryService_20150416.ConnectDirectory
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ConnectDirectoryResult> ConnectDirectoryAsync(ConnectDirectoryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.ConnectDirectory";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ConnectDirectoryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates an alias for a directory and assigns the alias to the directory. The alias is used to construct the access URL for the directory, such as <code>http://&lt;alias&gt;.awsapps.com</code>.</p> <important> <p>After an alias has been created, it cannot be deleted or reused, so this operation should only be used when absolutely necessary.</p> </important>
		/// CreateAlias /#X-Amz-Target=DirectoryService_20150416.CreateAlias
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateAliasResult> CreateAliasAsync(CreateAliasRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.CreateAlias";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateAliasResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a computer account in the specified directory, and joins the computer to the directory.
		/// CreateComputer /#X-Amz-Target=DirectoryService_20150416.CreateComputer
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateComputerResult> CreateComputerAsync(CreateComputerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.CreateComputer";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateComputerResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a conditional forwarder associated with your AWS directory. Conditional forwarders are required in order to set up a trust relationship with another domain. The conditional forwarder points to the trusted domain.
		/// CreateConditionalForwarder /#X-Amz-Target=DirectoryService_20150416.CreateConditionalForwarder
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateConditionalForwarderResult> CreateConditionalForwarderAsync(CreateConditionalForwarderRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.CreateConditionalForwarder";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateConditionalForwarderResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a Simple AD directory. For more information, see <a href="https://docs.aws.amazon.com/directoryservice/latest/admin-guide/directory_simple_ad.html">Simple Active Directory</a> in the <i>AWS Directory Service Admin Guide</i>.</p> <p>Before you call <code>CreateDirectory</code>, ensure that all of the required permissions have been explicitly granted through a policy. For details about what permissions are required to run the <code>CreateDirectory</code> operation, see <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/UsingWithDS_IAM_ResourcePermissions.html">AWS Directory Service API Permissions: Actions, Resources, and Conditions Reference</a>.</p>
		/// CreateDirectory /#X-Amz-Target=DirectoryService_20150416.CreateDirectory
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateDirectoryResult> CreateDirectoryAsync(CreateDirectoryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.CreateDirectory";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateDirectoryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a subscription to forward real-time Directory Service domain controller security logs to the specified Amazon CloudWatch log group in your AWS account.
		/// CreateLogSubscription /#X-Amz-Target=DirectoryService_20150416.CreateLogSubscription
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateLogSubscriptionResult> CreateLogSubscriptionAsync(CreateLogSubscriptionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.CreateLogSubscription";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateLogSubscriptionResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a Microsoft AD directory in the AWS Cloud. For more information, see <a href="https://docs.aws.amazon.com/directoryservice/latest/admin-guide/directory_microsoft_ad.html">AWS Managed Microsoft AD</a> in the <i>AWS Directory Service Admin Guide</i>.</p> <p>Before you call <i>CreateMicrosoftAD</i>, ensure that all of the required permissions have been explicitly granted through a policy. For details about what permissions are required to run the <i>CreateMicrosoftAD</i> operation, see <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/UsingWithDS_IAM_ResourcePermissions.html">AWS Directory Service API Permissions: Actions, Resources, and Conditions Reference</a>.</p>
		/// CreateMicrosoftAD /#X-Amz-Target=DirectoryService_20150416.CreateMicrosoftAD
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateMicrosoftADResult> CreateMicrosoftADAsync(CreateMicrosoftADRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.CreateMicrosoftAD";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateMicrosoftADResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a snapshot of a Simple AD or Microsoft AD directory in the AWS cloud.</p> <note> <p>You cannot take snapshots of AD Connector directories.</p> </note>
		/// CreateSnapshot /#X-Amz-Target=DirectoryService_20150416.CreateSnapshot
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateSnapshotResult> CreateSnapshotAsync(CreateSnapshotRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.CreateSnapshot";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateSnapshotResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>AWS Directory Service for Microsoft Active Directory allows you to configure trust relationships. For example, you can establish a trust between your AWS Managed Microsoft AD directory, and your existing on-premises Microsoft Active Directory. This would allow you to provide users and groups access to resources in either domain, with a single set of credentials.</p> <p>This action initiates the creation of the AWS side of a trust relationship between an AWS Managed Microsoft AD directory and an external domain. You can create either a forest trust or an external trust.</p>
		/// CreateTrust /#X-Amz-Target=DirectoryService_20150416.CreateTrust
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateTrustResult> CreateTrustAsync(CreateTrustRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.CreateTrust";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateTrustResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a conditional forwarder that has been set up for your AWS directory.
		/// DeleteConditionalForwarder /#X-Amz-Target=DirectoryService_20150416.DeleteConditionalForwarder
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteConditionalForwarderResult> DeleteConditionalForwarderAsync(DeleteConditionalForwarderRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DeleteConditionalForwarder";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteConditionalForwarderResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes an AWS Directory Service directory.</p> <p>Before you call <code>DeleteDirectory</code>, ensure that all of the required permissions have been explicitly granted through a policy. For details about what permissions are required to run the <code>DeleteDirectory</code> operation, see <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/UsingWithDS_IAM_ResourcePermissions.html">AWS Directory Service API Permissions: Actions, Resources, and Conditions Reference</a>.</p>
		/// DeleteDirectory /#X-Amz-Target=DirectoryService_20150416.DeleteDirectory
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteDirectoryResult> DeleteDirectoryAsync(DeleteDirectoryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DeleteDirectory";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteDirectoryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified log subscription.
		/// DeleteLogSubscription /#X-Amz-Target=DirectoryService_20150416.DeleteLogSubscription
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteLogSubscriptionResult> DeleteLogSubscriptionAsync(DeleteLogSubscriptionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DeleteLogSubscription";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteLogSubscriptionResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a directory snapshot.
		/// DeleteSnapshot /#X-Amz-Target=DirectoryService_20150416.DeleteSnapshot
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteSnapshotResult> DeleteSnapshotAsync(DeleteSnapshotRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DeleteSnapshot";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteSnapshotResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing trust relationship between your AWS Managed Microsoft AD directory and an external domain.
		/// DeleteTrust /#X-Amz-Target=DirectoryService_20150416.DeleteTrust
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteTrustResult> DeleteTrustAsync(DeleteTrustRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DeleteTrust";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteTrustResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes from the system the certificate that was registered for a secured LDAP connection.
		/// DeregisterCertificate /#X-Amz-Target=DirectoryService_20150416.DeregisterCertificate
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeregisterCertificateResult> DeregisterCertificateAsync(DeregisterCertificateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DeregisterCertificate";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeregisterCertificateResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes the specified directory as a publisher to the specified SNS topic.
		/// DeregisterEventTopic /#X-Amz-Target=DirectoryService_20150416.DeregisterEventTopic
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeregisterEventTopicResult> DeregisterEventTopicAsync(DeregisterEventTopicRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DeregisterEventTopic";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeregisterEventTopicResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Displays information about the certificate registered for a secured LDAP connection.
		/// DescribeCertificate /#X-Amz-Target=DirectoryService_20150416.DescribeCertificate
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeCertificateResult> DescribeCertificateAsync(DescribeCertificateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DescribeCertificate";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeCertificateResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Obtains information about the conditional forwarders for this account.</p> <p>If no input parameters are provided for RemoteDomainNames, this request describes all conditional forwarders for the specified directory ID.</p>
		/// DescribeConditionalForwarders /#X-Amz-Target=DirectoryService_20150416.DescribeConditionalForwarders
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeConditionalForwardersResult> DescribeConditionalForwardersAsync(DescribeConditionalForwardersRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DescribeConditionalForwarders";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeConditionalForwardersResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Obtains information about the directories that belong to this account.</p> <p>You can retrieve information about specific directories by passing the directory identifiers in the <code>DirectoryIds</code> parameter. Otherwise, all directories that belong to the current account are returned.</p> <p>This operation supports pagination with the use of the <code>NextToken</code> request and response parameters. If more results are available, the <code>DescribeDirectoriesResult.NextToken</code> member contains a token that you pass in the next call to <a>DescribeDirectories</a> to retrieve the next set of items.</p> <p>You can also specify a maximum number of return results with the <code>Limit</code> parameter.</p>
		/// DescribeDirectories /#X-Amz-Target=DirectoryService_20150416.DescribeDirectories
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeDirectoriesResult> DescribeDirectoriesAsync(DescribeDirectoriesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DescribeDirectories";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeDirectoriesResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Provides information about any domain controllers in your directory.
		/// DescribeDomainControllers /#X-Amz-Target=DirectoryService_20150416.DescribeDomainControllers
		/// </summary>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeDomainControllersResult> DescribeDomainControllersAsync(string Limit, string NextToken, DescribeDomainControllersRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DescribeDomainControllers?Limit=" + (Limit==null? "" : Uri.EscapeDataString(Limit))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeDomainControllersResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Obtains information about which SNS topics receive status messages from the specified directory.</p> <p>If no input parameters are provided, such as DirectoryId or TopicName, this request describes all of the associations in the account.</p>
		/// DescribeEventTopics /#X-Amz-Target=DirectoryService_20150416.DescribeEventTopics
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeEventTopicsResult> DescribeEventTopicsAsync(DescribeEventTopicsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DescribeEventTopics";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeEventTopicsResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Describes the status of LDAP security for the specified directory.
		/// DescribeLDAPSSettings /#X-Amz-Target=DirectoryService_20150416.DescribeLDAPSSettings
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeLDAPSSettingsResult> DescribeLDAPSSettingsAsync(DescribeLDAPSSettingsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DescribeLDAPSSettings";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeLDAPSSettingsResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the shared directories in your account.
		/// DescribeSharedDirectories /#X-Amz-Target=DirectoryService_20150416.DescribeSharedDirectories
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeSharedDirectoriesResult> DescribeSharedDirectoriesAsync(DescribeSharedDirectoriesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DescribeSharedDirectories";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeSharedDirectoriesResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Obtains information about the directory snapshots that belong to this account.</p> <p>This operation supports pagination with the use of the <i>NextToken</i> request and response parameters. If more results are available, the <i>DescribeSnapshots.NextToken</i> member contains a token that you pass in the next call to <a>DescribeSnapshots</a> to retrieve the next set of items.</p> <p>You can also specify a maximum number of return results with the <i>Limit</i> parameter.</p>
		/// DescribeSnapshots /#X-Amz-Target=DirectoryService_20150416.DescribeSnapshots
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeSnapshotsResult> DescribeSnapshotsAsync(DescribeSnapshotsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DescribeSnapshots";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeSnapshotsResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Obtains information about the trust relationships for this account.</p> <p>If no input parameters are provided, such as DirectoryId or TrustIds, this request describes all the trust relationships belonging to the account.</p>
		/// DescribeTrusts /#X-Amz-Target=DirectoryService_20150416.DescribeTrusts
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeTrustsResult> DescribeTrustsAsync(DescribeTrustsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DescribeTrusts";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeTrustsResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deactivates LDAP secure calls for the specified directory.
		/// DisableLDAPS /#X-Amz-Target=DirectoryService_20150416.DisableLDAPS
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DisableLDAPSResult> DisableLDAPSAsync(DisableLDAPSRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DisableLDAPS";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DisableLDAPSResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Disables multi-factor authentication (MFA) with the Remote Authentication Dial In User Service (RADIUS) server for an AD Connector or Microsoft AD directory.
		/// DisableRadius /#X-Amz-Target=DirectoryService_20150416.DisableRadius
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DisableRadiusResult> DisableRadiusAsync(DisableRadiusRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DisableRadius";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DisableRadiusResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Disables single-sign on for a directory.
		/// DisableSso /#X-Amz-Target=DirectoryService_20150416.DisableSso
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DisableSsoResult> DisableSsoAsync(DisableSsoRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.DisableSso";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DisableSsoResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Activates the switch for the specific directory to always use LDAP secure calls.
		/// EnableLDAPS /#X-Amz-Target=DirectoryService_20150416.EnableLDAPS
		/// </summary>
		/// <returns>Success</returns>
		public async Task<EnableLDAPSResult> EnableLDAPSAsync(EnableLDAPSRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.EnableLDAPS";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<EnableLDAPSResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Enables multi-factor authentication (MFA) with the Remote Authentication Dial In User Service (RADIUS) server for an AD Connector or Microsoft AD directory.
		/// EnableRadius /#X-Amz-Target=DirectoryService_20150416.EnableRadius
		/// </summary>
		/// <returns>Success</returns>
		public async Task<EnableRadiusResult> EnableRadiusAsync(EnableRadiusRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.EnableRadius";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<EnableRadiusResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Enables single sign-on for a directory. Single sign-on allows users in your directory to access certain AWS services from a computer joined to the directory without having to enter their credentials separately.
		/// EnableSso /#X-Amz-Target=DirectoryService_20150416.EnableSso
		/// </summary>
		/// <returns>Success</returns>
		public async Task<EnableSsoResult> EnableSsoAsync(EnableSsoRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.EnableSso";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<EnableSsoResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Obtains directory limit information for the current Region.
		/// GetDirectoryLimits /#X-Amz-Target=DirectoryService_20150416.GetDirectoryLimits
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetDirectoryLimitsResult> GetDirectoryLimitsAsync(GetDirectoryLimitsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.GetDirectoryLimits";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetDirectoryLimitsResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Obtains the manual snapshot limits for a directory.
		/// GetSnapshotLimits /#X-Amz-Target=DirectoryService_20150416.GetSnapshotLimits
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetSnapshotLimitsResult> GetSnapshotLimitsAsync(GetSnapshotLimitsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.GetSnapshotLimits";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetSnapshotLimitsResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// For the specified directory, lists all the certificates registered for a secured LDAP connection.
		/// ListCertificates /#X-Amz-Target=DirectoryService_20150416.ListCertificates
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListCertificatesResult> ListCertificatesAsync(ListCertificatesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.ListCertificates";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListCertificatesResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the address blocks that you have added to a directory.
		/// ListIpRoutes /#X-Amz-Target=DirectoryService_20150416.ListIpRoutes
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListIpRoutesResult> ListIpRoutesAsync(ListIpRoutesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.ListIpRoutes";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListIpRoutesResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the active log subscriptions for the AWS account.
		/// ListLogSubscriptions /#X-Amz-Target=DirectoryService_20150416.ListLogSubscriptions
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListLogSubscriptionsResult> ListLogSubscriptionsAsync(ListLogSubscriptionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.ListLogSubscriptions";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListLogSubscriptionsResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all schema extensions applied to a Microsoft AD Directory.
		/// ListSchemaExtensions /#X-Amz-Target=DirectoryService_20150416.ListSchemaExtensions
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListSchemaExtensionsResult> ListSchemaExtensionsAsync(ListSchemaExtensionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.ListSchemaExtensions";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListSchemaExtensionsResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all tags on a directory.
		/// ListTagsForResource /#X-Amz-Target=DirectoryService_20150416.ListTagsForResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResult> ListTagsForResourceAsync(ListTagsForResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.ListTagsForResource";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListTagsForResourceResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Registers a certificate for secured LDAP connection.
		/// RegisterCertificate /#X-Amz-Target=DirectoryService_20150416.RegisterCertificate
		/// </summary>
		/// <returns>Success</returns>
		public async Task<RegisterCertificateResult> RegisterCertificateAsync(RegisterCertificateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.RegisterCertificate";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RegisterCertificateResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Associates a directory with an SNS topic. This establishes the directory as a publisher to the specified SNS topic. You can then receive email or text (SMS) messages when the status of your directory changes. You get notified if your directory goes from an Active status to an Impaired or Inoperable status. You also receive a notification when the directory returns to an Active status.
		/// RegisterEventTopic /#X-Amz-Target=DirectoryService_20150416.RegisterEventTopic
		/// </summary>
		/// <returns>Success</returns>
		public async Task<RegisterEventTopicResult> RegisterEventTopicAsync(RegisterEventTopicRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.RegisterEventTopic";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RegisterEventTopicResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Rejects a directory sharing request that was sent from the directory owner account.
		/// RejectSharedDirectory /#X-Amz-Target=DirectoryService_20150416.RejectSharedDirectory
		/// </summary>
		/// <returns>Success</returns>
		public async Task<RejectSharedDirectoryResult> RejectSharedDirectoryAsync(RejectSharedDirectoryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.RejectSharedDirectory";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RejectSharedDirectoryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes IP address blocks from a directory.
		/// RemoveIpRoutes /#X-Amz-Target=DirectoryService_20150416.RemoveIpRoutes
		/// </summary>
		/// <returns>Success</returns>
		public async Task<RemoveIpRoutesResult> RemoveIpRoutesAsync(RemoveIpRoutesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.RemoveIpRoutes";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RemoveIpRoutesResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes tags from a directory.
		/// RemoveTagsFromResource /#X-Amz-Target=DirectoryService_20150416.RemoveTagsFromResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task<RemoveTagsFromResourceResult> RemoveTagsFromResourceAsync(RemoveTagsFromResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.RemoveTagsFromResource";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RemoveTagsFromResourceResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Resets the password for any user in your AWS Managed Microsoft AD or Simple AD directory.</p> <p>You can reset the password for any user in your directory with the following exceptions:</p> <ul> <li> <p>For Simple AD, you cannot reset the password for any user that is a member of either the <b>Domain Admins</b> or <b>Enterprise Admins</b> group except for the administrator user.</p> </li> <li> <p>For AWS Managed Microsoft AD, you can only reset the password for a user that is in an OU based off of the NetBIOS name that you typed when you created your directory. For example, you cannot reset the password for a user in the <b>AWS Reserved</b> OU. For more information about the OU structure for an AWS Managed Microsoft AD directory, see <a href="https://docs.aws.amazon.com/directoryservice/latest/admin-guide/ms_ad_getting_started_what_gets_created.html">What Gets Created</a> in the <i>AWS Directory Service Administration Guide</i>.</p> </li> </ul>
		/// ResetUserPassword /#X-Amz-Target=DirectoryService_20150416.ResetUserPassword
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ResetUserPasswordResult> ResetUserPasswordAsync(ResetUserPasswordRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.ResetUserPassword";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ResetUserPasswordResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Restores a directory using an existing directory snapshot.</p> <p>When you restore a directory from a snapshot, any changes made to the directory after the snapshot date are overwritten.</p> <p>This action returns as soon as the restore operation is initiated. You can monitor the progress of the restore operation by calling the <a>DescribeDirectories</a> operation with the directory identifier. When the <b>DirectoryDescription.Stage</b> value changes to <code>Active</code>, the restore operation is complete.</p>
		/// RestoreFromSnapshot /#X-Amz-Target=DirectoryService_20150416.RestoreFromSnapshot
		/// </summary>
		/// <returns>Success</returns>
		public async Task<RestoreFromSnapshotResult> RestoreFromSnapshotAsync(RestoreFromSnapshotRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.RestoreFromSnapshot";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RestoreFromSnapshotResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Shares a specified directory (<code>DirectoryId</code>) in your AWS account (directory owner) with another AWS account (directory consumer). With this operation you can use your directory from any AWS account and from any Amazon VPC within an AWS Region.</p> <p>When you share your AWS Managed Microsoft AD directory, AWS Directory Service creates a shared directory in the directory consumer account. This shared directory contains the metadata to provide access to the directory within the directory owner account. The shared directory is visible in all VPCs in the directory consumer account.</p> <p>The <code>ShareMethod</code> parameter determines whether the specified directory can be shared between AWS accounts inside the same AWS organization (<code>ORGANIZATIONS</code>). It also determines whether you can share the directory with any other AWS account either inside or outside of the organization (<code>HANDSHAKE</code>).</p> <p>The <code>ShareNotes</code> parameter is only used when <code>HANDSHAKE</code> is called, which sends a directory sharing request to the directory consumer. </p>
		/// ShareDirectory /#X-Amz-Target=DirectoryService_20150416.ShareDirectory
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ShareDirectoryResult> ShareDirectoryAsync(ShareDirectoryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.ShareDirectory";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ShareDirectoryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Applies a schema extension to a Microsoft AD directory.
		/// StartSchemaExtension /#X-Amz-Target=DirectoryService_20150416.StartSchemaExtension
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StartSchemaExtensionResult> StartSchemaExtensionAsync(StartSchemaExtensionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.StartSchemaExtension";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<StartSchemaExtensionResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stops the directory sharing between the directory owner and consumer accounts.
		/// UnshareDirectory /#X-Amz-Target=DirectoryService_20150416.UnshareDirectory
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UnshareDirectoryResult> UnshareDirectoryAsync(UnshareDirectoryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.UnshareDirectory";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UnshareDirectoryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a conditional forwarder that has been set up for your AWS directory.
		/// UpdateConditionalForwarder /#X-Amz-Target=DirectoryService_20150416.UpdateConditionalForwarder
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateConditionalForwarderResult> UpdateConditionalForwarderAsync(UpdateConditionalForwarderRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.UpdateConditionalForwarder";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateConditionalForwarderResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds or removes domain controllers to or from the directory. Based on the difference between current value and new value (provided through this API call), domain controllers will be added or removed. It may take up to 45 minutes for any new domain controllers to become fully active once the requested number of domain controllers is updated. During this time, you cannot make another update request.
		/// UpdateNumberOfDomainControllers /#X-Amz-Target=DirectoryService_20150416.UpdateNumberOfDomainControllers
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateNumberOfDomainControllersResult> UpdateNumberOfDomainControllersAsync(UpdateNumberOfDomainControllersRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.UpdateNumberOfDomainControllers";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateNumberOfDomainControllersResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the Remote Authentication Dial In User Service (RADIUS) server information for an AD Connector or Microsoft AD directory.
		/// UpdateRadius /#X-Amz-Target=DirectoryService_20150416.UpdateRadius
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateRadiusResult> UpdateRadiusAsync(UpdateRadiusRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.UpdateRadius";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateRadiusResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the trust that has been set up between your AWS Managed Microsoft AD directory and an on-premises Active Directory.
		/// UpdateTrust /#X-Amz-Target=DirectoryService_20150416.UpdateTrust
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateTrustResult> UpdateTrustAsync(UpdateTrustRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.UpdateTrust";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateTrustResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>AWS Directory Service for Microsoft Active Directory allows you to configure and verify trust relationships.</p> <p>This action verifies a trust relationship between your AWS Managed Microsoft AD directory and an external domain.</p>
		/// VerifyTrust /#X-Amz-Target=DirectoryService_20150416.VerifyTrust
		/// </summary>
		/// <returns>Success</returns>
		public async Task<VerifyTrustResult> VerifyTrustAsync(VerifyTrustRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=DirectoryService_20150416.VerifyTrust";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<VerifyTrustResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
