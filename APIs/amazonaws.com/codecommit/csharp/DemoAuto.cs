//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AssociateApprovalRuleTemplateWithRepositoryInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchAssociateApprovalRuleTemplateWithRepositoriesOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RepositoryName[] AssociatedRepositoryNames { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BatchAssociateApprovalRuleTemplateWithRepositoriesError[] Errors { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchAssociateApprovalRuleTemplateWithRepositoriesInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RepositoryName[] RepositoryNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchDescribeMergeConflictsOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Conflict[] Conflicts { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BatchDescribeMergeConflictsError[] Errors { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseCommitId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchDescribeMergeConflictsInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BatchDescribeMergeConflictsInputMergeOption MergeOption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxMergeHunks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxConflictFiles { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Path[] FilePaths { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BatchDescribeMergeConflictsInputConflictDetailLevel ConflictDetailLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BatchDescribeMergeConflictsInputConflictResolutionStrategy ConflictResolutionStrategy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum BatchDescribeMergeConflictsInputMergeOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAST_FORWARD_MERGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SQUASH_MERGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREE_WAY_MERGE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum BatchDescribeMergeConflictsInputConflictDetailLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum BatchDescribeMergeConflictsInputConflictResolutionStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RepositoryName[] DisassociatedRepositoryNames { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BatchDisassociateApprovalRuleTemplateFromRepositoriesError[] Errors { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchDisassociateApprovalRuleTemplateFromRepositoriesInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RepositoryName[] RepositoryNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchGetCommitsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Commit[] Commits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BatchGetCommitsError[] Errors { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchGetCommitsInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ObjectId[] CommitIds { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a batch get repositories operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchGetRepositoriesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public RepositoryMetadata[] Repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RepositoryName[] RepositoriesNotFound { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a batch get repositories operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchGetRepositoriesInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RepositoryName[] RepositoryNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateApprovalRuleTemplateOutput
	{
		
		/// <summary>
		/// Returns information about an approval rule template.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleTemplate ApprovalRuleTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateApprovalRuleTemplateInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
		
		/// <summary>
		/// Max length: 3000
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(3000, MinimumLength=1)]
		public string ApprovalRuleTemplateContent { get; set; }
		
		/// <summary>
		/// Max length: 1000
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1000, MinimumLength=0)]
		public string ApprovalRuleTemplateDescription { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a create branch operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateBranchInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string BranchName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateCommitOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TreeId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FileMetadata[] FilesAdded { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FileMetadata[] FilesUpdated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FileMetadata[] FilesDeleted { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateCommitInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string BranchName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AuthorName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> KeepEmptyFolders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PutFileEntry[] PutFiles { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeleteFileEntry[] DeleteFiles { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SetFileModeEntry[] SetFileModes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreatePullRequestOutput
	{
		
		/// <summary>
		/// Returns information about a pull request.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PullRequest PullRequest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreatePullRequestInput
	{
		
		/// <summary>
		/// Max length: 150
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(150)]
		public string Title { get; set; }
		
		/// <summary>
		/// Max length: 10240
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(10240)]
		public string Description { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Target[] Targets { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreatePullRequestApprovalRuleOutput
	{
		
		/// <summary>
		/// Returns information about an approval rule.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRule ApprovalRule { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreatePullRequestApprovalRuleInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleName { get; set; }
		
		/// <summary>
		/// Max length: 3000
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(3000, MinimumLength=1)]
		public string ApprovalRuleContent { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a create repository operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateRepositoryOutput
	{
		
		/// <summary>
		/// Information about a repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RepositoryMetadata RepositoryMetadata { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a create repository operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateRepositoryInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Max length: 1000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1000)]
		public string RepositoryDescription { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TagsMap Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateUnreferencedMergeCommitOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TreeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateUnreferencedMergeCommitInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateUnreferencedMergeCommitInputMergeOption MergeOption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CreateUnreferencedMergeCommitInputConflictDetailLevel ConflictDetailLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CreateUnreferencedMergeCommitInputConflictResolutionStrategy ConflictResolutionStrategy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AuthorName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> KeepEmptyFolders { get; set; }
		
		/// <summary>
		/// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConflictResolution ConflictResolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateUnreferencedMergeCommitInputMergeOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAST_FORWARD_MERGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SQUASH_MERGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREE_WAY_MERGE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateUnreferencedMergeCommitInputConflictDetailLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateUnreferencedMergeCommitInputConflictResolutionStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteApprovalRuleTemplateOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ApprovalRuleTemplateId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteApprovalRuleTemplateInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a delete branch operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteBranchOutput
	{
		
		/// <summary>
		/// Returns information about a branch.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BranchInfo DeletedBranch { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a delete branch operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteBranchInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string BranchName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteCommentContentOutput
	{
		
		/// <summary>
		/// Returns information about a specific comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Comment Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteCommentContentInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CommentId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteFileOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BlobId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TreeId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteFileInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string BranchName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ParentCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> KeepEmptyFolders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeletePullRequestApprovalRuleOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ApprovalRuleId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeletePullRequestApprovalRuleInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleName { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a delete repository operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteRepositoryOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RepositoryId { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a delete repository operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteRepositoryInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeMergeConflictsOutput
	{
		
		/// <summary>
		/// Information about the metadata for a conflict in a merge operation.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConflictMetadata ConflictMetadata { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public MergeHunk[] MergeHunks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseCommitId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeMergeConflictsInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribeMergeConflictsInputMergeOption MergeOption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxMergeHunks { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribeMergeConflictsInputConflictDetailLevel ConflictDetailLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribeMergeConflictsInputConflictResolutionStrategy ConflictResolutionStrategy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeMergeConflictsInputMergeOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAST_FORWARD_MERGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SQUASH_MERGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREE_WAY_MERGE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeMergeConflictsInputConflictDetailLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeMergeConflictsInputConflictResolutionStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribePullRequestEventsOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PullRequestEvent[] PullRequestEvents { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribePullRequestEventsInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribePullRequestEventsInputPullRequestEventType PullRequestEventType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ActorArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribePullRequestEventsInputPullRequestEventType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_STATUS_CHANGED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_SOURCE_REFERENCE_UPDATED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_MERGE_STATE_CHANGED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_CREATED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_UPDATED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_DELETED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_STATE_CHANGED = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DisassociateApprovalRuleTemplateFromRepositoryInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EvaluatePullRequestApprovalRulesOutput
	{
		
		/// <summary>
		/// Returns information about the approval rules applied to a pull request and whether conditions have been met.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Evaluation Evaluation { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EvaluatePullRequestApprovalRulesInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RevisionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetApprovalRuleTemplateOutput
	{
		
		/// <summary>
		/// Returns information about an approval rule template.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleTemplate ApprovalRuleTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetApprovalRuleTemplateInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a get blob operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBlobOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a get blob operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBlobInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BlobId { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a get branch operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBranchOutput
	{
		
		/// <summary>
		/// Returns information about a branch.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BranchInfo Branch { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a get branch operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBranchInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string BranchName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetCommentOutput
	{
		
		/// <summary>
		/// Returns information about a specific comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Comment Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetCommentInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CommentId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetCommentsForComparedCommitOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CommentsForComparedCommit[] CommentsForComparedCommitData { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetCommentsForComparedCommitInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeCommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AfterCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetCommentsForPullRequestOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CommentsForPullRequest[] CommentsForPullRequestData { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetCommentsForPullRequestInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a get commit operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetCommitOutput
	{
		
		/// <summary>
		/// Returns information about a specific commit.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Commit Commit { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a get commit operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetCommitInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetDifferencesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Difference[] Differences { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetDifferencesInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AfterCommitSpecifier { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterPath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetFileOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BlobId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public GetFileOutputFileMode FileMode { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int FileSize { get; set; }
		
		/// <summary>
		/// Max length: 6291456
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(6291456)]
		public string FileContent { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GetFileOutputFileMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetFileInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetFolderOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FolderPath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TreeId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Folder[] SubFolders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public File[] Files { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SymbolicLink[] SymbolicLinks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SubModule[] SubModules { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetFolderInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FolderPath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetMergeCommitOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MergedCommitId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetMergeCommitInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitSpecifier { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GetMergeCommitInputConflictDetailLevel ConflictDetailLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GetMergeCommitInputConflictResolutionStrategy ConflictResolutionStrategy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GetMergeCommitInputConflictDetailLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GetMergeCommitInputConflictResolutionStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetMergeConflictsOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool Mergeable { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseCommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConflictMetadata[] ConflictMetadataList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetMergeConflictsInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public GetMergeConflictsInputMergeOption MergeOption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GetMergeConflictsInputConflictDetailLevel ConflictDetailLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxConflictFiles { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GetMergeConflictsInputConflictResolutionStrategy ConflictResolutionStrategy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GetMergeConflictsInputMergeOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAST_FORWARD_MERGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SQUASH_MERGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREE_WAY_MERGE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GetMergeConflictsInputConflictDetailLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GetMergeConflictsInputConflictResolutionStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetMergeOptionsOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public MergeOptionTypeEnum[] MergeOptions { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BaseCommitId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetMergeOptionsInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitSpecifier { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GetMergeOptionsInputConflictDetailLevel ConflictDetailLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GetMergeOptionsInputConflictResolutionStrategy ConflictResolutionStrategy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GetMergeOptionsInputConflictDetailLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GetMergeOptionsInputConflictResolutionStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetPullRequestOutput
	{
		
		/// <summary>
		/// Returns information about a pull request.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PullRequest PullRequest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetPullRequestInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetPullRequestApprovalStatesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Approval[] Approvals { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetPullRequestApprovalStatesInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RevisionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetPullRequestOverrideStateOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Overridden { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Overrider { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetPullRequestOverrideStateInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RevisionId { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a get repository operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetRepositoryOutput
	{
		
		/// <summary>
		/// Information about a repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RepositoryMetadata RepositoryMetadata { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a get repository operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetRepositoryInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a get repository triggers operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetRepositoryTriggersOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ConfigurationId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RepositoryTrigger[] Triggers { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a get repository triggers operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetRepositoryTriggersInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListApprovalRuleTemplatesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleTemplateName[] ApprovalRuleTemplateNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListApprovalRuleTemplatesInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListAssociatedApprovalRuleTemplatesForRepositoryOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleTemplateName[] ApprovalRuleTemplateNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListAssociatedApprovalRuleTemplatesForRepositoryInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a list branches operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListBranchesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BranchName[] Branches { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a list branches operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListBranchesInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListPullRequestsOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PullRequestId[] PullRequestIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListPullRequestsInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AuthorArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ListPullRequestsInputPullRequestStatus PullRequestStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListPullRequestsInputPullRequestStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOSED = 1,
	}
	
	/// <summary>
	/// Represents the output of a list repositories operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListRepositoriesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public RepositoryNameIdPair[] Repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a list repositories operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListRepositoriesInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ListRepositoriesInputSortBy SortBy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ListRepositoriesInputOrder Order { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListRepositoriesInputSortBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		repositoryName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lastModifiedDate = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListRepositoriesInputOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ascending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		descending = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListRepositoriesForApprovalRuleTemplateOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public RepositoryName[] RepositoryNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListRepositoriesForApprovalRuleTemplateInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsForResourceOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TagsMap Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsForResourceInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergeBranchesByFastForwardOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TreeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergeBranchesByFastForwardInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitSpecifier { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string TargetBranch { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergeBranchesBySquashOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TreeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergeBranchesBySquashInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitSpecifier { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string TargetBranch { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergeBranchesBySquashInputConflictDetailLevel ConflictDetailLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergeBranchesBySquashInputConflictResolutionStrategy ConflictResolutionStrategy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AuthorName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> KeepEmptyFolders { get; set; }
		
		/// <summary>
		/// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConflictResolution ConflictResolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergeBranchesBySquashInputConflictDetailLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergeBranchesBySquashInputConflictResolutionStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergeBranchesByThreeWayOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TreeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergeBranchesByThreeWayInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitSpecifier { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitSpecifier { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string TargetBranch { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergeBranchesByThreeWayInputConflictDetailLevel ConflictDetailLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergeBranchesByThreeWayInputConflictResolutionStrategy ConflictResolutionStrategy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AuthorName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> KeepEmptyFolders { get; set; }
		
		/// <summary>
		/// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConflictResolution ConflictResolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergeBranchesByThreeWayInputConflictDetailLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergeBranchesByThreeWayInputConflictResolutionStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergePullRequestByFastForwardOutput
	{
		
		/// <summary>
		/// Returns information about a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PullRequest PullRequest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergePullRequestByFastForwardInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergePullRequestBySquashOutput
	{
		
		/// <summary>
		/// Returns information about a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PullRequest PullRequest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergePullRequestBySquashInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergePullRequestBySquashInputConflictDetailLevel ConflictDetailLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergePullRequestBySquashInputConflictResolutionStrategy ConflictResolutionStrategy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AuthorName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> KeepEmptyFolders { get; set; }
		
		/// <summary>
		/// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConflictResolution ConflictResolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergePullRequestBySquashInputConflictDetailLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergePullRequestBySquashInputConflictResolutionStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergePullRequestByThreeWayOutput
	{
		
		/// <summary>
		/// Returns information about a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PullRequest PullRequest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergePullRequestByThreeWayInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergePullRequestByThreeWayInputConflictDetailLevel ConflictDetailLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergePullRequestByThreeWayInputConflictResolutionStrategy ConflictResolutionStrategy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AuthorName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> KeepEmptyFolders { get; set; }
		
		/// <summary>
		/// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConflictResolution ConflictResolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergePullRequestByThreeWayInputConflictDetailLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergePullRequestByThreeWayInputConflictResolutionStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class OverridePullRequestApprovalRulesInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RevisionId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public OverridePullRequestApprovalRulesInputOverrideStatus OverrideStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum OverridePullRequestApprovalRulesInputOverrideStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OVERRIDE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVOKE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PostCommentForComparedCommitOutput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeBlobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterBlobId { get; set; }
		
		/// <summary>
		/// Returns information about the location of a change or comment in the comparison between two commits or a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Location Location { get; set; }
		
		/// <summary>
		/// Returns information about a specific comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Comment Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PostCommentForComparedCommitInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeCommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AfterCommitId { get; set; }
		
		/// <summary>
		/// Returns information about the location of a change or comment in the comparison between two commits or a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Location Location { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PostCommentForPullRequestOutput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeBlobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterBlobId { get; set; }
		
		/// <summary>
		/// Returns information about the location of a change or comment in the comparison between two commits or a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Location Location { get; set; }
		
		/// <summary>
		/// Returns information about a specific comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Comment Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PostCommentForPullRequestInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BeforeCommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AfterCommitId { get; set; }
		
		/// <summary>
		/// Returns information about the location of a change or comment in the comparison between two commits or a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Location Location { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PostCommentReplyOutput
	{
		
		/// <summary>
		/// Returns information about a specific comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Comment Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PostCommentReplyInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string InReplyTo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutFileOutput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BlobId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TreeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutFileInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string BranchName { get; set; }
		
		/// <summary>
		/// Max length: 6291456
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(6291456)]
		public string FileContent { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PutFileInputFileMode FileMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PutFileInputFileMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	/// <summary>
	/// Represents the output of a put repository triggers operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutRepositoryTriggersOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ConfigurationId { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a put repository triggers operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutRepositoryTriggersInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RepositoryTrigger[] Triggers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TagsMap Tags { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a test repository triggers operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TestRepositoryTriggersOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public RepositoryTriggerName[] SuccessfulExecutions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RepositoryTriggerExecutionFailure[] FailedExecutions { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a test repository triggers operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TestRepositoryTriggersInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RepositoryTrigger[] Triggers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UntagResourceInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TagKey[] TagKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApprovalRuleTemplateContentOutput
	{
		
		/// <summary>
		/// Returns information about an approval rule template.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleTemplate ApprovalRuleTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApprovalRuleTemplateContentInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
		
		/// <summary>
		/// Max length: 3000
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(3000, MinimumLength=1)]
		public string NewRuleContent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ExistingRuleContentSha256 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApprovalRuleTemplateDescriptionOutput
	{
		
		/// <summary>
		/// Returns information about an approval rule template.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleTemplate ApprovalRuleTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApprovalRuleTemplateDescriptionInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
		
		/// <summary>
		/// Max length: 1000
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1000, MinimumLength=0)]
		public string ApprovalRuleTemplateDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApprovalRuleTemplateNameOutput
	{
		
		/// <summary>
		/// Returns information about an approval rule template.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleTemplate ApprovalRuleTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApprovalRuleTemplateNameInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string OldApprovalRuleTemplateName { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string NewApprovalRuleTemplateName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateCommentOutput
	{
		
		/// <summary>
		/// Returns information about a specific comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Comment Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateCommentInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CommentId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
	}
	
	/// <summary>
	/// Represents the input of an update default branch operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateDefaultBranchInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string DefaultBranchName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdatePullRequestApprovalRuleContentOutput
	{
		
		/// <summary>
		/// Returns information about an approval rule.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRule ApprovalRule { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdatePullRequestApprovalRuleContentInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ExistingRuleContentSha256 { get; set; }
		
		/// <summary>
		/// Max length: 3000
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(3000, MinimumLength=1)]
		public string NewRuleContent { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdatePullRequestApprovalStateInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RevisionId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdatePullRequestApprovalStateInputApprovalState ApprovalState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdatePullRequestApprovalStateInputApprovalState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPROVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVOKE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdatePullRequestDescriptionOutput
	{
		
		/// <summary>
		/// Returns information about a pull request.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PullRequest PullRequest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdatePullRequestDescriptionInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 10240
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(10240)]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdatePullRequestStatusOutput
	{
		
		/// <summary>
		/// Returns information about a pull request.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PullRequest PullRequest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdatePullRequestStatusInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdatePullRequestStatusInputPullRequestStatus PullRequestStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdatePullRequestStatusInputPullRequestStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOSED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdatePullRequestTitleOutput
	{
		
		/// <summary>
		/// Returns information about a pull request.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PullRequest PullRequest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdatePullRequestTitleInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 150
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(150)]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// Represents the input of an update repository description operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateRepositoryDescriptionInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Max length: 1000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1000)]
		public string RepositoryDescription { get; set; }
	}
	
	/// <summary>
	/// Represents the input of an update repository description operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateRepositoryNameInput
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string OldName { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string NewName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ApprovalState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPROVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVOKE = 1,
	}
	
	/// <summary>
	/// Returns information about a specific approval on a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Approval
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string UserArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ApprovalApprovalState ApprovalState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ApprovalApprovalState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPROVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVOKE = 1,
	}
	
	/// <summary>
	/// Returns information about the template that created the approval rule for a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class OriginApprovalRuleTemplate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ApprovalRuleTemplateId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
	}
	
	/// <summary>
	/// Returns information about an approval rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ApprovalRule
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ApprovalRuleId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleName { get; set; }
		
		/// <summary>
		/// Max length: 3000
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(3000, MinimumLength=1)]
		public string ApprovalRuleContent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RuleContentSha256 { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LastModifiedUser { get; set; }
		
		/// <summary>
		/// Returns information about the template that created the approval rule for a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public OriginApprovalRuleTemplate OriginApprovalRuleTemplate { get; set; }
	}
	
	/// <summary>
	/// Returns information about an event for an approval rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ApprovalRuleEventMetadata
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ApprovalRuleId { get; set; }
		
		/// <summary>
		/// Max length: 3000
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(3000, MinimumLength=1)]
		public string ApprovalRuleContent { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum OverrideStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OVERRIDE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVOKE = 1,
	}
	
	/// <summary>
	/// Returns information about an override event for approval rules for a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ApprovalRuleOverriddenEventMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RevisionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleOverriddenEventMetadataOverrideStatus OverrideStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ApprovalRuleOverriddenEventMetadataOverrideStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OVERRIDE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVOKE = 1,
	}
	
	/// <summary>
	/// Returns information about an approval rule template.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ApprovalRuleTemplate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ApprovalRuleTemplateId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string ApprovalRuleTemplateName { get; set; }
		
		/// <summary>
		/// Max length: 1000
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1000, MinimumLength=0)]
		public string ApprovalRuleTemplateDescription { get; set; }
		
		/// <summary>
		/// Max length: 3000
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(3000, MinimumLength=1)]
		public string ApprovalRuleTemplateContent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RuleContentSha256 { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LastModifiedUser { get; set; }
	}
	
	/// <summary>
	/// Returns information about a change in the approval state for a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ApprovalStateChangedEventMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RevisionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ApprovalStateChangedEventMetadataApprovalStatus ApprovalStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ApprovalStateChangedEventMetadataApprovalStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPROVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVOKE = 1,
	}
	
	/// <summary>
	/// Returns information about errors in a BatchAssociateApprovalRuleTemplateWithRepositories operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchAssociateApprovalRuleTemplateWithRepositoriesError
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorMessage { get; set; }
	}
	
	/// <summary>
	/// Returns information about errors in a BatchDescribeMergeConflicts operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchDescribeMergeConflictsError
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExceptionName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergeOptionTypeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAST_FORWARD_MERGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SQUASH_MERGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREE_WAY_MERGE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ConflictDetailLevelTypeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_LEVEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE_LEVEL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ConflictResolutionStrategyTypeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 3,
	}
	
	/// <summary>
	/// Returns information about errors in a BatchDisassociateApprovalRuleTemplateFromRepositories operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchDisassociateApprovalRuleTemplateFromRepositoriesError
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorMessage { get; set; }
	}
	
	/// <summary>
	/// Returns information about errors in a BatchGetCommits operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BatchGetCommitsError
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorMessage { get; set; }
	}
	
	/// <summary>
	/// Returns information about a specific Git blob object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BlobMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BlobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Mode { get; set; }
	}
	
	/// <summary>
	/// Returns information about a branch.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BranchInfo
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string BranchName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ChangeTypeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		A = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		M = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		D = 2,
	}
	
	/// <summary>
	/// Returns information about a specific comment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Comment
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CommentId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string InReplyTo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AuthorArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
	}
	
	/// <summary>
	/// Returns information about the location of a change or comment in the comparison between two commits or a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Location
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> FilePosition { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LocationRelativeFileVersion RelativeFileVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum LocationRelativeFileVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BEFORE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AFTER = 1,
	}
	
	/// <summary>
	/// Returns information about comments on the comparison between two commits.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CommentsForComparedCommit
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeBlobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterBlobId { get; set; }
		
		/// <summary>
		/// Returns information about the location of a change or comment in the comparison between two commits or a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Location Location { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Comment[] Comments { get; set; }
	}
	
	/// <summary>
	/// Returns information about comments on a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CommentsForPullRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeBlobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterBlobId { get; set; }
		
		/// <summary>
		/// Returns information about the location of a change or comment in the comparison between two commits or a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Location Location { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Comment[] Comments { get; set; }
	}
	
	/// <summary>
	/// Information about the user who made a specified commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UserInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Date { get; set; }
	}
	
	/// <summary>
	/// Returns information about a specific commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Commit
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TreeId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ObjectId[] Parents { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
		
		/// <summary>
		/// Information about the user who made a specified commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserInfo Author { get; set; }
		
		/// <summary>
		/// Information about the user who made a specified commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserInfo Committer { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AdditionalData { get; set; }
	}
	
	/// <summary>
	/// Information about the metadata for a conflict in a merge operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ConflictMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		/// <summary>
		/// Information about the size of files in a merge or pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FileSizes FileSizes { get; set; }
		
		/// <summary>
		/// Information about file modes in a merge or pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FileModes FileModes { get; set; }
		
		/// <summary>
		/// Information about the type of an object in a merge operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ObjectTypes ObjectTypes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NumberOfConflicts { get; set; }
		
		/// <summary>
		/// Information about whether a file is binary or textual in a merge or pull request operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public IsBinaryFile IsBinaryFile { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ContentConflict { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> FileModeConflict { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ObjectTypeConflict { get; set; }
		
		/// <summary>
		/// Information about the file operation conflicts in a merge operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MergeOperations MergeOperations { get; set; }
	}
	
	/// <summary>
	/// Information about conflicts in a merge operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Conflict
	{
		
		/// <summary>
		/// Information about the metadata for a conflict in a merge operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConflictMetadata ConflictMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergeHunk[] MergeHunks { get; set; }
	}
	
	/// <summary>
	/// Information about the size of files in a merge or pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FileSizes
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Source { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Destination { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Base { get; set; }
	}
	
	/// <summary>
	/// Information about file modes in a merge or pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FileModes
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FileModesSource Source { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FileModesDestination Destination { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FileModesBase Base { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FileModesSource
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FileModesDestination
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FileModesBase
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	/// <summary>
	/// Information about the type of an object in a merge operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ObjectTypes
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ObjectTypesSource Source { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ObjectTypesDestination Destination { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ObjectTypesBase Base { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ObjectTypesSource
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECTORY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GIT_LINK = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMBOLIC_LINK = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ObjectTypesDestination
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECTORY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GIT_LINK = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMBOLIC_LINK = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ObjectTypesBase
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECTORY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GIT_LINK = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMBOLIC_LINK = 3,
	}
	
	/// <summary>
	/// Information about whether a file is binary or textual in a merge or pull request operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IsBinaryFile
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Source { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Destination { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Base { get; set; }
	}
	
	/// <summary>
	/// Information about the file operation conflicts in a merge operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergeOperations
	{
		
		[System.Runtime.Serialization.DataMember()]
		public MergeOperationsSource Source { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergeOperationsDestination Destination { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergeOperationsSource
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		A = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		M = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		D = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergeOperationsDestination
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		A = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		M = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		D = 2,
	}
	
	/// <summary>
	/// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ConflictResolution
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ReplaceContentEntry[] ReplaceContents { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeleteFileEntry[] DeleteFiles { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SetFileModeEntry[] SetFileModes { get; set; }
	}
	
	/// <summary>
	/// Returns information about a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PullRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Max length: 150
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(150)]
		public string Title { get; set; }
		
		/// <summary>
		/// Max length: 10240
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(10240)]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastActivityDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PullRequestPullRequestStatus PullRequestStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AuthorArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PullRequestTarget[] PullRequestTargets { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RevisionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRule[] ApprovalRules { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PullRequestPullRequestStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOSED = 1,
	}
	
	/// <summary>
	/// Information about a repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RepositoryMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AccountId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RepositoryId { get; set; }
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Max length: 1000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1000)]
		public string RepositoryDescription { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string DefaultBranch { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CloneUrlHttp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CloneUrlSsh { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
	}
	
	/// <summary>
	/// A file that is deleted as part of a commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteFileEntry
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PullRequestEventType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_STATUS_CHANGED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_SOURCE_REFERENCE_UPDATED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_MERGE_STATE_CHANGED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_CREATED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_UPDATED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_DELETED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_STATE_CHANGED = 8,
	}
	
	/// <summary>
	/// Returns information about a set of differences for a commit specifier.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Difference
	{
		
		/// <summary>
		/// Returns information about a specific Git blob object.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BlobMetadata BeforeBlob { get; set; }
		
		/// <summary>
		/// Returns information about a specific Git blob object.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BlobMetadata AfterBlob { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DifferenceChangeType ChangeType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DifferenceChangeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		A = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		M = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		D = 2,
	}
	
	/// <summary>
	/// Returns information about the approval rules applied to a pull request and whether conditions have been met.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Evaluation
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Approved { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Overridden { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleName[] ApprovalRulesSatisfied { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleName[] ApprovalRulesNotSatisfied { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FileModeTypeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	/// <summary>
	/// Returns information about a file in a repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class File
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BlobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AbsolutePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RelativePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FileFileMode FileMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FileFileMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	/// <summary>
	/// A file to be added, updated, or deleted as part of a commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FileMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AbsolutePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BlobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FileMetadataFileMode FileMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FileMetadataFileMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	/// <summary>
	/// Returns information about a folder in a repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Folder
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TreeId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AbsolutePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RelativePath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PullRequestStatusEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOSED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SortByEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		repositoryName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lastModifiedDate = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum OrderEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ascending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		descending = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RelativeFileVersionEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BEFORE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AFTER = 1,
	}
	
	/// <summary>
	/// Information about the details of a merge hunk that contains a conflict in a merge or pull request operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergeHunkDetail
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartLine { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> EndLine { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HunkContent { get; set; }
	}
	
	/// <summary>
	/// Information about merge hunks in a merge or pull request operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergeHunk
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsConflict { get; set; }
		
		/// <summary>
		/// Information about the details of a merge hunk that contains a conflict in a merge or pull request operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MergeHunkDetail Source { get; set; }
		
		/// <summary>
		/// Information about the details of a merge hunk that contains a conflict in a merge or pull request operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MergeHunkDetail Destination { get; set; }
		
		/// <summary>
		/// Information about the details of a merge hunk that contains a conflict in a merge or pull request operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MergeHunkDetail Base { get; set; }
	}
	
	/// <summary>
	/// Returns information about a merge or potential merge between a source reference and a destination reference in a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MergeMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsMerged { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MergedBy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MergeCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MergeMetadataMergeOption MergeOption { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MergeMetadataMergeOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAST_FORWARD_MERGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SQUASH_MERGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREE_WAY_MERGE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ObjectTypeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECTORY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GIT_LINK = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMBOLIC_LINK = 3,
	}
	
	/// <summary>
	/// Metadata about the pull request that is used when comparing the pull request source with its destination.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PullRequestCreatedEventMetadata
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MergeBase { get; set; }
	}
	
	/// <summary>
	/// Information about a change to the status of a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PullRequestStatusChangedEventMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PullRequestStatusChangedEventMetadataPullRequestStatus PullRequestStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PullRequestStatusChangedEventMetadataPullRequestStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOSED = 1,
	}
	
	/// <summary>
	/// Information about an update to the source branch of a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PullRequestSourceReferenceUpdatedEventMetadata
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BeforeCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AfterCommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MergeBase { get; set; }
	}
	
	/// <summary>
	/// Returns information about the change in the merge state for a pull request event. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PullRequestMergedStateChangedEventMetadata
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationReference { get; set; }
		
		/// <summary>
		/// Returns information about a merge or potential merge between a source reference and a destination reference in a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MergeMetadata MergeMetadata { get; set; }
	}
	
	/// <summary>
	/// Returns information about a pull request event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PullRequestEvent
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string PullRequestId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EventDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PullRequestEventPullRequestEventType PullRequestEventType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ActorArn { get; set; }
		
		/// <summary>
		/// Metadata about the pull request that is used when comparing the pull request source with its destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PullRequestCreatedEventMetadata PullRequestCreatedEventMetadata { get; set; }
		
		/// <summary>
		/// Information about a change to the status of a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PullRequestStatusChangedEventMetadata PullRequestStatusChangedEventMetadata { get; set; }
		
		/// <summary>
		/// Information about an update to the source branch of a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PullRequestSourceReferenceUpdatedEventMetadata PullRequestSourceReferenceUpdatedEventMetadata { get; set; }
		
		/// <summary>
		/// Returns information about the change in the merge state for a pull request event. 
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PullRequestMergedStateChangedEventMetadata PullRequestMergedStateChangedEventMetadata { get; set; }
		
		/// <summary>
		/// Returns information about an event for an approval rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleEventMetadata ApprovalRuleEventMetadata { get; set; }
		
		/// <summary>
		/// Returns information about a change in the approval state for a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ApprovalStateChangedEventMetadata ApprovalStateChangedEventMetadata { get; set; }
		
		/// <summary>
		/// Returns information about an override event for approval rules for a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ApprovalRuleOverriddenEventMetadata ApprovalRuleOverriddenEventMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PullRequestEventPullRequestEventType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_STATUS_CHANGED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_SOURCE_REFERENCE_UPDATED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_MERGE_STATE_CHANGED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_CREATED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_UPDATED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_DELETED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PULL_REQUEST_APPROVAL_STATE_CHANGED = 8,
	}
	
	/// <summary>
	/// Returns information about a pull request target.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PullRequestTarget
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceReference { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationReference { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationCommit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceCommit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MergeBase { get; set; }
		
		/// <summary>
		/// Returns information about a merge or potential merge between a source reference and a destination reference in a pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MergeMetadata MergeMetadata { get; set; }
	}
	
	/// <summary>
	/// Information about a file added or updated as part of a commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutFileEntry
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PutFileEntryFileMode FileMode { get; set; }
		
		/// <summary>
		/// Max length: 6291456
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(6291456)]
		public string FileContent { get; set; }
		
		/// <summary>
		/// Information about a source file that is part of changes made in a commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SourceFileSpecifier SourceFile { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PutFileEntryFileMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	/// <summary>
	/// Information about a source file that is part of changes made in a commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SourceFileSpecifier
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsMove { get; set; }
	}
	
	/// <summary>
	/// Information about a replacement content entry in the conflict of a merge or pull request operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ReplaceContentEntry
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ReplaceContentEntryReplacementType ReplacementType { get; set; }
		
		/// <summary>
		/// Max length: 6291456
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(6291456)]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplaceContentEntryFileMode FileMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ReplaceContentEntryReplacementType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KEEP_BASE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KEEP_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KEEP_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USE_NEW_CONTENT = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ReplaceContentEntryFileMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ReplacementTypeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KEEP_BASE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KEEP_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KEEP_DESTINATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USE_NEW_CONTENT = 3,
	}
	
	/// <summary>
	/// Information about a repository name and ID.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RepositoryNameIdPair
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RepositoryId { get; set; }
	}
	
	/// <summary>
	/// Information about a trigger for a repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RepositoryTrigger
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CustomData { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BranchName[] Branches { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RepositoryTriggerEventEnum[] Events { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RepositoryTriggerEventEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updateReference = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		createReference = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleteReference = 3,
	}
	
	/// <summary>
	/// A trigger failed to run.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RepositoryTriggerExecutionFailure
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Trigger { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FailureMessage { get; set; }
	}
	
	/// <summary>
	/// Information about the file mode changes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SetFileModeEntry
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FilePath { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SetFileModeEntryFileMode FileMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SetFileModeEntryFileMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	/// <summary>
	/// Returns information about a submodule reference in a repository folder.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SubModule
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CommitId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AbsolutePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RelativePath { get; set; }
	}
	
	/// <summary>
	/// Returns information about a symbolic link in a repository folder.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SymbolicLink
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BlobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AbsolutePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RelativePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SymbolicLinkFileMode FileMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SymbolicLinkFileMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYMLINK = 2,
	}
	
	/// <summary>
	/// Returns information about a target for a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Target
	{
		
		/// <summary>
		/// Max length: 100
		/// Min length: 1
		/// Pattern: [\w\.-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength=1)]
		public string RepositoryName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceReference { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationReference { get; set; }
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Creates an association between an approval rule template and a specified repository. Then, the next time a pull request is created in the repository where the destination reference (if specified) matches the destination reference (branch) for the pull request, an approval rule that matches the template conditions is automatically created for that pull request. If no destination references are specified in the template, an approval rule that matches the template contents is created for all pull requests in that repository.
		/// AssociateApprovalRuleTemplateWithRepository /#X-Amz-Target=CodeCommit_20150413.AssociateApprovalRuleTemplateWithRepository
		/// </summary>
		/// <returns>Success</returns>
		public async Task AssociateApprovalRuleTemplateWithRepositoryAsync(AssociateApprovalRuleTemplateWithRepositoryInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.AssociateApprovalRuleTemplateWithRepository";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates an association between an approval rule template and one or more specified repositories.
		/// BatchAssociateApprovalRuleTemplateWithRepositories /#X-Amz-Target=CodeCommit_20150413.BatchAssociateApprovalRuleTemplateWithRepositories
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchAssociateApprovalRuleTemplateWithRepositoriesOutput> BatchAssociateApprovalRuleTemplateWithRepositoriesAsync(BatchAssociateApprovalRuleTemplateWithRepositoriesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.BatchAssociateApprovalRuleTemplateWithRepositories";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<BatchAssociateApprovalRuleTemplateWithRepositoriesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about one or more merge conflicts in the attempted merge of two commit specifiers using the squash or three-way merge strategy.
		/// BatchDescribeMergeConflicts /#X-Amz-Target=CodeCommit_20150413.BatchDescribeMergeConflicts
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchDescribeMergeConflictsOutput> BatchDescribeMergeConflictsAsync(BatchDescribeMergeConflictsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.BatchDescribeMergeConflicts";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<BatchDescribeMergeConflictsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes the association between an approval rule template and one or more specified repositories.
		/// BatchDisassociateApprovalRuleTemplateFromRepositories /#X-Amz-Target=CodeCommit_20150413.BatchDisassociateApprovalRuleTemplateFromRepositories
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput> BatchDisassociateApprovalRuleTemplateFromRepositoriesAsync(BatchDisassociateApprovalRuleTemplateFromRepositoriesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.BatchDisassociateApprovalRuleTemplateFromRepositories";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about the contents of one or more commits in a repository.
		/// BatchGetCommits /#X-Amz-Target=CodeCommit_20150413.BatchGetCommits
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchGetCommitsOutput> BatchGetCommitsAsync(BatchGetCommitsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.BatchGetCommits";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<BatchGetCommitsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Returns information about one or more repositories.</p> <note> <p>The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a webpage can expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a webpage.</p> </note>
		/// BatchGetRepositories /#X-Amz-Target=CodeCommit_20150413.BatchGetRepositories
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchGetRepositoriesOutput> BatchGetRepositoriesAsync(BatchGetRepositoriesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.BatchGetRepositories";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<BatchGetRepositoriesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a template for approval rules that can then be associated with one or more repositories in your AWS account. When you associate a template with a repository, AWS CodeCommit creates an approval rule that matches the conditions of the template for all pull requests that meet the conditions of the template. For more information, see <a>AssociateApprovalRuleTemplateWithRepository</a>.
		/// CreateApprovalRuleTemplate /#X-Amz-Target=CodeCommit_20150413.CreateApprovalRuleTemplate
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateApprovalRuleTemplateOutput> CreateApprovalRuleTemplateAsync(CreateApprovalRuleTemplateInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.CreateApprovalRuleTemplate";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateApprovalRuleTemplateOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a branch in a repository and points the branch to a commit.</p> <note> <p>Calling the create branch operation does not set a repository's default branch. To do this, call the update default branch operation.</p> </note>
		/// CreateBranch /#X-Amz-Target=CodeCommit_20150413.CreateBranch
		/// </summary>
		/// <returns>Success</returns>
		public async Task CreateBranchAsync(CreateBranchInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.CreateBranch";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a commit for a repository on the tip of a specified branch.
		/// CreateCommit /#X-Amz-Target=CodeCommit_20150413.CreateCommit
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateCommitOutput> CreateCommitAsync(CreateCommitInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.CreateCommit";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateCommitOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a pull request in the specified repository.
		/// CreatePullRequest /#X-Amz-Target=CodeCommit_20150413.CreatePullRequest
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreatePullRequestOutput> CreatePullRequestAsync(CreatePullRequestInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.CreatePullRequest";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreatePullRequestOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates an approval rule for a pull request.
		/// CreatePullRequestApprovalRule /#X-Amz-Target=CodeCommit_20150413.CreatePullRequestApprovalRule
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreatePullRequestApprovalRuleOutput> CreatePullRequestApprovalRuleAsync(CreatePullRequestApprovalRuleInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.CreatePullRequestApprovalRule";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreatePullRequestApprovalRuleOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a new, empty repository.
		/// CreateRepository /#X-Amz-Target=CodeCommit_20150413.CreateRepository
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateRepositoryOutput> CreateRepositoryAsync(CreateRepositoryInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.CreateRepository";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateRepositoryOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates an unreferenced commit that represents the result of merging two branches using a specified merge strategy. This can help you determine the outcome of a potential merge. This API cannot be used with the fast-forward merge strategy because that strategy does not create a merge commit.</p> <note> <p>This unreferenced merge commit can only be accessed using the GetCommit API or through git commands such as git fetch. To retrieve this commit, you must specify its commit ID or otherwise reference it.</p> </note>
		/// CreateUnreferencedMergeCommit /#X-Amz-Target=CodeCommit_20150413.CreateUnreferencedMergeCommit
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateUnreferencedMergeCommitOutput> CreateUnreferencedMergeCommitAsync(CreateUnreferencedMergeCommitInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.CreateUnreferencedMergeCommit";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateUnreferencedMergeCommitOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a specified approval rule template. Deleting a template does not remove approval rules on pull requests already created with the template.
		/// DeleteApprovalRuleTemplate /#X-Amz-Target=CodeCommit_20150413.DeleteApprovalRuleTemplate
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteApprovalRuleTemplateOutput> DeleteApprovalRuleTemplateAsync(DeleteApprovalRuleTemplateInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.DeleteApprovalRuleTemplate";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteApprovalRuleTemplateOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a branch from a repository, unless that branch is the default branch for the repository.
		/// DeleteBranch /#X-Amz-Target=CodeCommit_20150413.DeleteBranch
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteBranchOutput> DeleteBranchAsync(DeleteBranchInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.DeleteBranch";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteBranchOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the content of a comment made on a change, file, or commit in a repository.
		/// DeleteCommentContent /#X-Amz-Target=CodeCommit_20150413.DeleteCommentContent
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteCommentContentOutput> DeleteCommentContentAsync(DeleteCommentContentInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.DeleteCommentContent";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteCommentContentOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a specified file from a specified branch. A commit is created on the branch that contains the revision. The file still exists in the commits earlier to the commit that contains the deletion.
		/// DeleteFile /#X-Amz-Target=CodeCommit_20150413.DeleteFile
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteFileOutput> DeleteFileAsync(DeleteFileInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.DeleteFile";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteFileOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an approval rule from a specified pull request. Approval rules can be deleted from a pull request only if the pull request is open, and if the approval rule was created specifically for a pull request and not generated from an approval rule template associated with the repository where the pull request was created. You cannot delete an approval rule from a merged or closed pull request.
		/// DeletePullRequestApprovalRule /#X-Amz-Target=CodeCommit_20150413.DeletePullRequestApprovalRule
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeletePullRequestApprovalRuleOutput> DeletePullRequestApprovalRuleAsync(DeletePullRequestApprovalRuleInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.DeletePullRequestApprovalRule";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeletePullRequestApprovalRuleOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a repository. If a specified repository was already deleted, a null repository ID is returned.</p> <important> <p>Deleting a repository also deletes all associated objects and metadata. After a repository is deleted, all future push calls to the deleted repository fail.</p> </important>
		/// DeleteRepository /#X-Amz-Target=CodeCommit_20150413.DeleteRepository
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteRepositoryOutput> DeleteRepositoryAsync(DeleteRepositoryInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.DeleteRepository";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteRepositoryOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about one or more merge conflicts in the attempted merge of two commit specifiers using the squash or three-way merge strategy. If the merge option for the attempted merge is specified as FAST_FORWARD_MERGE, an exception is thrown.
		/// DescribeMergeConflicts /#X-Amz-Target=CodeCommit_20150413.DescribeMergeConflicts
		/// </summary>
		/// <param name="maxMergeHunks">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeMergeConflictsOutput> DescribeMergeConflictsAsync(string maxMergeHunks, string nextToken, DescribeMergeConflictsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.DescribeMergeConflicts?maxMergeHunks=" + (maxMergeHunks==null? "" : Uri.EscapeDataString(maxMergeHunks))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeMergeConflictsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about one or more pull request events.
		/// DescribePullRequestEvents /#X-Amz-Target=CodeCommit_20150413.DescribePullRequestEvents
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribePullRequestEventsOutput> DescribePullRequestEventsAsync(string maxResults, string nextToken, DescribePullRequestEventsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.DescribePullRequestEvents?maxResults=" + (maxResults==null? "" : Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribePullRequestEventsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes the association between a template and a repository so that approval rules based on the template are not automatically created when pull requests are created in the specified repository. This does not delete any approval rules previously created for pull requests through the template association.
		/// DisassociateApprovalRuleTemplateFromRepository /#X-Amz-Target=CodeCommit_20150413.DisassociateApprovalRuleTemplateFromRepository
		/// </summary>
		/// <returns>Success</returns>
		public async Task DisassociateApprovalRuleTemplateFromRepositoryAsync(DisassociateApprovalRuleTemplateFromRepositoryInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.DisassociateApprovalRuleTemplateFromRepository";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Evaluates whether a pull request has met all the conditions specified in its associated approval rules.
		/// EvaluatePullRequestApprovalRules /#X-Amz-Target=CodeCommit_20150413.EvaluatePullRequestApprovalRules
		/// </summary>
		/// <returns>Success</returns>
		public async Task<EvaluatePullRequestApprovalRulesOutput> EvaluatePullRequestApprovalRulesAsync(EvaluatePullRequestApprovalRulesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.EvaluatePullRequestApprovalRules";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<EvaluatePullRequestApprovalRulesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about a specified approval rule template.
		/// GetApprovalRuleTemplate /#X-Amz-Target=CodeCommit_20150413.GetApprovalRuleTemplate
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetApprovalRuleTemplateOutput> GetApprovalRuleTemplateAsync(GetApprovalRuleTemplateInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetApprovalRuleTemplate";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetApprovalRuleTemplateOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the base-64 encoded content of an individual blob in a repository.
		/// GetBlob /#X-Amz-Target=CodeCommit_20150413.GetBlob
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetBlobOutput> GetBlobAsync(GetBlobInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetBlob";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetBlobOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about a repository branch, including its name and the last commit ID.
		/// GetBranch /#X-Amz-Target=CodeCommit_20150413.GetBranch
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetBranchOutput> GetBranchAsync(GetBranchInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetBranch";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetBranchOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the content of a comment made on a change, file, or commit in a repository.
		/// GetComment /#X-Amz-Target=CodeCommit_20150413.GetComment
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetCommentOutput> GetCommentAsync(GetCommentInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetComment";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetCommentOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about comments made on the comparison between two commits.
		/// GetCommentsForComparedCommit /#X-Amz-Target=CodeCommit_20150413.GetCommentsForComparedCommit
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<GetCommentsForComparedCommitOutput> GetCommentsForComparedCommitAsync(string maxResults, string nextToken, GetCommentsForComparedCommitInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetCommentsForComparedCommit?maxResults=" + (maxResults==null? "" : Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetCommentsForComparedCommitOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns comments made on a pull request.
		/// GetCommentsForPullRequest /#X-Amz-Target=CodeCommit_20150413.GetCommentsForPullRequest
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<GetCommentsForPullRequestOutput> GetCommentsForPullRequestAsync(string maxResults, string nextToken, GetCommentsForPullRequestInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetCommentsForPullRequest?maxResults=" + (maxResults==null? "" : Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetCommentsForPullRequestOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about a commit, including commit message and committer information.
		/// GetCommit /#X-Amz-Target=CodeCommit_20150413.GetCommit
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetCommitOutput> GetCommitAsync(GetCommitInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetCommit";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetCommitOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about the differences in a valid commit specifier (such as a branch, tag, HEAD, commit ID, or other fully qualified reference). Results can be limited to a specified path.
		/// GetDifferences /#X-Amz-Target=CodeCommit_20150413.GetDifferences
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<GetDifferencesOutput> GetDifferencesAsync(string MaxResults, string NextToken, GetDifferencesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetDifferences?MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetDifferencesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the base-64 encoded contents of a specified file and its metadata.
		/// GetFile /#X-Amz-Target=CodeCommit_20150413.GetFile
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetFileOutput> GetFileAsync(GetFileInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetFile";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetFileOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the contents of a specified folder in a repository.
		/// GetFolder /#X-Amz-Target=CodeCommit_20150413.GetFolder
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetFolderOutput> GetFolderAsync(GetFolderInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetFolder";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetFolderOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about a specified merge commit.
		/// GetMergeCommit /#X-Amz-Target=CodeCommit_20150413.GetMergeCommit
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetMergeCommitOutput> GetMergeCommitAsync(GetMergeCommitInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetMergeCommit";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetMergeCommitOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about merge conflicts between the before and after commit IDs for a pull request in a repository.
		/// GetMergeConflicts /#X-Amz-Target=CodeCommit_20150413.GetMergeConflicts
		/// </summary>
		/// <param name="maxConflictFiles">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<GetMergeConflictsOutput> GetMergeConflictsAsync(string maxConflictFiles, string nextToken, GetMergeConflictsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetMergeConflicts?maxConflictFiles=" + (maxConflictFiles==null? "" : Uri.EscapeDataString(maxConflictFiles))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetMergeConflictsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about the merge options available for merging two specified branches. For details about why a merge option is not available, use GetMergeConflicts or DescribeMergeConflicts.
		/// GetMergeOptions /#X-Amz-Target=CodeCommit_20150413.GetMergeOptions
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetMergeOptionsOutput> GetMergeOptionsAsync(GetMergeOptionsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetMergeOptions";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetMergeOptionsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets information about a pull request in a specified repository.
		/// GetPullRequest /#X-Amz-Target=CodeCommit_20150413.GetPullRequest
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetPullRequestOutput> GetPullRequestAsync(GetPullRequestInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetPullRequest";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetPullRequestOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets information about the approval states for a specified pull request. Approval states only apply to pull requests that have one or more approval rules applied to them.
		/// GetPullRequestApprovalStates /#X-Amz-Target=CodeCommit_20150413.GetPullRequestApprovalStates
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetPullRequestApprovalStatesOutput> GetPullRequestApprovalStatesAsync(GetPullRequestApprovalStatesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetPullRequestApprovalStates";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetPullRequestApprovalStatesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about whether approval rules have been set aside (overridden) for a pull request, and if so, the Amazon Resource Name (ARN) of the user or identity that overrode the rules and their requirements for the pull request.
		/// GetPullRequestOverrideState /#X-Amz-Target=CodeCommit_20150413.GetPullRequestOverrideState
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetPullRequestOverrideStateOutput> GetPullRequestOverrideStateAsync(GetPullRequestOverrideStateInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetPullRequestOverrideState";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetPullRequestOverrideStateOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Returns information about a repository.</p> <note> <p>The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a webpage can expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a webpage.</p> </note>
		/// GetRepository /#X-Amz-Target=CodeCommit_20150413.GetRepository
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetRepositoryOutput> GetRepositoryAsync(GetRepositoryInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetRepository";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetRepositoryOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets information about triggers configured for a repository.
		/// GetRepositoryTriggers /#X-Amz-Target=CodeCommit_20150413.GetRepositoryTriggers
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetRepositoryTriggersOutput> GetRepositoryTriggersAsync(GetRepositoryTriggersInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.GetRepositoryTriggers";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetRepositoryTriggersOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all approval rule templates in the specified AWS Region in your AWS account. If an AWS Region is not specified, the AWS Region where you are signed in is used.
		/// ListApprovalRuleTemplates /#X-Amz-Target=CodeCommit_20150413.ListApprovalRuleTemplates
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListApprovalRuleTemplatesOutput> ListApprovalRuleTemplatesAsync(string maxResults, string nextToken, ListApprovalRuleTemplatesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.ListApprovalRuleTemplates?maxResults=" + (maxResults==null? "" : Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListApprovalRuleTemplatesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all approval rule templates that are associated with a specified repository.
		/// ListAssociatedApprovalRuleTemplatesForRepository /#X-Amz-Target=CodeCommit_20150413.ListAssociatedApprovalRuleTemplatesForRepository
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListAssociatedApprovalRuleTemplatesForRepositoryOutput> ListAssociatedApprovalRuleTemplatesForRepositoryAsync(string maxResults, string nextToken, ListAssociatedApprovalRuleTemplatesForRepositoryInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.ListAssociatedApprovalRuleTemplatesForRepository?maxResults=" + (maxResults==null? "" : Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListAssociatedApprovalRuleTemplatesForRepositoryOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets information about one or more branches in a repository.
		/// ListBranches /#X-Amz-Target=CodeCommit_20150413.ListBranches
		/// </summary>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListBranchesOutput> ListBranchesAsync(string nextToken, ListBranchesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.ListBranches?nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListBranchesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of pull requests for a specified repository. The return list can be refined by pull request status or pull request author ARN.
		/// ListPullRequests /#X-Amz-Target=CodeCommit_20150413.ListPullRequests
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListPullRequestsOutput> ListPullRequestsAsync(string maxResults, string nextToken, ListPullRequestsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.ListPullRequests?maxResults=" + (maxResults==null? "" : Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListPullRequestsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets information about one or more repositories.
		/// ListRepositories /#X-Amz-Target=CodeCommit_20150413.ListRepositories
		/// </summary>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListRepositoriesOutput> ListRepositoriesAsync(string nextToken, ListRepositoriesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.ListRepositories?nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListRepositoriesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all repositories associated with the specified approval rule template.
		/// ListRepositoriesForApprovalRuleTemplate /#X-Amz-Target=CodeCommit_20150413.ListRepositoriesForApprovalRuleTemplate
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListRepositoriesForApprovalRuleTemplateOutput> ListRepositoriesForApprovalRuleTemplateAsync(string maxResults, string nextToken, ListRepositoriesForApprovalRuleTemplateInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.ListRepositoriesForApprovalRuleTemplate?maxResults=" + (maxResults==null? "" : Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListRepositoriesForApprovalRuleTemplateOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets information about AWS tags for a specified Amazon Resource Name (ARN) in AWS CodeCommit. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the<i> AWS CodeCommit User Guide</i>.
		/// ListTagsForResource /#X-Amz-Target=CodeCommit_20150413.ListTagsForResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceOutput> ListTagsForResourceAsync(ListTagsForResourceInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.ListTagsForResource";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListTagsForResourceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Merges two branches using the fast-forward merge strategy.
		/// MergeBranchesByFastForward /#X-Amz-Target=CodeCommit_20150413.MergeBranchesByFastForward
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MergeBranchesByFastForwardOutput> MergeBranchesByFastForwardAsync(MergeBranchesByFastForwardInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.MergeBranchesByFastForward";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MergeBranchesByFastForwardOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Merges two branches using the squash merge strategy.
		/// MergeBranchesBySquash /#X-Amz-Target=CodeCommit_20150413.MergeBranchesBySquash
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MergeBranchesBySquashOutput> MergeBranchesBySquashAsync(MergeBranchesBySquashInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.MergeBranchesBySquash";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MergeBranchesBySquashOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Merges two specified branches using the three-way merge strategy.
		/// MergeBranchesByThreeWay /#X-Amz-Target=CodeCommit_20150413.MergeBranchesByThreeWay
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MergeBranchesByThreeWayOutput> MergeBranchesByThreeWayAsync(MergeBranchesByThreeWayInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.MergeBranchesByThreeWay";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MergeBranchesByThreeWayOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Attempts to merge the source commit of a pull request into the specified destination branch for that pull request at the specified commit using the fast-forward merge strategy. If the merge is successful, it closes the pull request.
		/// MergePullRequestByFastForward /#X-Amz-Target=CodeCommit_20150413.MergePullRequestByFastForward
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MergePullRequestByFastForwardOutput> MergePullRequestByFastForwardAsync(MergePullRequestByFastForwardInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.MergePullRequestByFastForward";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MergePullRequestByFastForwardOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Attempts to merge the source commit of a pull request into the specified destination branch for that pull request at the specified commit using the squash merge strategy. If the merge is successful, it closes the pull request.
		/// MergePullRequestBySquash /#X-Amz-Target=CodeCommit_20150413.MergePullRequestBySquash
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MergePullRequestBySquashOutput> MergePullRequestBySquashAsync(MergePullRequestBySquashInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.MergePullRequestBySquash";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MergePullRequestBySquashOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Attempts to merge the source commit of a pull request into the specified destination branch for that pull request at the specified commit using the three-way merge strategy. If the merge is successful, it closes the pull request.
		/// MergePullRequestByThreeWay /#X-Amz-Target=CodeCommit_20150413.MergePullRequestByThreeWay
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MergePullRequestByThreeWayOutput> MergePullRequestByThreeWayAsync(MergePullRequestByThreeWayInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.MergePullRequestByThreeWay";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MergePullRequestByThreeWayOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets aside (overrides) all approval rule requirements for a specified pull request.
		/// OverridePullRequestApprovalRules /#X-Amz-Target=CodeCommit_20150413.OverridePullRequestApprovalRules
		/// </summary>
		/// <returns>Success</returns>
		public async Task OverridePullRequestApprovalRulesAsync(OverridePullRequestApprovalRulesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.OverridePullRequestApprovalRules";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Posts a comment on the comparison between two commits.
		/// PostCommentForComparedCommit /#X-Amz-Target=CodeCommit_20150413.PostCommentForComparedCommit
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PostCommentForComparedCommitOutput> PostCommentForComparedCommitAsync(PostCommentForComparedCommitInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.PostCommentForComparedCommit";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PostCommentForComparedCommitOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Posts a comment on a pull request.
		/// PostCommentForPullRequest /#X-Amz-Target=CodeCommit_20150413.PostCommentForPullRequest
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PostCommentForPullRequestOutput> PostCommentForPullRequestAsync(PostCommentForPullRequestInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.PostCommentForPullRequest";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PostCommentForPullRequestOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Posts a comment in reply to an existing comment on a comparison between commits or a pull request.
		/// PostCommentReply /#X-Amz-Target=CodeCommit_20150413.PostCommentReply
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PostCommentReplyOutput> PostCommentReplyAsync(PostCommentReplyInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.PostCommentReply";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PostCommentReplyOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds or updates a file in a branch in an AWS CodeCommit repository, and generates a commit for the addition in the specified branch.
		/// PutFile /#X-Amz-Target=CodeCommit_20150413.PutFile
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PutFileOutput> PutFileAsync(PutFileInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.PutFile";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PutFileOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Replaces all triggers for a repository. Used to create or delete triggers.
		/// PutRepositoryTriggers /#X-Amz-Target=CodeCommit_20150413.PutRepositoryTriggers
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PutRepositoryTriggersOutput> PutRepositoryTriggersAsync(PutRepositoryTriggersInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.PutRepositoryTriggers";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PutRepositoryTriggersOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds or updates tags for a resource in AWS CodeCommit. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the <i>AWS CodeCommit User Guide</i>.
		/// TagResource /#X-Amz-Target=CodeCommit_20150413.TagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task TagResourceAsync(TagResourceInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.TagResource";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Tests the functionality of repository triggers by sending information to the trigger target. If real data is available in the repository, the test sends data from the last commit. If no data is available, sample data is generated.
		/// TestRepositoryTriggers /#X-Amz-Target=CodeCommit_20150413.TestRepositoryTriggers
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TestRepositoryTriggersOutput> TestRepositoryTriggersAsync(TestRepositoryTriggersInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.TestRepositoryTriggers";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<TestRepositoryTriggersOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes tags for a resource in AWS CodeCommit. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the <i>AWS CodeCommit User Guide</i>.
		/// UntagResource /#X-Amz-Target=CodeCommit_20150413.UntagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task UntagResourceAsync(UntagResourceInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UntagResource";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the content of an approval rule template. You can change the number of required approvals, the membership of the approval rule, and whether an approval pool is defined.
		/// UpdateApprovalRuleTemplateContent /#X-Amz-Target=CodeCommit_20150413.UpdateApprovalRuleTemplateContent
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateApprovalRuleTemplateContentOutput> UpdateApprovalRuleTemplateContentAsync(UpdateApprovalRuleTemplateContentInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdateApprovalRuleTemplateContent";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateApprovalRuleTemplateContentOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the description for a specified approval rule template.
		/// UpdateApprovalRuleTemplateDescription /#X-Amz-Target=CodeCommit_20150413.UpdateApprovalRuleTemplateDescription
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateApprovalRuleTemplateDescriptionOutput> UpdateApprovalRuleTemplateDescriptionAsync(UpdateApprovalRuleTemplateDescriptionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdateApprovalRuleTemplateDescription";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateApprovalRuleTemplateDescriptionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the name of a specified approval rule template.
		/// UpdateApprovalRuleTemplateName /#X-Amz-Target=CodeCommit_20150413.UpdateApprovalRuleTemplateName
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateApprovalRuleTemplateNameOutput> UpdateApprovalRuleTemplateNameAsync(UpdateApprovalRuleTemplateNameInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdateApprovalRuleTemplateName";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateApprovalRuleTemplateNameOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Replaces the contents of a comment.
		/// UpdateComment /#X-Amz-Target=CodeCommit_20150413.UpdateComment
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateCommentOutput> UpdateCommentAsync(UpdateCommentInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdateComment";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateCommentOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Sets or changes the default branch name for the specified repository.</p> <note> <p>If you use this operation to change the default branch name to the current default branch name, a success message is returned even though the default branch did not change.</p> </note>
		/// UpdateDefaultBranch /#X-Amz-Target=CodeCommit_20150413.UpdateDefaultBranch
		/// </summary>
		/// <returns>Success</returns>
		public async Task UpdateDefaultBranchAsync(UpdateDefaultBranchInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdateDefaultBranch";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the structure of an approval rule created specifically for a pull request. For example, you can change the number of required approvers and the approval pool for approvers.
		/// UpdatePullRequestApprovalRuleContent /#X-Amz-Target=CodeCommit_20150413.UpdatePullRequestApprovalRuleContent
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdatePullRequestApprovalRuleContentOutput> UpdatePullRequestApprovalRuleContentAsync(UpdatePullRequestApprovalRuleContentInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdatePullRequestApprovalRuleContent";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdatePullRequestApprovalRuleContentOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the state of a user's approval on a pull request. The user is derived from the signed-in account when the request is made.
		/// UpdatePullRequestApprovalState /#X-Amz-Target=CodeCommit_20150413.UpdatePullRequestApprovalState
		/// </summary>
		/// <returns>Success</returns>
		public async Task UpdatePullRequestApprovalStateAsync(UpdatePullRequestApprovalStateInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdatePullRequestApprovalState";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Replaces the contents of the description of a pull request.
		/// UpdatePullRequestDescription /#X-Amz-Target=CodeCommit_20150413.UpdatePullRequestDescription
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdatePullRequestDescriptionOutput> UpdatePullRequestDescriptionAsync(UpdatePullRequestDescriptionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdatePullRequestDescription";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdatePullRequestDescriptionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the status of a pull request.
		/// UpdatePullRequestStatus /#X-Amz-Target=CodeCommit_20150413.UpdatePullRequestStatus
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdatePullRequestStatusOutput> UpdatePullRequestStatusAsync(UpdatePullRequestStatusInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdatePullRequestStatus";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdatePullRequestStatusOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Replaces the title of a pull request.
		/// UpdatePullRequestTitle /#X-Amz-Target=CodeCommit_20150413.UpdatePullRequestTitle
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdatePullRequestTitleOutput> UpdatePullRequestTitleAsync(UpdatePullRequestTitleInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdatePullRequestTitle";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdatePullRequestTitleOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Sets or changes the comment or description for a repository.</p> <note> <p>The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a webpage can expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a webpage.</p> </note>
		/// UpdateRepositoryDescription /#X-Amz-Target=CodeCommit_20150413.UpdateRepositoryDescription
		/// </summary>
		/// <returns>Success</returns>
		public async Task UpdateRepositoryDescriptionAsync(UpdateRepositoryDescriptionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdateRepositoryDescription";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Renames a repository. The repository name must be unique across the calling AWS account. Repository names are limited to 100 alphanumeric, dash, and underscore characters, and cannot include certain characters. The suffix .git is prohibited. For more information about the limits on repository names, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">Limits</a> in the AWS CodeCommit User Guide.
		/// UpdateRepositoryName /#X-Amz-Target=CodeCommit_20150413.UpdateRepositoryName
		/// </summary>
		/// <returns>Success</returns>
		public async Task UpdateRepositoryNameAsync(UpdateRepositoryNameInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=CodeCommit_20150413.UpdateRepositoryName";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
