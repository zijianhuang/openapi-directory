//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateBackupPlanOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VersionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateBackupSelectionOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SelectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateBackupVaultOutput
	{
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteBackupPlanOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DeletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VersionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeBackupJobOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupJobId { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CompletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribeBackupJobOutputState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StatusMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PercentDone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BackupSizeInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		/// <summary>
		/// Contains information about the backup plan and rule that AWS Backup used to initiate the recovery point backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RecoveryPointCreator CreatedBy { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BytesTransferred { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ExpectedCompletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartBy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeBackupJobOutputState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeBackupVaultOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EncryptionKeyArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NumberOfRecoveryPoints { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeCopyJobOutput
	{
		
		/// <summary>
		/// Contains detailed information about a copy job.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CopyJob CopyJob { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeProtectedResourceOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastBackupTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeRecoveryPointOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Contains information about the backup plan and rule that AWS Backup used to initiate the recovery point backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RecoveryPointCreator CreatedBy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribeRecoveryPointOutputStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CompletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BackupSizeInBytes { get; set; }
		
		/// <summary>
		/// <p>Contains <code>DeleteAt</code> and <code>MoveToColdStorageAt</code> timestamps, which are used to specify a lifecycle for a recovery point.</p> <p>The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. AWS Backup transitions and expires backups automatically according to the lifecycle that you define.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CalculatedLifecycle CalculatedLifecycle { get; set; }
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Lifecycle Lifecycle { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EncryptionKeyArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsEncrypted { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribeRecoveryPointOutputStorageClass StorageClass { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastRestoreTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeRecoveryPointOutputStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTIAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeRecoveryPointOutputStorageClass
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WARM = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COLD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeRegionSettingsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceTypeOptInPreference ResourceTypeOptInPreference { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeRestoreJobOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RestoreJobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CompletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribeRestoreJobOutputStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StatusMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PercentDone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BackupSizeInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ExpectedCompletionTimeMinutes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatedResourceArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeRestoreJobOutputStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ExportBackupPlanTemplateOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanTemplateJson { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBackupPlanOutput
	{
		
		/// <summary>
		/// Contains an optional backup plan display name and an array of <code>BackupRule</code> objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of AWS resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BackupPlan BackupPlan { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VersionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DeletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastExecutionDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBackupPlanFromJSONOutput
	{
		
		/// <summary>
		/// Contains an optional backup plan display name and an array of <code>BackupRule</code> objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of AWS resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BackupPlan BackupPlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBackupPlanFromTemplateOutput
	{
		
		/// <summary>
		/// Contains an optional backup plan display name and an array of <code>BackupRule</code> objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of AWS resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BackupPlan BackupPlanDocument { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBackupSelectionOutput
	{
		
		/// <summary>
		/// Used to specify a set of resources to a backup plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BackupSelection BackupSelection { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SelectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBackupVaultAccessPolicyOutput
	{
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBackupVaultNotificationsOutput
	{
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SNSTopicArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BackupVaultEvent[] BackupVaultEvents { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetRecoveryPointRestoreMetadataOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Metadata RestoreMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetSupportedResourceTypesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceType[] ResourceTypes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListBackupJobsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BackupJob[] BackupJobs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListBackupPlanTemplatesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BackupPlanTemplatesListMember[] BackupPlanTemplatesList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListBackupPlanVersionsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BackupPlansListMember[] BackupPlanVersionsList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListBackupPlansOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BackupPlansListMember[] BackupPlansList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListBackupSelectionsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BackupSelectionsListMember[] BackupSelectionsList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListBackupVaultsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BackupVaultListMember[] BackupVaultList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListCopyJobsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CopyJob[] CopyJobs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListProtectedResourcesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ProtectedResource[] Results { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListRecoveryPointsByBackupVaultOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RecoveryPointByBackupVault[] RecoveryPoints { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListRecoveryPointsByResourceOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RecoveryPointByResource[] RecoveryPoints { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListRestoreJobsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public RestoreJobsListMember[] RestoreJobs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum BackupVaultEvent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKUP_JOB_STARTED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKUP_JOB_COMPLETED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKUP_JOB_SUCCESSFUL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKUP_JOB_FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKUP_JOB_EXPIRED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORE_JOB_STARTED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORE_JOB_COMPLETED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORE_JOB_SUCCESSFUL = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORE_JOB_FAILED = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COPY_JOB_STARTED = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COPY_JOB_SUCCESSFUL = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COPY_JOB_FAILED = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECOVERY_POINT_MODIFIED = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKUP_PLAN_CREATED = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKUP_PLAN_MODIFIED = 14,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartBackupJobOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupJobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartCopyJobOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CopyJobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartRestoreJobOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RestoreJobId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateBackupPlanOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VersionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateRecoveryPointLifecycleOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Lifecycle Lifecycle { get; set; }
		
		/// <summary>
		/// <p>Contains <code>DeleteAt</code> and <code>MoveToColdStorageAt</code> timestamps, which are used to specify a lifecycle for a recovery point.</p> <p>The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. AWS Backup transitions and expires backups automatically according to the lifecycle that you define.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CalculatedLifecycle CalculatedLifecycle { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum BackupJobState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 7,
	}
	
	/// <summary>
	/// Contains information about the backup plan and rule that AWS Backup used to initiate the recovery point backup.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RecoveryPointCreator
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupRuleId { get; set; }
	}
	
	/// <summary>
	/// Contains detailed information about a backup job.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BackupJob
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupJobId { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CompletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BackupJobState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StatusMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PercentDone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BackupSizeInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		/// <summary>
		/// Contains information about the backup plan and rule that AWS Backup used to initiate the recovery point backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RecoveryPointCreator CreatedBy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ExpectedCompletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartBy { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BytesTransferred { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum BackupJobState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 7,
	}
	
	/// <summary>
	/// Contains an optional backup plan display name and an array of <code>BackupRule</code> objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of AWS resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BackupPlan
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BackupRule[] Rules { get; set; }
	}
	
	/// <summary>
	/// Contains an optional backup plan display name and an array of <code>BackupRule</code> objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of AWS resources. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BackupPlanInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BackupRuleInput[] Rules { get; set; }
	}
	
	/// <summary>
	/// An object specifying metadata associated with a backup plan template.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BackupPlanTemplatesListMember
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanTemplateId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanTemplateName { get; set; }
	}
	
	/// <summary>
	/// Contains metadata about a backup plan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BackupPlansListMember
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DeletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VersionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastExecutionDate { get; set; }
	}
	
	/// <summary>
	/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Lifecycle
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MoveToColdStorageAfterDays { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DeleteAfterDays { get; set; }
	}
	
	/// <summary>
	/// Specifies a scheduled task used to back up a selection of resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BackupRule
	{
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RuleName { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TargetBackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartWindowMinutes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> CompletionWindowMinutes { get; set; }
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Lifecycle Lifecycle { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tags RecoveryPointTags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RuleId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CopyAction[] CopyActions { get; set; }
	}
	
	/// <summary>
	/// Specifies a scheduled task used to back up a selection of resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BackupRuleInput
	{
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RuleName { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TargetBackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartWindowMinutes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> CompletionWindowMinutes { get; set; }
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Lifecycle Lifecycle { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tags RecoveryPointTags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CopyAction[] CopyActions { get; set; }
	}
	
	/// <summary>
	/// Used to specify a set of resources to a backup plan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BackupSelection
	{
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SelectionName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ARN[] Resources { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Condition[] ListOfTags { get; set; }
	}
	
	/// <summary>
	/// Contains metadata about a <code>BackupSelection</code> object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BackupSelectionsListMember
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SelectionId { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SelectionName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
	}
	
	/// <summary>
	/// Contains metadata about a backup vault.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BackupVaultListMember
	{
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EncryptionKeyArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NumberOfRecoveryPoints { get; set; }
	}
	
	/// <summary>
	/// <p>Contains <code>DeleteAt</code> and <code>MoveToColdStorageAt</code> timestamps, which are used to specify a lifecycle for a recovery point.</p> <p>The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. AWS Backup transitions and expires backups automatically according to the lifecycle that you define.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CalculatedLifecycle
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> MoveToColdStorageAt { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DeleteAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ConditionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STRINGEQUALS = 0,
	}
	
	/// <summary>
	/// Contains an array of triplets made up of a condition type (such as <code>STRINGEQUALS</code>), a key, and a value. Conditions are used to filter resources in a selection that is assigned to a backup plan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Condition
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConditionConditionType ConditionType { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConditionKey { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConditionValue { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ConditionConditionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STRINGEQUALS = 0,
	}
	
	/// <summary>
	/// The details of the copy operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CopyAction
	{
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Lifecycle Lifecycle { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationBackupVaultArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CopyJobState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
	}
	
	/// <summary>
	/// Contains detailed information about a copy job.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CopyJob
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CopyJobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceBackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceRecoveryPointArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationBackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationRecoveryPointArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CompletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CopyJobState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StatusMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BackupSizeInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		/// <summary>
		/// Contains information about the backup plan and rule that AWS Backup used to initiate the recovery point backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RecoveryPointCreator CreatedBy { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CopyJobState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateBackupPlanInput
	{
		
		/// <summary>
		/// Contains an optional backup plan display name and an array of <code>BackupRule</code> objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of AWS resources. 
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BackupPlanInput BackupPlan { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tags BackupPlanTags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateBackupSelectionInput
	{
		
		/// <summary>
		/// Used to specify a set of resources to a backup plan.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BackupSelection BackupSelection { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateBackupVaultInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Tags BackupVaultTags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EncryptionKeyArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RecoveryPointStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTIAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum StorageClass
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WARM = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COLD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RestoreJobStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBackupPlanFromJSONInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanTemplateJson { get; set; }
	}
	
	/// <summary>
	/// A structure that contains information about a backed-up resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ProtectedResource
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastBackupTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutBackupVaultAccessPolicyInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutBackupVaultNotificationsInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SNSTopicArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BackupVaultEvent[] BackupVaultEvents { get; set; }
	}
	
	/// <summary>
	/// Contains detailed information about the recovery points stored in a backup vault.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RecoveryPointByBackupVault
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Contains information about the backup plan and rule that AWS Backup used to initiate the recovery point backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RecoveryPointCreator CreatedBy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RecoveryPointByBackupVaultStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CompletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BackupSizeInBytes { get; set; }
		
		/// <summary>
		/// <p>Contains <code>DeleteAt</code> and <code>MoveToColdStorageAt</code> timestamps, which are used to specify a lifecycle for a recovery point.</p> <p>The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. AWS Backup transitions and expires backups automatically according to the lifecycle that you define.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CalculatedLifecycle CalculatedLifecycle { get; set; }
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Lifecycle Lifecycle { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EncryptionKeyArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsEncrypted { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastRestoreTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RecoveryPointByBackupVaultStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTIAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 3,
	}
	
	/// <summary>
	/// Contains detailed information about a saved recovery point.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RecoveryPointByResource
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RecoveryPointByResourceStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EncryptionKeyArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BackupSizeBytes { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RecoveryPointByResourceStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTIAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 3,
	}
	
	/// <summary>
	/// Contains metadata about a restore job.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RestoreJobsListMember
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RestoreJobId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CompletionDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RestoreJobsListMemberStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StatusMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PercentDone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BackupSizeInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ExpectedCompletionTimeMinutes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatedResourceArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RestoreJobsListMemberStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartBackupJobInput
	{
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IdempotencyToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartWindowMinutes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> CompleteWindowMinutes { get; set; }
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Lifecycle Lifecycle { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tags RecoveryPointTags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartCopyJobInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceBackupVaultName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationBackupVaultArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IdempotencyToken { get; set; }
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Lifecycle Lifecycle { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartRestoreJobInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Metadata Metadata { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IdempotencyToken { get; set; }
		
		/// <summary>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UntagResourceInput
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @string[] TagKeyList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateBackupPlanInput
	{
		
		/// <summary>
		/// Contains an optional backup plan display name and an array of <code>BackupRule</code> objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of AWS resources. 
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BackupPlanInput BackupPlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateRecoveryPointLifecycleInput
	{
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Lifecycle Lifecycle { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateRegionSettingsInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceTypeOptInPreference ResourceTypeOptInPreference { get; set; }
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// <p>Backup plans are documents that contain information that AWS Backup uses to schedule tasks that create recovery points of resources.</p> <p>If you call <code>CreateBackupPlan</code> with a plan that already exists, an <code>AlreadyExistsException</code> is returned.</p>
		/// CreateBackupPlan /backup/plans/
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateBackupPlanOutput> CreateBackupPlanAsync(CreateBackupPlanBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateBackupPlanOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns metadata of your saved backup plans, including Amazon Resource Names (ARNs), plan IDs, creation and deletion dates, version IDs, plan names, and creator request IDs.
		/// ListBackupPlans /backup/plans/
		/// </summary>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="includeDeleted">A Boolean value with a default value of <code>FALSE</code> that returns deleted backup plans when set to <code>TRUE</code>.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListBackupPlansOutput> ListBackupPlansAsync(string nextToken, int maxResults, bool includeDeleted, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/?nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&includeDeleted="+includeDeleted+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListBackupPlansOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a JSON document that specifies a set of resources to assign to a backup plan. Resources can be included by specifying patterns for a <code>ListOfTags</code> and selected <code>Resources</code>. </p> <p>For example, consider the following patterns:</p> <ul> <li> <p> <code>Resources: "arn:aws:ec2:region:account-id:volume/volume-id"</code> </p> </li> <li> <p> <code>ConditionKey:"department"</code> </p> <p> <code>ConditionValue:"finance"</code> </p> <p> <code>ConditionType:"STRINGEQUALS"</code> </p> </li> <li> <p> <code>ConditionKey:"importance"</code> </p> <p> <code>ConditionValue:"critical"</code> </p> <p> <code>ConditionType:"STRINGEQUALS"</code> </p> </li> </ul> <p>Using these patterns would back up all Amazon Elastic Block Store (Amazon EBS) volumes that are tagged as <code>"department=finance"</code>, <code>"importance=critical"</code>, in addition to an EBS volume with the specified volume Id.</p> <p>Resources and conditions are additive in that all resources that match the pattern are selected. This shouldn't be confused with a logical AND, where all conditions must match. The matching patterns are logically 'put together using the OR operator. In other words, all patterns that match are selected for backup.</p>
		/// CreateBackupSelection /backup/plans/{backupPlanId}/selections/
		/// </summary>
		/// <param name="backupPlanId">Uniquely identifies the backup plan to be associated with the selection of resources.</param>
		/// <returns>Success</returns>
		public async Task<CreateBackupSelectionOutput> CreateBackupSelectionAsync(string backupPlanId, CreateBackupSelectionBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/"+ (backupPlanId==null? "" : Uri.EscapeDataString(backupPlanId))+"/selections/";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateBackupSelectionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns an array containing metadata of the resources associated with the target backup plan.
		/// ListBackupSelections /backup/plans/{backupPlanId}/selections/
		/// </summary>
		/// <param name="backupPlanId">Uniquely identifies a backup plan.</param>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListBackupSelectionsOutput> ListBackupSelectionsAsync(string backupPlanId, string nextToken, int maxResults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/"+ (backupPlanId==null? "" : Uri.EscapeDataString(backupPlanId))+"/selections/&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListBackupSelectionsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a logical container where backups are stored. A <code>CreateBackupVault</code> request includes a name, optionally one or more resource tags, an encryption key, and a request ID.</p> <note> <p>Sensitive data, such as passport numbers, should not be included the name of a backup vault.</p> </note>
		/// CreateBackupVault /backup-vaults/{backupVaultName}
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <returns>Success</returns>
		public async Task<CreateBackupVaultOutput> CreateBackupVaultAsync(string backupVaultName, CreateBackupVaultBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateBackupVaultOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the backup vault identified by its name. A vault can be deleted only if it is empty.
		/// DeleteBackupVault /backup-vaults/{backupVaultName}
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <returns>Success</returns>
		public async Task DeleteBackupVaultAsync(string backupVaultName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns metadata about a backup vault specified by its name.
		/// DescribeBackupVault /backup-vaults/{backupVaultName}
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <returns>Success</returns>
		public async Task<DescribeBackupVaultOutput> DescribeBackupVaultAsync(string backupVaultName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeBackupVaultOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a backup plan. A backup plan can only be deleted after all associated selections of resources have been deleted. Deleting a backup plan deletes the current version of a backup plan. Previous versions, if any, will still exist.
		/// DeleteBackupPlan /backup/plans/{backupPlanId}
		/// </summary>
		/// <param name="backupPlanId">Uniquely identifies a backup plan.</param>
		/// <returns>Success</returns>
		public async Task<DeleteBackupPlanOutput> DeleteBackupPlanAsync(string backupPlanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/"+ (backupPlanId==null? "" : Uri.EscapeDataString(backupPlanId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteBackupPlanOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Replaces the body of a saved backup plan identified by its <code>backupPlanId</code> with the input document in JSON format. The new version is uniquely identified by a <code>VersionId</code>.
		/// UpdateBackupPlan /backup/plans/{backupPlanId}
		/// </summary>
		/// <param name="backupPlanId">Uniquely identifies a backup plan.</param>
		/// <returns>Success</returns>
		public async Task<UpdateBackupPlanOutput> UpdateBackupPlanAsync(string backupPlanId, UpdateBackupPlanBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/"+ (backupPlanId==null? "" : Uri.EscapeDataString(backupPlanId));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateBackupPlanOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the resource selection associated with a backup plan that is specified by the <code>SelectionId</code>.
		/// DeleteBackupSelection /backup/plans/{backupPlanId}/selections/{selectionId}
		/// </summary>
		/// <param name="backupPlanId">Uniquely identifies a backup plan.</param>
		/// <param name="selectionId">Uniquely identifies the body of a request to assign a set of resources to a backup plan.</param>
		/// <returns>Success</returns>
		public async Task DeleteBackupSelectionAsync(string backupPlanId, string selectionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/"+ (backupPlanId==null? "" : Uri.EscapeDataString(backupPlanId))+"/selections/"+ (selectionId==null? "" : Uri.EscapeDataString(selectionId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns selection metadata and a document in JSON format that specifies a list of resources that are associated with a backup plan.
		/// GetBackupSelection /backup/plans/{backupPlanId}/selections/{selectionId}
		/// </summary>
		/// <param name="backupPlanId">Uniquely identifies a backup plan.</param>
		/// <param name="selectionId">Uniquely identifies the body of a request to assign a set of resources to a backup plan.</param>
		/// <returns>Success</returns>
		public async Task<GetBackupSelectionOutput> GetBackupSelectionAsync(string backupPlanId, string selectionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/"+ (backupPlanId==null? "" : Uri.EscapeDataString(backupPlanId))+"/selections/"+ (selectionId==null? "" : Uri.EscapeDataString(selectionId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetBackupSelectionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the policy document that manages permissions on a backup vault.
		/// DeleteBackupVaultAccessPolicy /backup-vaults/{backupVaultName}/access-policy
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <returns>Success</returns>
		public async Task DeleteBackupVaultAccessPolicyAsync(string backupVaultName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/access-policy";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the access policy document that is associated with the named backup vault.
		/// GetBackupVaultAccessPolicy /backup-vaults/{backupVaultName}/access-policy
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <returns>Success</returns>
		public async Task<GetBackupVaultAccessPolicyOutput> GetBackupVaultAccessPolicyAsync(string backupVaultName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/access-policy";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetBackupVaultAccessPolicyOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets a resource-based policy that is used to manage access permissions on the target backup vault. Requires a backup vault name and an access policy document in JSON format.
		/// PutBackupVaultAccessPolicy /backup-vaults/{backupVaultName}/access-policy
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <returns>Success</returns>
		public async Task PutBackupVaultAccessPolicyAsync(string backupVaultName, PutBackupVaultAccessPolicyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/access-policy";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes event notifications for the specified backup vault.
		/// DeleteBackupVaultNotifications /backup-vaults/{backupVaultName}/notification-configuration
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <returns>Success</returns>
		public async Task DeleteBackupVaultNotificationsAsync(string backupVaultName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/notification-configuration";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns event notifications for the specified backup vault.
		/// GetBackupVaultNotifications /backup-vaults/{backupVaultName}/notification-configuration
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <returns>Success</returns>
		public async Task<GetBackupVaultNotificationsOutput> GetBackupVaultNotificationsAsync(string backupVaultName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/notification-configuration";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetBackupVaultNotificationsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Turns on notifications on a backup vault for the specified topic and events.
		/// PutBackupVaultNotifications /backup-vaults/{backupVaultName}/notification-configuration
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <returns>Success</returns>
		public async Task PutBackupVaultNotificationsAsync(string backupVaultName, PutBackupVaultNotificationsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/notification-configuration";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the recovery point specified by a recovery point ID.
		/// DeleteRecoveryPoint /backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <param name="recoveryPointArn">An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</param>
		/// <returns>Success</returns>
		public async Task DeleteRecoveryPointAsync(string backupVaultName, string recoveryPointArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/recovery-points/"+ (recoveryPointArn==null? "" : Uri.EscapeDataString(recoveryPointArn));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns metadata associated with a recovery point, including ID, status, encryption, and lifecycle.
		/// DescribeRecoveryPoint /backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <param name="recoveryPointArn">An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</param>
		/// <returns>Success</returns>
		public async Task<DescribeRecoveryPointOutput> DescribeRecoveryPointAsync(string backupVaultName, string recoveryPointArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/recovery-points/"+ (recoveryPointArn==null? "" : Uri.EscapeDataString(recoveryPointArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeRecoveryPointOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Sets the transition lifecycle of a recovery point.</p> <p>The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. AWS Backup transitions and expires backups automatically according to the lifecycle that you define. </p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. </p>
		/// UpdateRecoveryPointLifecycle /backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <param name="recoveryPointArn">An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</param>
		/// <returns>Success</returns>
		public async Task<UpdateRecoveryPointLifecycleOutput> UpdateRecoveryPointLifecycleAsync(string backupVaultName, string recoveryPointArn, UpdateRecoveryPointLifecycleBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/recovery-points/"+ (recoveryPointArn==null? "" : Uri.EscapeDataString(recoveryPointArn));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateRecoveryPointLifecycleOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns metadata associated with creating a backup of a resource.
		/// DescribeBackupJob /backup-jobs/{backupJobId}
		/// </summary>
		/// <param name="backupJobId">Uniquely identifies a request to AWS Backup to back up a resource.</param>
		/// <returns>Success</returns>
		public async Task<DescribeBackupJobOutput> DescribeBackupJobAsync(string backupJobId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-jobs/"+ (backupJobId==null? "" : Uri.EscapeDataString(backupJobId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeBackupJobOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Attempts to cancel a job to create a one-time backup of a resource.
		/// StopBackupJob /backup-jobs/{backupJobId}
		/// </summary>
		/// <param name="backupJobId">Uniquely identifies a request to AWS Backup to back up a resource.</param>
		/// <returns>Success</returns>
		public async Task StopBackupJobAsync(string backupJobId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-jobs/"+ (backupJobId==null? "" : Uri.EscapeDataString(backupJobId));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns metadata associated with creating a copy of a resource.
		/// DescribeCopyJob /copy-jobs/{copyJobId}
		/// </summary>
		/// <param name="copyJobId">Uniquely identifies a copy job.</param>
		/// <returns>Success</returns>
		public async Task<DescribeCopyJobOutput> DescribeCopyJobAsync(string copyJobId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/copy-jobs/"+ (copyJobId==null? "" : Uri.EscapeDataString(copyJobId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeCopyJobOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns information about a saved resource, including the last time it was backed up, its Amazon Resource Name (ARN), and the AWS service type of the saved resource.
		/// DescribeProtectedResource /resources/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.</param>
		/// <returns>Success</returns>
		public async Task<DescribeProtectedResourceOutput> DescribeProtectedResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/resources/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeProtectedResourceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the current service opt-in settings for the region. If the service has a value set to true, AWS Backup will attempt to protect that service's resources in this region, when included in an on-demand backup or scheduled backup plan. If the value is set to false for a service, AWS Backup will not attempt to protect that service's resources in this region.
		/// DescribeRegionSettings /account-settings
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeRegionSettingsOutput> DescribeRegionSettingsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/account-settings";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeRegionSettingsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the current service opt-in settings for the region. If the service has a value set to true, AWS Backup will attempt to protect that service's resources in this region, when included in an on-demand backup or scheduled backup plan. If the value is set to false for a service, AWS Backup will not attempt to protect that service's resources in this region.
		/// UpdateRegionSettings /account-settings
		/// </summary>
		/// <returns>Success</returns>
		public async Task UpdateRegionSettingsAsync(UpdateRegionSettingsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/account-settings";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns metadata associated with a restore job that is specified by a job ID.
		/// DescribeRestoreJob /restore-jobs/{restoreJobId}
		/// </summary>
		/// <param name="restoreJobId">Uniquely identifies the job that restores a recovery point.</param>
		/// <returns>Success</returns>
		public async Task<DescribeRestoreJobOutput> DescribeRestoreJobAsync(string restoreJobId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/restore-jobs/"+ (restoreJobId==null? "" : Uri.EscapeDataString(restoreJobId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeRestoreJobOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the backup plan that is specified by the plan ID as a backup template.
		/// ExportBackupPlanTemplate /backup/plans/{backupPlanId}/toTemplate/
		/// </summary>
		/// <param name="backupPlanId">Uniquely identifies a backup plan.</param>
		/// <returns>Success</returns>
		public async Task<ExportBackupPlanTemplateOutput> ExportBackupPlanTemplateAsync(string backupPlanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/"+ (backupPlanId==null? "" : Uri.EscapeDataString(backupPlanId))+"/toTemplate/";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ExportBackupPlanTemplateOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the body of a backup plan in JSON format, in addition to plan metadata.
		/// GetBackupPlan /backup/plans/{backupPlanId}/
		/// </summary>
		/// <param name="backupPlanId">Uniquely identifies a backup plan.</param>
		/// <param name="versionId">Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.</param>
		/// <returns>Success</returns>
		public async Task<GetBackupPlanOutput> GetBackupPlanAsync(string backupPlanId, string versionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/"+ (backupPlanId==null? "" : Uri.EscapeDataString(backupPlanId))+"/&versionId=" + (versionId==null? "" : Uri.EscapeDataString(versionId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetBackupPlanOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a valid JSON document specifying a backup plan or an error.
		/// GetBackupPlanFromJSON /backup/template/json/toPlan
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetBackupPlanFromJSONOutput> GetBackupPlanFromJSONAsync(GetBackupPlanFromJSONBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/template/json/toPlan";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetBackupPlanFromJSONOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the template specified by its <code>templateId</code> as a backup plan.
		/// GetBackupPlanFromTemplate /backup/template/plans/{templateId}/toPlan
		/// </summary>
		/// <param name="templateId">Uniquely identifies a stored backup plan template.</param>
		/// <returns>Success</returns>
		public async Task<GetBackupPlanFromTemplateOutput> GetBackupPlanFromTemplateAsync(string templateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/template/plans/"+ (templateId==null? "" : Uri.EscapeDataString(templateId))+"/toPlan";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetBackupPlanFromTemplateOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a set of metadata key-value pairs that were used to create the backup.
		/// GetRecoveryPointRestoreMetadata /backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}/restore-metadata
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <param name="recoveryPointArn">An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</param>
		/// <returns>Success</returns>
		public async Task<GetRecoveryPointRestoreMetadataOutput> GetRecoveryPointRestoreMetadataAsync(string backupVaultName, string recoveryPointArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/recovery-points/"+ (recoveryPointArn==null? "" : Uri.EscapeDataString(recoveryPointArn))+"/restore-metadata";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetRecoveryPointRestoreMetadataOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the AWS resource types supported by AWS Backup.
		/// GetSupportedResourceTypes /supported-resource-types
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetSupportedResourceTypesOutput> GetSupportedResourceTypesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/supported-resource-types";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetSupportedResourceTypesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns metadata about your backup jobs.
		/// ListBackupJobs /backup-jobs/
		/// </summary>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="resourceArn">Returns only backup jobs that match the specified resource Amazon Resource Name (ARN).</param>
		/// <param name="state">Returns only backup jobs that are in the specified state.</param>
		/// <param name="backupVaultName">Returns only backup jobs that will be stored in the specified backup vault. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <param name="createdBefore">Returns only backup jobs that were created before the specified date.</param>
		/// <param name="createdAfter">Returns only backup jobs that were created after the specified date.</param>
		/// <param name="resourceType"><p>Returns only backup jobs for the specified resources:</p> <ul> <li> <p> <code>DynamoDB</code> for Amazon DynamoDB</p> </li> <li> <p> <code>EBS</code> for Amazon Elastic Block Store</p> </li> <li> <p> <code>EFS</code> for Amazon Elastic File System</p> </li> <li> <p> <code>RDS</code> for Amazon Relational Database Service</p> </li> <li> <p> <code>Storage Gateway</code> for AWS Storage Gateway</p> </li> </ul></param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListBackupJobsOutput> ListBackupJobsAsync(string nextToken, int maxResults, string resourceArn, DescribeBackupJobOutputState state, string backupVaultName, System.DateTimeOffset createdBefore, System.DateTimeOffset createdAfter, string resourceType, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-jobs/?nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&resourceArn=" + (resourceArn==null? "" : Uri.EscapeDataString(resourceArn))+"&state=" + state+"&backupVaultName=" + (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"&createdBefore=" + createdBefore.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&createdAfter=" + createdAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&resourceType=" + (resourceType==null? "" : Uri.EscapeDataString(resourceType))+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListBackupJobsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns metadata of your saved backup plan templates, including the template ID, name, and the creation and deletion dates.
		/// ListBackupPlanTemplates /backup/template/plans
		/// </summary>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListBackupPlanTemplatesOutput> ListBackupPlanTemplatesAsync(string nextToken, int maxResults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/template/plans?nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListBackupPlanTemplatesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns version metadata of your backup plans, including Amazon Resource Names (ARNs), backup plan IDs, creation and deletion dates, plan names, and version IDs.
		/// ListBackupPlanVersions /backup/plans/{backupPlanId}/versions/
		/// </summary>
		/// <param name="backupPlanId">Uniquely identifies a backup plan.</param>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListBackupPlanVersionsOutput> ListBackupPlanVersionsAsync(string backupPlanId, string nextToken, int maxResults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup/plans/"+ (backupPlanId==null? "" : Uri.EscapeDataString(backupPlanId))+"/versions/&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListBackupPlanVersionsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of recovery point storage containers along with information about them.
		/// ListBackupVaults /backup-vaults/
		/// </summary>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListBackupVaultsOutput> ListBackupVaultsAsync(string nextToken, int maxResults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/?nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListBackupVaultsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns metadata about your copy jobs.
		/// ListCopyJobs /copy-jobs/
		/// </summary>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token. </param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="resourceArn">Returns only copy jobs that match the specified resource Amazon Resource Name (ARN). </param>
		/// <param name="state">Returns only copy jobs that are in the specified state.</param>
		/// <param name="createdBefore">Returns only copy jobs that were created before the specified date.</param>
		/// <param name="createdAfter">Returns only copy jobs that were created after the specified date.</param>
		/// <param name="resourceType"><p>Returns only backup jobs for the specified resources:</p> <ul> <li> <p> <code>EBS</code> for Amazon Elastic Block Store</p> </li> <li> <p> <code>EFS</code> for Amazon Elastic File System</p> </li> <li> <p> <code>RDS</code> for Amazon Relational Database Service</p> </li> <li> <p> <code>Storage Gateway</code> for AWS Storage Gateway</p> </li> </ul></param>
		/// <param name="destinationVaultArn">An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy from; for example, <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>. </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListCopyJobsOutput> ListCopyJobsAsync(string nextToken, int maxResults, string resourceArn, CopyJobState state, System.DateTimeOffset createdBefore, System.DateTimeOffset createdAfter, string resourceType, string destinationVaultArn, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/copy-jobs/?nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&resourceArn=" + (resourceArn==null? "" : Uri.EscapeDataString(resourceArn))+"&state=" + state+"&createdBefore=" + createdBefore.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&createdAfter=" + createdAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&resourceType=" + (resourceType==null? "" : Uri.EscapeDataString(resourceType))+"&destinationVaultArn=" + (destinationVaultArn==null? "" : Uri.EscapeDataString(destinationVaultArn))+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListCopyJobsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an array of resources successfully backed up by AWS Backup, including the time the resource was saved, an Amazon Resource Name (ARN) of the resource, and a resource type.
		/// ListProtectedResources /resources/
		/// </summary>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListProtectedResourcesOutput> ListProtectedResourcesAsync(string nextToken, int maxResults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/resources/?nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListProtectedResourcesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns detailed information about the recovery points stored in a backup vault.
		/// ListRecoveryPointsByBackupVault /backup-vaults/{backupVaultName}/recovery-points/
		/// </summary>
		/// <param name="backupVaultName">The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.</param>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="resourceArn">Returns only recovery points that match the specified resource Amazon Resource Name (ARN).</param>
		/// <param name="resourceType">Returns only recovery points that match the specified resource type.</param>
		/// <param name="backupPlanId">Returns only recovery points that match the specified backup plan ID.</param>
		/// <param name="createdBefore">Returns only recovery points that were created before the specified timestamp.</param>
		/// <param name="createdAfter">Returns only recovery points that were created after the specified timestamp.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListRecoveryPointsByBackupVaultOutput> ListRecoveryPointsByBackupVaultAsync(string backupVaultName, string nextToken, int maxResults, string resourceArn, string resourceType, string backupPlanId, System.DateTimeOffset createdBefore, System.DateTimeOffset createdAfter, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-vaults/"+ (backupVaultName==null? "" : Uri.EscapeDataString(backupVaultName))+"/recovery-points/&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&resourceArn=" + (resourceArn==null? "" : Uri.EscapeDataString(resourceArn))+"&resourceType=" + (resourceType==null? "" : Uri.EscapeDataString(resourceType))+"&backupPlanId=" + (backupPlanId==null? "" : Uri.EscapeDataString(backupPlanId))+"&createdBefore=" + createdBefore.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&createdAfter=" + createdAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListRecoveryPointsByBackupVaultOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns detailed information about recovery points of the type specified by a resource Amazon Resource Name (ARN).
		/// ListRecoveryPointsByResource /resources/{resourceArn}/recovery-points/
		/// </summary>
		/// <param name="resourceArn">An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.</param>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListRecoveryPointsByResourceOutput> ListRecoveryPointsByResourceAsync(string resourceArn, string nextToken, int maxResults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/resources/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn))+"/recovery-points/&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListRecoveryPointsByResourceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of jobs that AWS Backup initiated to restore a saved resource, including metadata about the recovery process.
		/// ListRestoreJobs /restore-jobs/
		/// </summary>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListRestoreJobsOutput> ListRestoreJobsAsync(string nextToken, int maxResults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/restore-jobs/?nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListRestoreJobsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Returns a list of key-value pairs assigned to a target recovery point, backup plan, or backup vault.</p> <note> <p> <code>ListTags</code> are currently only supported with Amazon EFS backups.</p> </note>
		/// ListTags /tags/{resourceArn}/
		/// </summary>
		/// <param name="resourceArn">An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the type of resource. Valid targets for <code>ListTags</code> are recovery points, backup plans, and backup vaults.</param>
		/// <param name="nextToken">The next item following a partial list of returned items. For example, if a request is made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you to return more items in your list starting at the location pointed to by the next token.</param>
		/// <param name="maxResults">The maximum number of items to be returned.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListTagsOutput> ListTagsAsync(string resourceArn, string nextToken, int maxResults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn))+"/&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListTagsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts a job to create a one-time backup of the specified resource.
		/// StartBackupJob /backup-jobs
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StartBackupJobOutput> StartBackupJobAsync(StartBackupJobBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/backup-jobs";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<StartBackupJobOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Starts a job to create a one-time copy of the specified resource.
		/// StartCopyJob /copy-jobs
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StartCopyJobOutput> StartCopyJobAsync(StartCopyJobBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/copy-jobs";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<StartCopyJobOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Recovers the saved resource identified by an Amazon Resource Name (ARN). </p> <p>If the resource ARN is included in the request, then the last complete backup of that resource is recovered. If the ARN of a recovery point is supplied, then that recovery point is restored.</p>
		/// StartRestoreJob /restore-jobs
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StartRestoreJobOutput> StartRestoreJobAsync(StartRestoreJobBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/restore-jobs";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<StartRestoreJobOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Assigns a set of key-value pairs to a recovery point, backup plan, or backup vault identified by an Amazon Resource Name (ARN).
		/// TagResource /tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource.</param>
		/// <returns>Success</returns>
		public async Task TagResourceAsync(string resourceArn, TagResourceBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes a set of key-value pairs from a recovery point, backup plan, or backup vault identified by an Amazon Resource Name (ARN)
		/// UntagResource /untag/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource.</param>
		/// <returns>Success</returns>
		public async Task UntagResourceAsync(string resourceArn, UntagResourceBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/untag/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateBackupPlanBody
	{
		
		/// <summary>
		/// Contains an optional backup plan display name and an array of <code>BackupRule</code> objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of AWS resources. 
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlan { get; set; }
		
		/// <summary>
		/// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair. The specified tags are assigned to all backups created with this plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanTags { get; set; }
		
		/// <summary>
		/// Identifies the request and allows failed requests to be retried without the risk of executing the operation twice. If the request includes a <code>CreatorRequestId</code> that matches an existing backup plan, that plan is returned. This parameter is optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateBackupSelectionBody
	{
		
		/// <summary>
		/// Used to specify a set of resources to a backup plan.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupSelection { get; set; }
		
		/// <summary>
		/// A unique string that identifies the request and allows failed requests to be retried without the risk of executing the operation twice.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateBackupVaultBody
	{
		
		/// <summary>
		/// Metadata that you can assign to help organize the resources that you create. Each tag is a key-value pair.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultTags { get; set; }
		
		/// <summary>
		/// The server-side encryption key that is used to protect your backups; for example, <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string EncryptionKeyArn { get; set; }
		
		/// <summary>
		/// A unique string that identifies the request and allows failed requests to be retried without the risk of executing the operation twice.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CreatorRequestId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateBackupPlanBody
	{
		
		/// <summary>
		/// Contains an optional backup plan display name and an array of <code>BackupRule</code> objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of AWS resources. 
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutBackupVaultAccessPolicyBody
	{
		
		/// <summary>
		/// The backup vault access policy document in JSON format.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutBackupVaultNotificationsBody
	{
		
		/// <summary>
		/// The Amazon Resource Name (ARN) that specifies the topic for a backup vault’s events; for example, <code>arn:aws:sns:us-west-2:111122223333:MyVaultTopic</code>.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SNSTopicArn { get; set; }
		
		/// <summary>
		/// An array of events that indicate the status of jobs to back up resources to the backup vault.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BackupVaultEvent[] BackupVaultEvents { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateRecoveryPointLifecycleBody
	{
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Lifecycle { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateRegionSettingsBody
	{
		
		/// <summary>
		/// Updates the list of services along with the opt-in preferences for the region.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceTypeOptInPreference { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBackupPlanFromJSONBody
	{
		
		/// <summary>
		/// A customer-supplied backup plan document in JSON format.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupPlanTemplateJson { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartBackupJobBody
	{
		
		/// <summary>
		/// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupVaultName { get; set; }
		
		/// <summary>
		/// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Specifies the IAM role ARN used to create the target recovery point; for example, <code>arn:aws:iam::123456789012:role/S3Access</code>.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		/// <summary>
		/// A customer chosen string that can be used to distinguish between calls to <code>StartBackupJob</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IdempotencyToken { get; set; }
		
		/// <summary>
		/// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartWindowMinutes { get; set; }
		
		/// <summary>
		/// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by AWS Backup. This value is optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> CompleteWindowMinutes { get; set; }
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Lifecycle { get; set; }
		
		/// <summary>
		/// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointTags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartCopyJobBody
	{
		
		/// <summary>
		/// An ARN that uniquely identifies a recovery point to use for the copy job; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45. 
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		/// <summary>
		/// The name of a logical source container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceBackupVaultName { get; set; }
		
		/// <summary>
		/// An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to copy to; for example, <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DestinationBackupVaultArn { get; set; }
		
		/// <summary>
		/// Specifies the IAM role ARN used to copy the target recovery point; for example, <code>arn:aws:iam::123456789012:role/S3Access</code>.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		/// <summary>
		/// A customer chosen string that can be used to distinguish between calls to <code>StartCopyJob</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IdempotencyToken { get; set; }
		
		/// <summary>
		/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before a recovery point transitions to cold storage or is deleted.</p> <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Lifecycle { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartRestoreJobBody
	{
		
		/// <summary>
		/// An ARN that uniquely identifies a recovery point; for example, <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RecoveryPointArn { get; set; }
		
		/// <summary>
		/// <p>A set of metadata key-value pairs. Contains information, such as a resource name, required to restore a recovery point.</p> <p> You can get configuration metadata about a resource at the time it was backed up by calling <code>GetRecoveryPointRestoreMetadata</code>. However, values in addition to those provided by <code>GetRecoveryPointRestoreMetadata</code> might be required to restore a resource. For example, you might need to provide a new resource name if the original already exists.</p> <p>You need to specify specific metadata to restore an Amazon Elastic File System (Amazon EFS) instance:</p> <ul> <li> <p> <code>file-system-id</code>: ID of the Amazon EFS file system that is backed up by AWS Backup. Returned in <code>GetRecoveryPointRestoreMetadata</code>.</p> </li> <li> <p> <code>Encrypted</code>: A Boolean value that, if true, specifies that the file system is encrypted. If <code>KmsKeyId</code> is specified, <code>Encrypted</code> must be set to <code>true</code>.</p> </li> <li> <p> <code>KmsKeyId</code>: Specifies the AWS KMS key that is used to encrypt the restored file system.</p> </li> <li> <p> <code>PerformanceMode</code>: Specifies the throughput mode of the file system.</p> </li> <li> <p> <code>CreationToken</code>: A user-supplied value that ensures the uniqueness (idempotency) of the request.</p> </li> <li> <p> <code>newFileSystem</code>: A Boolean value that, if true, specifies that the recovery point is restored to a new Amazon EFS file system.</p> </li> </ul>
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		/// <summary>
		/// The Amazon Resource Name (ARN) of the IAM role that AWS Backup uses to create the target recovery point; for example, <code>arn:aws:iam::123456789012:role/S3Access</code>.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IamRoleArn { get; set; }
		
		/// <summary>
		/// A customer chosen string that can be used to distinguish between calls to <code>StartRestoreJob</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IdempotencyToken { get; set; }
		
		/// <summary>
		/// <p>Starts a job to restore a recovery point for one of the following resources:</p> <ul> <li> <p> <code>EBS</code> for Amazon Elastic Block Store</p> </li> <li> <p> <code>Storage Gateway</code> for AWS Storage Gateway</p> </li> <li> <p> <code>RDS</code> for Amazon Relational Database Service</p> </li> <li> <p> <code>DDB</code> for Amazon DynamoDB</p> </li> <li> <p> <code>EFS</code> for Amazon Elastic File System</p> </li> </ul>
		/// Pattern: ^[a-zA-Z0-9\-\_\.]{1,50}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceBody
	{
		
		/// <summary>
		/// Key-value pairs that are used to help organize your resources. You can assign your own metadata to the resources you create. 
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UntagResourceBody
	{
		
		/// <summary>
		/// A list of keys to identify which key-value tags to remove from a resource.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @string[] TagKeyList { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
