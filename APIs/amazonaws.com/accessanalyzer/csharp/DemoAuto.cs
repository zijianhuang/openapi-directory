//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// The response to the request to create an analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateAnalyzerResponse
	{
		
		/// <summary>
		/// Pattern: ^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
	}
	
	/// <summary>
	/// An criterion statement in an archive rule. Each archive rule may have multiple criteria.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class InlineArchiveRule
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FilterCriteriaMap Filter { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[A-Za-z][A-Za-z0-9_.-]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string RuleName { get; set; }
	}
	
	/// <summary>
	/// The criteria to use in the filter that defines the archive rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Criterion
	{
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 20
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public String[] Contains { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 20
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public String[] Eq { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Exists { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 20
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public String[] Neq { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetAnalyzedResourceResponse
	{
		
		/// <summary>
		/// Contains details about the analyzed resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AnalyzedResource Resource { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetAnalyzerResponse
	{
		
		/// <summary>
		/// Contains information about the analyzer.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AnalyzerSummary Analyzer { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetArchiveRuleResponse
	{
		
		/// <summary>
		/// Contains information about an archive rule.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ArchiveRuleSummary ArchiveRule { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetFindingResponse
	{
		
		/// <summary>
		/// Contains information about a finding.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Finding Finding { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListAnalyzedResourcesResponse
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AnalyzedResourceSummary[] AnalyzedResources { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListAnalyzersResponse
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AnalyzerSummary[] Analyzers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListArchiveRulesResponse
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ArchiveRuleSummary[] ArchiveRules { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListFindingsResponse
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FindingSummary[] Findings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum OrderBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DESC = 1,
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TagsMap Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::IAM::Role = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::KMS::Key = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::Function = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::LayerVersion = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::S3::Bucket = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::SQS::Queue = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FindingStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHIVED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOLVED = 2,
	}
	
	/// <summary>
	/// Contains details about the analyzed resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnalyzedResource
	{
		
		[System.Runtime.Serialization.DataMember()]
		public String[] Actions { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset AnalyzedAt { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Error { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsPublic { get; set; }
		
		/// <summary>
		/// Pattern: arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceOwnerAccount { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AnalyzedResourceResourceType ResourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public String[] SharedVia { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AnalyzedResourceStatus Status { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AnalyzedResourceResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::IAM::Role = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::KMS::Key = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::Function = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::LayerVersion = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::S3::Bucket = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::SQS::Queue = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AnalyzedResourceStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHIVED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOLVED = 2,
	}
	
	/// <summary>
	/// Contains the ARN of the analyzed resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnalyzedResourceSummary
	{
		
		/// <summary>
		/// Pattern: arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceOwnerAccount { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AnalyzedResourceSummaryResourceType ResourceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AnalyzedResourceSummaryResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::IAM::Role = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::KMS::Key = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::Function = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::LayerVersion = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::S3::Bucket = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::SQS::Queue = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AnalyzerStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
	}
	
	/// <summary>
	/// Provides more details about the current status of the analyzer. For example, if the creation for the analyzer fails, a <code>Failed</code> status is displayed. For an analyzer with organization as the type, this failure can be due to an issue with creating the service-linked roles required in the member accounts of the AWS organization.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StatusReason
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public StatusReasonCode Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum StatusReasonCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_SERVICE_ACCESS_DISABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELEGATED_ADMINISTRATOR_DEREGISTERED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION_DELETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVICE_LINKED_ROLE_CREATION_FAILED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum Type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCOUNT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION = 1,
	}
	
	/// <summary>
	/// Contains information about the analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AnalyzerSummary
	{
		
		/// <summary>
		/// Pattern: ^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LastResourceAnalyzed { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastResourceAnalyzedAt { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[A-Za-z][A-Za-z0-9_.-]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AnalyzerSummaryStatus Status { get; set; }
		
		/// <summary>
		/// Provides more details about the current status of the analyzer. For example, if the creation for the analyzer fails, a <code>Failed</code> status is displayed. For an analyzer with organization as the type, this failure can be due to an issue with creating the service-linked roles required in the member accounts of the AWS organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public StatusReason StatusReason { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TagsMap Tags { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AnalyzerSummaryType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AnalyzerSummaryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AnalyzerSummaryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCOUNT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION = 1,
	}
	
	/// <summary>
	/// Contains information about an archive rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ArchiveRuleSummary
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FilterCriteriaMap Filter { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[A-Za-z][A-Za-z0-9_.-]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string RuleName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	/// <summary>
	/// Creates an analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateAnalyzerRequest
	{
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[A-Za-z][A-Za-z0-9_.-]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string AnalyzerName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public InlineArchiveRule[] ArchiveRules { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TagsMap Tags { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateAnalyzerRequestType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateAnalyzerRequestType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCOUNT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION = 1,
	}
	
	/// <summary>
	/// Creates an archive rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateArchiveRuleRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FilterCriteriaMap Filter { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[A-Za-z][A-Za-z0-9_.-]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string RuleName { get; set; }
	}
	
	/// <summary>
	/// Contains information about a finding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Finding
	{
		
		[System.Runtime.Serialization.DataMember()]
		public String[] Action { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset AnalyzedAt { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConditionKeyMap Condition { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Error { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPublic { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PrincipalMap Principal { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Resource { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceOwnerAccount { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FindingResourceType ResourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FindingSource[] Sources { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FindingStatus Status { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FindingResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::IAM::Role = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::KMS::Key = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::Function = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::LayerVersion = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::S3::Bucket = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::SQS::Queue = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FindingStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHIVED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOLVED = 2,
	}
	
	/// <summary>
	/// Includes details about how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FindingSourceDetail
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AccessPointArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FindingSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BUCKET_ACL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POLICY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		S3_ACCESS_POINT = 2,
	}
	
	/// <summary>
	/// The source of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FindingSource
	{
		
		/// <summary>
		/// Includes details about how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FindingSourceDetail Detail { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FindingSourceType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FindingSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BUCKET_ACL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POLICY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		S3_ACCESS_POINT = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FindingStatusUpdate
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHIVED = 1,
	}
	
	/// <summary>
	/// Contains information about a finding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FindingSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public String[] Action { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset AnalyzedAt { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConditionKeyMap Condition { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Error { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPublic { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PrincipalMap Principal { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Resource { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceOwnerAccount { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FindingSummaryResourceType ResourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FindingSource[] Sources { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FindingSummaryStatus Status { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FindingSummaryResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::IAM::Role = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::KMS::Key = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::Function = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::LayerVersion = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::S3::Bucket = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::SQS::Queue = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FindingSummaryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHIVED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOLVED = 2,
	}
	
	/// <summary>
	/// Retrieves a list of resources that have been analyzed.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListAnalyzedResourcesRequest
	{
		
		/// <summary>
		/// Pattern: ^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AnalyzerArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ListAnalyzedResourcesRequestResourceType ResourceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListAnalyzedResourcesRequestResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::IAM::Role = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::KMS::Key = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::Function = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::LayerVersion = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::S3::Bucket = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::SQS::Queue = 5,
	}
	
	/// <summary>
	/// The criteria used to sort.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SortCriteria
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AttributeName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SortCriteriaOrderBy OrderBy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SortCriteriaOrderBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DESC = 1,
	}
	
	/// <summary>
	/// Retrieves a list of findings generated by the specified analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListFindingsRequest
	{
		
		/// <summary>
		/// Pattern: ^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AnalyzerArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FilterCriteriaMap Filter { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// The criteria used to sort.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SortCriteria Sort { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ReasonCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_SERVICE_ACCESS_DISABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELEGATED_ADMINISTRATOR_DEREGISTERED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION_DELETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVICE_LINKED_ROLE_CREATION_FAILED = 3,
	}
	
	/// <summary>
	/// Starts a scan of the policies applied to the specified resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartResourceScanRequest
	{
		
		/// <summary>
		/// Pattern: ^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// Pattern: arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
	}
	
	/// <summary>
	/// Adds a tag to the specified resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TagsMap Tags { get; set; }
	}
	
	/// <summary>
	/// Updates the specified archive rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateArchiveRuleRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FilterCriteriaMap Filter { get; set; }
	}
	
	/// <summary>
	/// Updates findings with the new values provided in the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFindingsRequest
	{
		
		/// <summary>
		/// Pattern: ^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AnalyzerArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FindingId[] Ids { get; set; }
		
		/// <summary>
		/// Pattern: arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateFindingsRequestStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateFindingsRequestStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHIVED = 1,
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Creates an analyzer for your account.
		/// CreateAnalyzer analyzer
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateAnalyzerResponse> CreateAnalyzerAsync(CreateAnalyzerBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateAnalyzerResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of analyzers.
		/// ListAnalyzers analyzer
		/// </summary>
		/// <param name="maxResults">The maximum number of results to return in the response.</param>
		/// <param name="nextToken">A token used for pagination of results returned.</param>
		/// <param name="type">The type of analyzer.</param>
		/// <returns>Success</returns>
		public async Task<ListAnalyzersResponse> ListAnalyzersAsync(int maxResults, string nextToken, Type type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&type=" + type;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListAnalyzersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an archive rule for the specified analyzer. Archive rules automatically archive findings that meet the criteria you define when you create the rule.
		/// CreateArchiveRule analyzer/{analyzerName}/archive-rule
		/// </summary>
		/// <param name="analyzerName">The name of the created analyzer.</param>
		/// <returns>Success</returns>
		public async Task CreateArchiveRuleAsync(string analyzerName, CreateArchiveRuleBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : Uri.EscapeDataString(analyzerName))+"/archive-rule";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of archive rules created for the specified analyzer.
		/// ListArchiveRules analyzer/{analyzerName}/archive-rule
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer to retrieve rules from.</param>
		/// <param name="maxResults">The maximum number of results to return in the request.</param>
		/// <param name="nextToken">A token used for pagination of results returned.</param>
		/// <returns>Success</returns>
		public async Task<ListArchiveRulesResponse> ListArchiveRulesAsync(string analyzerName, int maxResults, string nextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : Uri.EscapeDataString(analyzerName))+"/archive-rule&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListArchiveRulesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified analyzer. When you delete an analyzer, Access Analyzer is disabled for the account in the current or specific Region. All findings that were generated by the analyzer are deleted. You cannot undo this action.
		/// DeleteAnalyzer analyzer/{analyzerName}
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer to delete.</param>
		/// <param name="clientToken">A client token.</param>
		/// <returns>Success</returns>
		public async Task DeleteAnalyzerAsync(string analyzerName, string clientToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : Uri.EscapeDataString(analyzerName))+"&clientToken=" + (clientToken==null? "" : Uri.EscapeDataString(clientToken));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about the specified analyzer.
		/// GetAnalyzer analyzer/{analyzerName}
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer retrieved.</param>
		/// <returns>Success</returns>
		public async Task<GetAnalyzerResponse> GetAnalyzerAsync(string analyzerName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : Uri.EscapeDataString(analyzerName));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetAnalyzerResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified archive rule.
		/// DeleteArchiveRule analyzer/{analyzerName}/archive-rule/{ruleName}
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer that associated with the archive rule to delete.</param>
		/// <param name="clientToken">A client token.</param>
		/// <param name="ruleName">The name of the rule to delete.</param>
		/// <returns>Success</returns>
		public async Task DeleteArchiveRuleAsync(string analyzerName, string clientToken, string ruleName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : Uri.EscapeDataString(analyzerName))+"/archive-rule/"+ (ruleName==null? "" : Uri.EscapeDataString(ruleName))+"&clientToken=" + (clientToken==null? "" : Uri.EscapeDataString(clientToken));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about an archive rule.
		/// GetArchiveRule analyzer/{analyzerName}/archive-rule/{ruleName}
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer to retrieve rules from.</param>
		/// <param name="ruleName">The name of the rule to retrieve.</param>
		/// <returns>Success</returns>
		public async Task<GetArchiveRuleResponse> GetArchiveRuleAsync(string analyzerName, string ruleName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : Uri.EscapeDataString(analyzerName))+"/archive-rule/"+ (ruleName==null? "" : Uri.EscapeDataString(ruleName));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetArchiveRuleResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the criteria and values for the specified archive rule.
		/// UpdateArchiveRule analyzer/{analyzerName}/archive-rule/{ruleName}
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer to update the archive rules for.</param>
		/// <param name="ruleName">The name of the rule to update.</param>
		/// <returns>Success</returns>
		public async Task UpdateArchiveRuleAsync(string analyzerName, string ruleName, UpdateArchiveRuleBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : Uri.EscapeDataString(analyzerName))+"/archive-rule/"+ (ruleName==null? "" : Uri.EscapeDataString(ruleName));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about a resource that was analyzed.
		/// GetAnalyzedResource analyzed-resource#analyzerArn&resourceArn
		/// </summary>
		/// <param name="analyzerArn">The ARN of the analyzer to retrieve information from.</param>
		/// <param name="resourceArn">The ARN of the resource to retrieve information about.</param>
		/// <returns>Success</returns>
		public async Task<GetAnalyzedResourceResponse> GetAnalyzedResourceAsync(string analyzerArn, string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzed-resource#analyzerArn&resourceArn?analyzerArn=" + (analyzerArn==null? "" : Uri.EscapeDataString(analyzerArn))+"&resourceArn=" + (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetAnalyzedResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about the specified finding.
		/// GetFinding finding/{id}#analyzerArn
		/// </summary>
		/// <param name="analyzerArn">The ARN of the analyzer that generated the finding.</param>
		/// <param name="id">The ID of the finding to retrieve.</param>
		/// <returns>Success</returns>
		public async Task<GetFindingResponse> GetFindingAsync(string analyzerArn, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "finding/"+ (id==null? "" : Uri.EscapeDataString(id))+"#analyzerArn?analyzerArn=" + (analyzerArn==null? "" : Uri.EscapeDataString(analyzerArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetFindingResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of resources of the specified type that have been analyzed by the specified analyzer..
		/// ListAnalyzedResources analyzed-resource
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListAnalyzedResourcesResponse> ListAnalyzedResourcesAsync(string maxResults, string nextToken, ListAnalyzedResourcesBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzed-resource?maxResults=" + (maxResults==null? "" : Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListAnalyzedResourcesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of findings generated by the specified analyzer.
		/// ListFindings finding
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListFindingsResponse> ListFindingsAsync(string maxResults, string nextToken, ListFindingsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "finding?maxResults=" + (maxResults==null? "" : Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListFindingsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the status for the specified findings.
		/// UpdateFindings finding
		/// </summary>
		/// <returns>Success</returns>
		public async Task UpdateFindingsAsync(UpdateFindingsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "finding";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of tags applied to the specified resource.
		/// ListTagsForResource tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The ARN of the resource to retrieve tags from.</param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a tag to the specified resource.
		/// TagResource tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The ARN of the resource to add the tag to.</param>
		/// <returns>Success</returns>
		public async Task<TagResourceResponse> TagResourceAsync(string resourceArn, TagResourceBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<TagResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Immediately starts a scan of the policies applied to the specified resource.
		/// StartResourceScan resource/scan
		/// </summary>
		/// <returns>Success</returns>
		public async Task StartResourceScanAsync(StartResourceScanBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "resource/scan";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes a tag from the specified resource.
		/// UntagResource tags/{resourceArn}#tagKeys
		/// </summary>
		/// <param name="resourceArn">The ARN of the resource to remove the tag from.</param>
		/// <param name="tagKeys">The key for the tag to add.</param>
		/// <returns>Success</returns>
		public async Task<UntagResourceResponse> UntagResourceAsync(string resourceArn, String[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn))+"#tagKeys&"+String.Join("&", tagKeys.Select(z => $"tagKeys={z}"));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UntagResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateAnalyzerBody
	{
		
		/// <summary>
		/// The name of the analyzer to create.
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[A-Za-z][A-Za-z0-9_.-]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string AnalyzerName { get; set; }
		
		/// <summary>
		/// Specifies the archive rules to add for the analyzer. Archive rules automatically archive findings that meet the criteria you define for the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public InlineArchiveRule[] ArchiveRules { get; set; }
		
		/// <summary>
		/// A client token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// The tags to apply to the analyzer.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Tags { get; set; }
		
		/// <summary>
		/// The type of analyzer to create. Only ACCOUNT analyzers are supported. You can create only one analyzer per account per Region.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateAnalyzerBodyType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateAnalyzerBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCOUNT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateArchiveRuleBody
	{
		
		/// <summary>
		/// A client token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// The criteria for the rule.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Filter { get; set; }
		
		/// <summary>
		/// The name of the rule to create.
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[A-Za-z][A-Za-z0-9_.-]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string RuleName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateArchiveRuleBody
	{
		
		/// <summary>
		/// A client token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// A filter to match for the rules to update. Only rules that match the filter are updated.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Filter { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListAnalyzedResourcesBody
	{
		
		/// <summary>
		/// The ARN of the analyzer to retrieve a list of analyzed resources from.
		/// Pattern: ^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// The maximum number of results to return in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// A token used for pagination of results returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// The type of resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ListAnalyzedResourcesBodyResourceType ResourceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListAnalyzedResourcesBodyResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::IAM::Role = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::KMS::Key = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::Function = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::Lambda::LayerVersion = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::S3::Bucket = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS::SQS::Queue = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListFindingsBody
	{
		
		/// <summary>
		/// The ARN of the analyzer to retrieve findings from.
		/// Pattern: ^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// A filter to match for the findings to return.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Filter { get; set; }
		
		/// <summary>
		/// The maximum number of results to return in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// A token used for pagination of results returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// The criteria used to sort.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Sort { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFindingsBody
	{
		
		/// <summary>
		/// The ARN of the analyzer that generated the findings to update.
		/// Pattern: ^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// A client token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// The IDs of the findings to update.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FindingId[] Ids { get; set; }
		
		/// <summary>
		/// The ARN of the resource identified in the finding.
		/// Pattern: arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// The state represents the action to take to update the finding Status. Use <code>ARCHIVE</code> to change an Active finding to an Archived finding. Use <code>ACTIVE</code> to change an Archived finding to an Active finding.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateFindingsBodyStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateFindingsBodyStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHIVED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceBody
	{
		
		/// <summary>
		/// The tags to add to the resource.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartResourceScanBody
	{
		
		/// <summary>
		/// The ARN of the analyzer to use to scan the policies applied to the specified resource.
		/// Pattern: ^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// The ARN of the resource to scan.
		/// Pattern: arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
