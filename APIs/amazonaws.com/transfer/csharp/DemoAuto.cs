//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateServerResponse
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateServerRequest
	{
		
		/// <summary>
		/// Max length: 1600
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600)]
		public string Certificate { get; set; }
		
		/// <summary>
		/// The virtual private cloud (VPC) endpoint settings that are configured for your file transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server and resources only within your VPC. To control incoming internet traffic, invoke the <code>UpdateServer</code> API and attach an Elastic IP to your server's endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public EndpointDetails EndpointDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CreateServerRequestEndpointType EndpointType { get; set; }
		
		/// <summary>
		/// Max length: 4096
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(4096)]
		public string HostKey { get; set; }
		
		/// <summary>
		/// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. A server can have only one method of authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public IdentityProviderDetails IdentityProviderDetails { get; set; }
		
		/// <summary>
		/// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. For <code>SERVICE_MANAGED</code> authentication, the Secure Shell (SSH) public keys are stored with a user on the server instance. For <code>API_GATEWAY</code> authentication, your custom authentication method is implemented by using an API call. The server can have only one method of authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateServerRequestIdentityProviderType IdentityProviderType { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 20
		/// Pattern: arn:.*role/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=20)]
		public string LoggingRole { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 3
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(3)]
		public Protocol[] Protocols { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateServerRequestEndpointType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC_ENDPOINT = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateServerRequestIdentityProviderType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVICE_MANAGED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_GATEWAY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateUserResponse
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateUserRequest
	{
		
		/// <summary>
		/// Max length: 1024
		/// Pattern: ^$|/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024)]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CreateUserRequestHomeDirectoryType HomeDirectoryType { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public HomeDirectoryMapEntry[] HomeDirectoryMappings { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048)]
		public string Policy { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 20
		/// Pattern: arn:.*role/.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=20)]
		public string Role { get; set; }
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Pattern: ^ssh-rsa\s+[A-Za-z0-9+/]+[=]{0,3}(\s+.+)?\s*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048)]
		public string SshPublicKeyBody { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public Tag[] Tags { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateUserRequestHomeDirectoryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOGICAL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteServerRequest
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteSshPublicKeyRequest
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Max length: 21
		/// Min length: 21
		/// Pattern: ^key-[0-9a-f]{17}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(21, MinimumLength=21)]
		public string SshPublicKeyId { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteUserRequest
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeServerResponse
	{
		
		/// <summary>
		/// Describes the properties of a file transfer protocol-enabled server that was specified. Information returned includes the following: the server Amazon Resource Name (ARN), the certificate ARN (if the FTPS protocol was selected), the endpoint type and details, the authentication configuration and type, the logging role, the file transfer protocol or protocols, the server ID and state, and assigned tags or metadata.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedServer Server { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeServerRequest
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeUserResponse
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Returns properties of the user that you want to describe.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedUser User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeUserRequest
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	/// <summary>
	/// Identifies the user, the file transfer protocol-enabled server they belong to, and the identifier of the SSH public key associated with that user. A user can have more than one key on each server that they are associated with.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImportSshPublicKeyResponse
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Max length: 21
		/// Min length: 21
		/// Pattern: ^key-[0-9a-f]{17}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(21, MinimumLength=21)]
		public string SshPublicKeyId { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ImportSshPublicKeyRequest
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Pattern: ^ssh-rsa\s+[A-Za-z0-9+/]+[=]{0,3}(\s+.+)?\s*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048)]
		public string SshPublicKeyBody { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListServersResponse
	{
		
		/// <summary>
		/// Max length: 6144
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(6144, MinimumLength=1)]
		public string NextToken { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedServer[] Servers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListServersRequest
	{
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 1000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 1000)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// Max length: 6144
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(6144, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsForResourceResponse
	{
		
		/// <summary>
		/// Max length: 1600
		/// Min length: 20
		/// Pattern: arn:.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600, MinimumLength=20)]
		public string Arn { get; set; }
		
		/// <summary>
		/// Max length: 6144
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(6144, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsForResourceRequest
	{
		
		/// <summary>
		/// Max length: 1600
		/// Min length: 20
		/// Pattern: arn:.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600, MinimumLength=20)]
		public string Arn { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 1000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 1000)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// Max length: 6144
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(6144, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListUsersResponse
	{
		
		/// <summary>
		/// Max length: 6144
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(6144, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedUser[] Users { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListUsersRequest
	{
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 1000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 1000)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// Max length: 6144
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(6144, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartServerRequest
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StopServerRequest
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Max length: 1600
		/// Min length: 20
		/// Pattern: arn:.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600, MinimumLength=20)]
		public string Arn { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TestIdentityProviderResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Response { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int StatusCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255)]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TestIdentityProviderRequest
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TestIdentityProviderRequestServerProtocol ServerProtocol { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Pattern: ^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32)]
		public string SourceIp { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048)]
		public string UserPassword { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TestIdentityProviderRequestServerProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SFTP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FTP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FTPS = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UntagResourceRequest
	{
		
		/// <summary>
		/// Max length: 1600
		/// Min length: 20
		/// Pattern: arn:.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600, MinimumLength=20)]
		public string Arn { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public TagKey[] TagKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateServerResponse
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateServerRequest
	{
		
		/// <summary>
		/// Max length: 1600
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600)]
		public string Certificate { get; set; }
		
		/// <summary>
		/// The virtual private cloud (VPC) endpoint settings that are configured for your file transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server and resources only within your VPC. To control incoming internet traffic, invoke the <code>UpdateServer</code> API and attach an Elastic IP to your server's endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public EndpointDetails EndpointDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateServerRequestEndpointType EndpointType { get; set; }
		
		/// <summary>
		/// Max length: 4096
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(4096)]
		public string HostKey { get; set; }
		
		/// <summary>
		/// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. A server can have only one method of authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public IdentityProviderDetails IdentityProviderDetails { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Pattern: ^$|arn:.*role/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048)]
		public string LoggingRole { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 3
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(3)]
		public Protocol[] Protocols { get; set; }
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateServerRequestEndpointType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC_ENDPOINT = 2,
	}
	
	/// <summary>
	///  <code>UpdateUserResponse</code> returns the user name and file transfer protocol-enabled server identifier for the request to update a user's properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateUserResponse
	{
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateUserRequest
	{
		
		/// <summary>
		/// Max length: 1024
		/// Pattern: ^$|/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024)]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateUserRequestHomeDirectoryType HomeDirectoryType { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public HomeDirectoryMapEntry[] HomeDirectoryMappings { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048)]
		public string Policy { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 20
		/// Pattern: arn:.*role/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=20)]
		public string Role { get; set; }
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateUserRequestHomeDirectoryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOGICAL = 1,
	}
	
	/// <summary>
	/// The virtual private cloud (VPC) endpoint settings that are configured for your file transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server and resources only within your VPC. To control incoming internet traffic, invoke the <code>UpdateServer</code> API and attach an Elastic IP to your server's endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EndpointDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AddressAllocationId[] AddressAllocationIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SubnetId[] SubnetIds { get; set; }
		
		/// <summary>
		/// Max length: 22
		/// Min length: 22
		/// Pattern: ^vpce-[0-9a-f]{17}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(22, MinimumLength=22)]
		public string VpcEndpointId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum EndpointType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC_ENDPOINT = 2,
	}
	
	/// <summary>
	/// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. A server can have only one method of authentication.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class IdentityProviderDetails
	{
		
		/// <summary>
		/// Max length: 255
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255)]
		public string Url { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 20
		/// Pattern: arn:.*role/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=20)]
		public string InvocationRole { get; set; }
	}
	
	/// <summary>
	/// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. For <code>SERVICE_MANAGED</code> authentication, the Secure Shell (SSH) public keys are stored with a user on the server instance. For <code>API_GATEWAY</code> authentication, your custom authentication method is implemented by using an API call. The server can have only one method of authentication.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum IdentityProviderType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVICE_MANAGED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_GATEWAY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum HomeDirectoryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOGICAL = 1,
	}
	
	/// <summary>
	/// Describes the properties of a file transfer protocol-enabled server that was specified. Information returned includes the following: the server Amazon Resource Name (ARN), the certificate ARN (if the FTPS protocol was selected), the endpoint type and details, the authentication configuration and type, the logging role, the file transfer protocol or protocols, the server ID and state, and assigned tags or metadata.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribedServer
	{
		
		/// <summary>
		/// Max length: 1600
		/// Min length: 20
		/// Pattern: arn:.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600, MinimumLength=20)]
		public string Arn { get; set; }
		
		/// <summary>
		/// Max length: 1600
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600)]
		public string Certificate { get; set; }
		
		/// <summary>
		/// The virtual private cloud (VPC) endpoint settings that are configured for your file transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server and resources only within your VPC. To control incoming internet traffic, invoke the <code>UpdateServer</code> API and attach an Elastic IP to your server's endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public EndpointDetails EndpointDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribedServerEndpointType EndpointType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyFingerprint { get; set; }
		
		/// <summary>
		/// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. A server can have only one method of authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public IdentityProviderDetails IdentityProviderDetails { get; set; }
		
		/// <summary>
		/// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. For <code>SERVICE_MANAGED</code> authentication, the Secure Shell (SSH) public keys are stored with a user on the server instance. For <code>API_GATEWAY</code> authentication, your custom authentication method is implemented by using an API call. The server can have only one method of authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DescribedServerIdentityProviderType IdentityProviderType { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 20
		/// Pattern: arn:.*role/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=20)]
		public string LoggingRole { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 3
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(3)]
		public Protocol[] Protocols { get; set; }
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// <p>Describes the condition of a file transfer protocol-enabled server with respect to its ability to perform file operations. There are six possible states: <code>OFFLINE</code>, <code>ONLINE</code>, <code>STARTING</code>, <code>STOPPING</code>, <code>START_FAILED</code>, and <code>STOP_FAILED</code>.</p> <p> <code>OFFLINE</code> indicates that the server exists, but that it is not available for file operations. <code>ONLINE</code> indicates that the server is available to perform file operations. <code>STARTING</code> indicates that the server's was instantiated, but the server is not yet available to perform file operations. Under normal conditions, it can take a couple of minutes for the server to be completely operational. Both <code>START_FAILED</code> and <code>STOP_FAILED</code> are error conditions.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DescribedServerState State { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> UserCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribedServerEndpointType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC_ENDPOINT = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribedServerIdentityProviderType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVICE_MANAGED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_GATEWAY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribedServerState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFFLINE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONLINE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		START_FAILED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOP_FAILED = 5,
	}
	
	/// <summary>
	/// Returns properties of the user that you want to describe.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribedUser
	{
		
		/// <summary>
		/// Max length: 1600
		/// Min length: 20
		/// Pattern: arn:.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600, MinimumLength=20)]
		public string Arn { get; set; }
		
		/// <summary>
		/// Max length: 1024
		/// Pattern: ^$|/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024)]
		public string HomeDirectory { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public HomeDirectoryMapEntry[] HomeDirectoryMappings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribedUserHomeDirectoryType HomeDirectoryType { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048)]
		public string Policy { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 20
		/// Pattern: arn:.*role/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=20)]
		public string Role { get; set; }
		
		/// <summary>
		/// Maximum items: 5
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MaxLength(5)]
		public SshPublicKey[] SshPublicKeys { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public Tag[] Tags { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribedUserHomeDirectoryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOGICAL = 1,
	}
	
	/// <summary>
	/// <p>Describes the condition of a file transfer protocol-enabled server with respect to its ability to perform file operations. There are six possible states: <code>OFFLINE</code>, <code>ONLINE</code>, <code>STARTING</code>, <code>STOPPING</code>, <code>START_FAILED</code>, and <code>STOP_FAILED</code>.</p> <p> <code>OFFLINE</code> indicates that the server exists, but that it is not available for file operations. <code>ONLINE</code> indicates that the server is available to perform file operations. <code>STARTING</code> indicates that the server's was instantiated, but the server is not yet available to perform file operations. Under normal conditions, it can take a couple of minutes for the server to be completely operational. Both <code>START_FAILED</code> and <code>STOP_FAILED</code> are error conditions.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum State
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFFLINE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONLINE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		START_FAILED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOP_FAILED = 5,
	}
	
	/// <summary>
	/// Represents an object that contains entries and a targets for <code>HomeDirectoryMappings</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class HomeDirectoryMapEntry
	{
		
		/// <summary>
		/// Max length: 1024
		/// Pattern: ^/.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024)]
		public string Entry { get; set; }
		
		/// <summary>
		/// Max length: 1024
		/// Pattern: ^/.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024)]
		public string Target { get; set; }
	}
	
	/// <summary>
	/// Returns properties of a file transfer protocol-enabled server that was specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListedServer
	{
		
		/// <summary>
		/// Max length: 1600
		/// Min length: 20
		/// Pattern: arn:.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600, MinimumLength=20)]
		public string Arn { get; set; }
		
		/// <summary>
		/// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. For <code>SERVICE_MANAGED</code> authentication, the Secure Shell (SSH) public keys are stored with a user on the server instance. For <code>API_GATEWAY</code> authentication, your custom authentication method is implemented by using an API call. The server can have only one method of authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ListedServerIdentityProviderType IdentityProviderType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ListedServerEndpointType EndpointType { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 20
		/// Pattern: arn:.*role/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=20)]
		public string LoggingRole { get; set; }
		
		/// <summary>
		/// Max length: 19
		/// Min length: 19
		/// Pattern: ^s-([0-9a-f]{17})$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(19, MinimumLength=19)]
		public string ServerId { get; set; }
		
		/// <summary>
		/// <p>Describes the condition of a file transfer protocol-enabled server with respect to its ability to perform file operations. There are six possible states: <code>OFFLINE</code>, <code>ONLINE</code>, <code>STARTING</code>, <code>STOPPING</code>, <code>START_FAILED</code>, and <code>STOP_FAILED</code>.</p> <p> <code>OFFLINE</code> indicates that the server exists, but that it is not available for file operations. <code>ONLINE</code> indicates that the server is available to perform file operations. <code>STARTING</code> indicates that the server's was instantiated, but the server is not yet available to perform file operations. Under normal conditions, it can take a couple of minutes for the server to be completely operational. Both <code>START_FAILED</code> and <code>STOP_FAILED</code> are error conditions.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ListedServerState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> UserCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListedServerIdentityProviderType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVICE_MANAGED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_GATEWAY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListedServerEndpointType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC_ENDPOINT = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListedServerState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFFLINE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONLINE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		START_FAILED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOP_FAILED = 5,
	}
	
	/// <summary>
	/// Returns properties of the user that you specify.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListedUser
	{
		
		/// <summary>
		/// Max length: 1600
		/// Min length: 20
		/// Pattern: arn:.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1600, MinimumLength=20)]
		public string Arn { get; set; }
		
		/// <summary>
		/// Max length: 1024
		/// Pattern: ^$|/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024)]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ListedUserHomeDirectoryType HomeDirectoryType { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 20
		/// Pattern: arn:.*role/.*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=20)]
		public string Role { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SshPublicKeyCount { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 3
		/// Pattern: ^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=3)]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ListedUserHomeDirectoryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOGICAL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum Protocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SFTP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FTP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FTPS = 2,
	}
	
	/// <summary>
	/// Provides information about the public Secure Shell (SSH) key that is associated with a user account for the specific file transfer protocol-enabled server (as identified by <code>ServerId</code>). The information returned includes the date the key was imported, the public key contents, and the public key ID. A user can store more than one SSH public key associated with their user name on a specific server.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SshPublicKey
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset DateImported { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Pattern: ^ssh-rsa\s+[A-Za-z0-9+/]+[=]{0,3}(\s+.+)?\s*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048)]
		public string SshPublicKeyBody { get; set; }
		
		/// <summary>
		/// Max length: 21
		/// Min length: 21
		/// Pattern: ^key-[0-9a-f]{17}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(21, MinimumLength=21)]
		public string SshPublicKeyId { get; set; }
	}
	
	/// <summary>
	/// Creates a key-value pair for a specific resource. Tags are metadata that you can use to search for and group a resource for various purposes. You can apply tags to servers, users, and roles. A tag key can take more than one value. For example, to group servers for accounting purposes, you might create a tag called <code>Group</code> and assign the values <code>Research</code> and <code>Accounting</code> to that group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Tag
	{
		
		/// <summary>
		/// Max length: 128
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128)]
		public string Key { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256)]
		public string Value { get; set; }
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Instantiates an autoscaling virtual server based on the selected file transfer protocol in AWS. When you make updates to your file transfer protocol-enabled server or when you work with users, use the service-generated <code>ServerId</code> property that is assigned to the newly created server.
		/// CreateServer /#X-Amz-Target=TransferService.CreateServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateServerResponse> CreateServerAsync(CreateServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.CreateServer";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateServerResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a user and associates them with an existing file transfer protocol-enabled server. You can only create and associate users with servers that have the <code>IdentityProviderType</code> set to <code>SERVICE_MANAGED</code>. Using parameters for <code>CreateUser</code>, you can specify the user name, set the home directory, store the user's public key, and assign the user's AWS Identity and Access Management (IAM) role. You can also optionally add a scope-down policy, and assign metadata with tags that can be used to group and search for users.
		/// CreateUser /#X-Amz-Target=TransferService.CreateUser
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateUserResponse> CreateUserAsync(CreateUserRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.CreateUser";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateUserResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes the file transfer protocol-enabled server that you specify.</p> <p>No response returns from this operation.</p>
		/// DeleteServer /#X-Amz-Target=TransferService.DeleteServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteServerAsync(DeleteServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.DeleteServer";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a user's Secure Shell (SSH) public key.</p> <p>No response is returned from this operation.</p>
		/// DeleteSshPublicKey /#X-Amz-Target=TransferService.DeleteSshPublicKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteSshPublicKeyAsync(DeleteSshPublicKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.DeleteSshPublicKey";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes the user belonging to a file transfer protocol-enabled server you specify.</p> <p>No response returns from this operation.</p> <note> <p>When you delete a user from a server, the user's information is lost.</p> </note>
		/// DeleteUser /#X-Amz-Target=TransferService.DeleteUser
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteUserAsync(DeleteUserRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.DeleteUser";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Describes a file transfer protocol-enabled server that you specify by passing the <code>ServerId</code> parameter.</p> <p>The response contains a description of a server's properties. When you set <code>EndpointType</code> to VPC, the response will contain the <code>EndpointDetails</code>.</p>
		/// DescribeServer /#X-Amz-Target=TransferService.DescribeServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeServerResponse> DescribeServerAsync(DescribeServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.DescribeServer";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeServerResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Describes the user assigned to the specific file transfer protocol-enabled server, as identified by its <code>ServerId</code> property.</p> <p>The response from this call returns the properties of the user associated with the <code>ServerId</code> value that was specified.</p>
		/// DescribeUser /#X-Amz-Target=TransferService.DescribeUser
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeUserResponse> DescribeUserAsync(DescribeUserRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.DescribeUser";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeUserResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Adds a Secure Shell (SSH) public key to a user account identified by a <code>UserName</code> value assigned to the specific file transfer protocol-enabled server, identified by <code>ServerId</code>.</p> <p>The response returns the <code>UserName</code> value, the <code>ServerId</code> value, and the name of the <code>SshPublicKeyId</code>.</p>
		/// ImportSshPublicKey /#X-Amz-Target=TransferService.ImportSshPublicKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ImportSshPublicKeyResponse> ImportSshPublicKeyAsync(ImportSshPublicKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.ImportSshPublicKey";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ImportSshPublicKeyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the file transfer protocol-enabled servers that are associated with your AWS account.
		/// ListServers /#X-Amz-Target=TransferService.ListServers
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListServersResponse> ListServersAsync(string MaxResults, string NextToken, ListServersRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.ListServers?MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListServersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all of the tags associated with the Amazon Resource Number (ARN) you specify. The resource can be a user, server, or role.
		/// ListTagsForResource /#X-Amz-Target=TransferService.ListTagsForResource
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string MaxResults, string NextToken, ListTagsForResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.ListTagsForResource?MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the users for a file transfer protocol-enabled server that you specify by passing the <code>ServerId</code> parameter.
		/// ListUsers /#X-Amz-Target=TransferService.ListUsers
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListUsersResponse> ListUsersAsync(string MaxResults, string NextToken, ListUsersRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.ListUsers?MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListUsersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Changes the state of a file transfer protocol-enabled server from <code>OFFLINE</code> to <code>ONLINE</code>. It has no impact on a server that is already <code>ONLINE</code>. An <code>ONLINE</code> server can accept and process file transfer jobs.</p> <p>The state of <code>STARTING</code> indicates that the server is in an intermediate state, either not fully able to respond, or not fully online. The values of <code>START_FAILED</code> can indicate an error condition.</p> <p>No response is returned from this call.</p>
		/// StartServer /#X-Amz-Target=TransferService.StartServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task StartServerAsync(StartServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.StartServer";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Changes the state of a file transfer protocol-enabled server from <code>ONLINE</code> to <code>OFFLINE</code>. An <code>OFFLINE</code> server cannot accept and process file transfer jobs. Information tied to your server, such as server and user properties, are not affected by stopping your server. Stopping the server will not reduce or impact your file transfer protocol endpoint billing.</p> <p>The state of <code>STOPPING</code> indicates that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of <code>STOP_FAILED</code> can indicate an error condition.</p> <p>No response is returned from this call.</p>
		/// StopServer /#X-Amz-Target=TransferService.StopServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task StopServerAsync(StopServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.StopServer";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Attaches a key-value pair to a resource, as identified by its Amazon Resource Name (ARN). Resources are users, servers, roles, and other entities.</p> <p>There is no response returned from this call.</p>
		/// TagResource /#X-Amz-Target=TransferService.TagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task TagResourceAsync(TagResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.TagResource";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// If the <code>IdentityProviderType</code> of a file transfer protocol-enabled server is <code>API_Gateway</code>, tests whether your API Gateway is set up successfully. We highly recommend that you call this operation to test your authentication method as soon as you create your server. By doing so, you can troubleshoot issues with the API Gateway integration to ensure that your users can successfully use the service.
		/// TestIdentityProvider /#X-Amz-Target=TransferService.TestIdentityProvider
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TestIdentityProviderResponse> TestIdentityProviderAsync(TestIdentityProviderRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.TestIdentityProvider";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<TestIdentityProviderResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Detaches a key-value pair from a resource, as identified by its Amazon Resource Name (ARN). Resources are users, servers, roles, and other entities.</p> <p>No response is returned from this call.</p>
		/// UntagResource /#X-Amz-Target=TransferService.UntagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task UntagResourceAsync(UntagResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.UntagResource";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Updates the file transfer protocol-enabled server's properties after that server has been created.</p> <p>The <code>UpdateServer</code> call returns the <code>ServerId</code> of the server you updated.</p>
		/// UpdateServer /#X-Amz-Target=TransferService.UpdateServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateServerResponse> UpdateServerAsync(UpdateServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.UpdateServer";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateServerResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Assigns new properties to a user. Parameters you pass modify any or all of the following: the home directory, role, and policy for the <code>UserName</code> and <code>ServerId</code> you specify.</p> <p>The response returns the <code>ServerId</code> and the <code>UserName</code> for the updated user.</p>
		/// UpdateUser /#X-Amz-Target=TransferService.UpdateUser
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateUserResponse> UpdateUserAsync(UpdateUserRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=TransferService.UpdateUser";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateUserResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
