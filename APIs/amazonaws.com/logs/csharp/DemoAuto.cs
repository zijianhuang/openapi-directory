//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AssociateKmsKeyRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256)]
		public string KmsKeyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CancelExportTaskRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string TaskId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateExportTaskResponse
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string TaskId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateExportTaskRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string TaskName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogStreamNamePrefix { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public int From { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public int To { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string Destination { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationPrefix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateLogGroupRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256)]
		public string KmsKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateLogStreamRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogStreamName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteDestinationRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string DestinationName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteLogGroupRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteLogStreamRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogStreamName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteMetricFilterRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string FilterName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteQueryDefinitionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Success { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteQueryDefinitionRequest
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=0)]
		public string QueryDefinitionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteResourcePolicyRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string PolicyName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteRetentionPolicyRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteSubscriptionFilterRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string FilterName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeDestinationsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Destination[] Destinations { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeDestinationsRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string DestinationNamePrefix { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 50)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeExportTasksResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ExportTask[] ExportTasks { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeExportTasksRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string TaskId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribeExportTasksRequestStatusCode StatusCode { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 50)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeExportTasksRequestStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_CANCEL = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeLogGroupsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LogGroup[] LogGroups { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeLogGroupsRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupNamePrefix { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 50)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeLogStreamsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LogStream[] LogStreams { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeLogStreamsRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogStreamNamePrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribeLogStreamsRequestOrderBy OrderBy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Descending { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 50)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeLogStreamsRequestOrderBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogStreamName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastEventTime = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeMetricFiltersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public MetricFilter[] MetricFilters { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeMetricFiltersRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string FilterNamePrefix { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 50)]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		/// <summary>
		/// The name of the CloudWatch metric to which the monitored log information should be published. For example, you may publish to a metric called ErrorCount.
		/// Max length: 255
		/// Pattern: [^:*$]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255)]
		public string MetricName { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Pattern: [^:*$]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255)]
		public string MetricNamespace { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeQueriesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public QueryInfo[] Queries { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeQueriesRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DescribeQueriesRequestStatus Status { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 1000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 1000)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DescribeQueriesRequestStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Complete = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cancelled = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeQueryDefinitionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public QueryDefinition[] QueryDefinitions { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeQueryDefinitionsRequest
	{
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^([^:*\/]+\/?)*[^:*\/]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string QueryDefinitionNamePrefix { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 1000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 1000)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeResourcePoliciesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResourcePolicy[] ResourcePolicies { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeResourcePoliciesRequest
	{
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 50)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeSubscriptionFiltersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SubscriptionFilter[] SubscriptionFilters { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeSubscriptionFiltersRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string FilterNamePrefix { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 50)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DisassociateKmsKeyRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FilterLogEventsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FilteredLogEvent[] Events { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SearchedLogStream[] SearchedLogStreams { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FilterLogEventsRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public LogStreamName[] LogStreamNames { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogStreamNamePrefix { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> StartTime { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> EndTime { get; set; }
		
		/// <summary>
		/// A symbolic description of how CloudWatch Logs should interpret the data in each log event. For example, a log event may contain timestamps, IP addresses, strings, and so on. You use the filter pattern to specify what to look for in the log event message.
		/// Max length: 1024
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024, MinimumLength=0)]
		public string FilterPattern { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 10000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 10000)]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Interleaved { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetLogEventsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public OutputLogEvent[] Events { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextForwardToken { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextBackwardToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetLogEventsRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogStreamName { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> StartTime { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> EndTime { get; set; }
		
		/// <summary>
		/// The token for the next set of items to return. The token expires after 24 hours.
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 10000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 10000)]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> StartFromHead { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetLogGroupFieldsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LogGroupField[] LogGroupFields { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetLogGroupFieldsRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Time { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetLogRecordResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LogRecord LogRecord { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetLogRecordRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string LogRecordPointer { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetQueryResultsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResultRows[] Results { get; set; }
		
		/// <summary>
		/// Contains the number of log events scanned by the query, the number of log events that matched the query criteria, and the total number of bytes in the log events that were scanned.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public QueryStatistics Statistics { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GetQueryResultsResponseStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GetQueryResultsResponseStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Complete = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cancelled = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetQueryResultsRequest
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=0)]
		public string QueryId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsLogGroupResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsLogGroupRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutDestinationResponse
	{
		
		/// <summary>
		/// Represents a cross-account destination that receives subscription log events.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Destination Destination { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutDestinationRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string DestinationName { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string TargetArn { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string RoleArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutDestinationPolicyRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string DestinationName { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string AccessPolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutLogEventsResponse
	{
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string NextSequenceToken { get; set; }
		
		/// <summary>
		/// Represents the rejected events.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RejectedLogEventsInfo RejectedLogEventsInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutLogEventsRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogStreamName { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 10000
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(10000)]
		public InputLogEvent[] LogEvents { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string SequenceToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutMetricFilterRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string FilterName { get; set; }
		
		/// <summary>
		/// A symbolic description of how CloudWatch Logs should interpret the data in each log event. For example, a log event may contain timestamps, IP addresses, strings, and so on. You use the filter pattern to specify what to look for in the log event message.
		/// Max length: 1024
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024, MinimumLength=0)]
		public string FilterPattern { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1)]
		public MetricTransformation[] MetricTransformations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutQueryDefinitionResponse
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=0)]
		public string QueryDefinitionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutQueryDefinitionRequest
	{
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^([^:*\/]+\/?)*[^:*\/]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=0)]
		public string QueryDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LogGroupName[] LogGroupNames { get; set; }
		
		/// <summary>
		/// Max length: 10000
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(10000, MinimumLength=1)]
		public string QueryString { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutResourcePolicyResponse
	{
		
		/// <summary>
		/// A policy enabling one or more entities to put logs to a log group in this account.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ResourcePolicy ResourcePolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutResourcePolicyRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string PolicyName { get; set; }
		
		/// <summary>
		/// Max length: 5120
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(5120, MinimumLength=1)]
		public string PolicyDocument { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutRetentionPolicyRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// The number of days to retain the log events in the specified log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int RetentionInDays { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PutSubscriptionFilterRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string FilterName { get; set; }
		
		/// <summary>
		/// A symbolic description of how CloudWatch Logs should interpret the data in each log event. For example, a log event may contain timestamps, IP addresses, strings, and so on. You use the filter pattern to specify what to look for in the log event message.
		/// Max length: 1024
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024, MinimumLength=0)]
		public string FilterPattern { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string DestinationArn { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string RoleArn { get; set; }
		
		/// <summary>
		/// The method used to distribute log data to the destination, which can be either random or grouped by log stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PutSubscriptionFilterRequestDistribution Distribution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PutSubscriptionFilterRequestDistribution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Random = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ByLogStream = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartQueryResponse
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=0)]
		public string QueryId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartQueryRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LogGroupName[] LogGroupNames { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public int StartTime { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public int EndTime { get; set; }
		
		/// <summary>
		/// Max length: 10000
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(10000, MinimumLength=0)]
		public string QueryString { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 10000
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 10000)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StopQueryResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Success { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StopQueryRequest
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=0)]
		public string QueryId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagLogGroupRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TestMetricFilterResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public MetricFilterMatchRecord[] Matches { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TestMetricFilterRequest
	{
		
		/// <summary>
		/// A symbolic description of how CloudWatch Logs should interpret the data in each log event. For example, a log event may contain timestamps, IP addresses, strings, and so on. You use the filter pattern to specify what to look for in the log event message.
		/// Max length: 1024
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024, MinimumLength=0)]
		public string FilterPattern { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public EventMessage[] LogEventMessages { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UntagLogGroupRequest
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public TagKey[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ExportTaskStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_CANCEL = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum OrderBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogStreamName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastEventTime = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum QueryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Complete = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cancelled = 4,
	}
	
	/// <summary>
	/// Represents a cross-account destination that receives subscription log events.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Destination
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string DestinationName { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string TargetArn { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string RoleArn { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string AccessPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CreationTime { get; set; }
	}
	
	/// <summary>
	/// The method used to distribute log data to the destination, which can be either random or grouped by log stream.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum Distribution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Random = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ByLogStream = 1,
	}
	
	/// <summary>
	/// Represents the status of an export task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ExportTaskStatus
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ExportTaskStatusCode Code { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ExportTaskStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_CANCEL = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 5,
	}
	
	/// <summary>
	/// Represents the status of an export task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ExportTaskExecutionInfo
	{
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CreationTime { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CompletionTime { get; set; }
	}
	
	/// <summary>
	/// Represents an export task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ExportTask
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string TaskId { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string TaskName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> From { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> To { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string Destination { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationPrefix { get; set; }
		
		/// <summary>
		/// Represents the status of an export task.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ExportTaskStatus Status { get; set; }
		
		/// <summary>
		/// Represents the status of an export task.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ExportTaskExecutionInfo ExecutionInfo { get; set; }
	}
	
	/// <summary>
	/// Represents a matched event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FilteredLogEvent
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogStreamName { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Timestamp { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string Message { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> IngestionTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EventId { get; set; }
	}
	
	/// <summary>
	/// Contains the number of log events scanned by the query, the number of log events that matched the query criteria, and the total number of bytes in the log events that were scanned.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class QueryStatistics
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> RecordsMatched { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> RecordsScanned { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> BytesScanned { get; set; }
	}
	
	/// <summary>
	/// Represents a log event, which is a record of activity that was recorded by the application or resource being monitored.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class InputLogEvent
	{
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public int Timestamp { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Represents a log group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class LogGroup
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CreationTime { get; set; }
		
		/// <summary>
		/// The number of days to retain the log events in the specified log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> RetentionInDays { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MetricFilterCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> StoredBytes { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256)]
		public string KmsKeyId { get; set; }
	}
	
	/// <summary>
	/// The fields contained in log events found by a <code>GetLogGroupFields</code> operation, along with the percentage of queried log events in which each field appears.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class LogGroupField
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public System.Nullable<System.Int32> Percent { get; set; }
	}
	
	/// <summary>
	/// Represents a log stream, which is a sequence of log events from a single emitter of logs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class LogStream
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogStreamName { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CreationTime { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> FirstEventTimestamp { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> LastEventTimestamp { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> LastIngestionTime { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string UploadSequenceToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> StoredBytes { get; set; }
	}
	
	/// <summary>
	/// Metric filters express how CloudWatch Logs would extract metric observations from ingested log events and transform them into metric data in a CloudWatch metric.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MetricFilter
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string FilterName { get; set; }
		
		/// <summary>
		/// A symbolic description of how CloudWatch Logs should interpret the data in each log event. For example, a log event may contain timestamps, IP addresses, strings, and so on. You use the filter pattern to specify what to look for in the log event message.
		/// Max length: 1024
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024, MinimumLength=0)]
		public string FilterPattern { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1)]
		public MetricTransformation[] MetricTransformations { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CreationTime { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
	}
	
	/// <summary>
	/// Represents a matched event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MetricFilterMatchRecord
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> EventNumber { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string EventMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExtractedValues ExtractedValues { get; set; }
	}
	
	/// <summary>
	/// Indicates how to transform ingested log events to metric data in a CloudWatch metric.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MetricTransformation
	{
		
		/// <summary>
		/// The name of the CloudWatch metric to which the monitored log information should be published. For example, you may publish to a metric called ErrorCount.
		/// Max length: 255
		/// Pattern: [^:*$]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255)]
		public string MetricName { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Pattern: [^:*$]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255)]
		public string MetricNamespace { get; set; }
		
		/// <summary>
		/// The value to publish to the CloudWatch metric. For example, if you're counting the occurrences of a term like "Error", the value is "1" for each occurrence. If you're counting the bytes transferred, the value is the value in the log event.
		/// Max length: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(100)]
		public string MetricValue { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> DefaultValue { get; set; }
	}
	
	/// <summary>
	/// Represents a log event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class OutputLogEvent
	{
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Timestamp { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string Message { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> IngestionTime { get; set; }
	}
	
	/// <summary>
	/// Represents the rejected events.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RejectedLogEventsInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TooNewLogEventStartIndex { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TooOldLogEventEndIndex { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ExpiredLogEventEndIndex { get; set; }
	}
	
	/// <summary>
	/// A policy enabling one or more entities to put logs to a log group in this account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ResourcePolicy
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string PolicyName { get; set; }
		
		/// <summary>
		/// Max length: 5120
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(5120, MinimumLength=1)]
		public string PolicyDocument { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> LastUpdatedTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class QueryDefinition
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=0)]
		public string QueryDefinitionId { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^([^:*\/]+\/?)*[^:*\/]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// Max length: 10000
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(10000, MinimumLength=1)]
		public string QueryString { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> LastModified { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LogGroupName[] LogGroupNames { get; set; }
	}
	
	/// <summary>
	/// Information about one CloudWatch Logs Insights query that matches the request in a <code>DescribeQueries</code> operation. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class QueryInfo
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=0)]
		public string QueryId { get; set; }
		
		/// <summary>
		/// Max length: 10000
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(10000, MinimumLength=0)]
		public string QueryString { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public QueryInfoStatus Status { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CreateTime { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum QueryInfoStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Complete = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cancelled = 4,
	}
	
	/// <summary>
	/// <p>Contains one field from one log event returned by a CloudWatch Logs Insights query, along with the value of that field.</p> <p>For more information about the fields that are generated by CloudWatch logs, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields</a>.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ResultField
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Field { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents the search status of a log stream.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SearchedLogStream
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogStreamName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SearchedCompletely { get; set; }
	}
	
	/// <summary>
	/// Represents a subscription filter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SubscriptionFilter
	{
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [^:*]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string FilterName { get; set; }
		
		/// <summary>
		/// Max length: 512
		/// Min length: 1
		/// Pattern: [\.\-_/#A-Za-z0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(512, MinimumLength=1)]
		public string LogGroupName { get; set; }
		
		/// <summary>
		/// A symbolic description of how CloudWatch Logs should interpret the data in each log event. For example, a log event may contain timestamps, IP addresses, strings, and so on. You use the filter pattern to specify what to look for in the log event message.
		/// Max length: 1024
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024, MinimumLength=0)]
		public string FilterPattern { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string DestinationArn { get; set; }
		
		/// <summary>
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string RoleArn { get; set; }
		
		/// <summary>
		/// The method used to distribute log data to the destination, which can be either random or grouped by log stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SubscriptionFilterDistribution Distribution { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> CreationTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SubscriptionFilterDistribution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Random = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ByLogStream = 1,
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// <p>Associates the specified AWS Key Management Service (AWS KMS) customer master key (CMK) with the specified log group.</p> <p>Associating an AWS KMS CMK with a log group overrides any existing associations between the log group and a CMK. After a CMK is associated with a log group, all newly ingested data for the log group is encrypted using the CMK. This association is stored as long as the data encrypted with the CMK is still within Amazon CloudWatch Logs. This enables Amazon CloudWatch Logs to decrypt this data whenever it is requested.</p> <note> <p> <b>Important:</b> CloudWatch Logs supports only symmetric CMKs. Do not use an associate an asymmetric CMK with your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric Keys</a>.</p> </note> <p>Note that it can take up to 5 minutes for this operation to take effect.</p> <p>If you attempt to associate a CMK with a log group but the CMK does not exist or the CMK is disabled, you will receive an <code>InvalidParameterException</code> error. </p>
		/// AssociateKmsKey /#X-Amz-Target=Logs_20140328.AssociateKmsKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task AssociateKmsKeyAsync(AssociateKmsKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.AssociateKmsKey";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Cancels the specified export task.</p> <p>The task must be in the <code>PENDING</code> or <code>RUNNING</code> state.</p>
		/// CancelExportTask /#X-Amz-Target=Logs_20140328.CancelExportTask
		/// </summary>
		/// <returns>Success</returns>
		public async Task CancelExportTaskAsync(CancelExportTaskRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.CancelExportTask";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates an export task, which allows you to efficiently export data from a log group to an Amazon S3 bucket.</p> <p>This is an asynchronous call. If all the required information is provided, this operation initiates an export task and responds with the ID of the task. After the task has started, you can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeExportTasks.html">DescribeExportTasks</a> to get the status of the export task. Each account can only have one active (<code>RUNNING</code> or <code>PENDING</code>) export task at a time. To cancel an export task, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_CancelExportTask.html">CancelExportTask</a>.</p> <p>You can export logs from multiple log groups or multiple time ranges to the same S3 bucket. To separate out log data for each export task, you can specify a prefix to be used as the Amazon S3 key prefix for all exported objects.</p> <p>Exporting to S3 buckets that are encrypted with AES-256 is supported. Exporting to S3 buckets encrypted with SSE-KMS is not supported. </p>
		/// CreateExportTask /#X-Amz-Target=Logs_20140328.CreateExportTask
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateExportTaskResponse> CreateExportTaskAsync(CreateExportTaskRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.CreateExportTask";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateExportTaskResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a log group with the specified name.</p> <p>You can create up to 20,000 log groups per account.</p> <p>You must use the following guidelines when naming a log group:</p> <ul> <li> <p>Log group names must be unique within a region for an AWS account.</p> </li> <li> <p>Log group names can be between 1 and 512 characters long.</p> </li> <li> <p>Log group names consist of the following characters: a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen), '/' (forward slash), '.' (period), and '#' (number sign)</p> </li> </ul> <p>If you associate a AWS Key Management Service (AWS KMS) customer master key (CMK) with the log group, ingested data is encrypted using the CMK. This association is stored as long as the data encrypted with the CMK is still within Amazon CloudWatch Logs. This enables Amazon CloudWatch Logs to decrypt this data whenever it is requested.</p> <p>If you attempt to associate a CMK with the log group but the CMK does not exist or the CMK is disabled, you will receive an <code>InvalidParameterException</code> error. </p> <note> <p> <b>Important:</b> CloudWatch Logs supports only symmetric CMKs. Do not associate an asymmetric CMK with your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric Keys</a>.</p> </note>
		/// CreateLogGroup /#X-Amz-Target=Logs_20140328.CreateLogGroup
		/// </summary>
		/// <returns>Success</returns>
		public async Task CreateLogGroupAsync(CreateLogGroupRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.CreateLogGroup";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a log stream for the specified log group.</p> <p>There is no limit on the number of log streams that you can create for a log group. There is a limit of 50 TPS on <code>CreateLogStream</code> operations, after which transactions are throttled.</p> <p>You must use the following guidelines when naming a log stream:</p> <ul> <li> <p>Log stream names must be unique within the log group.</p> </li> <li> <p>Log stream names can be between 1 and 512 characters long.</p> </li> <li> <p>The ':' (colon) and '*' (asterisk) characters are not allowed.</p> </li> </ul>
		/// CreateLogStream /#X-Amz-Target=Logs_20140328.CreateLogStream
		/// </summary>
		/// <returns>Success</returns>
		public async Task CreateLogStreamAsync(CreateLogStreamRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.CreateLogStream";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified destination, and eventually disables all the subscription filters that publish to it. This operation does not delete the physical resource encapsulated by the destination.
		/// DeleteDestination /#X-Amz-Target=Logs_20140328.DeleteDestination
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteDestinationAsync(DeleteDestinationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DeleteDestination";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified log group and permanently deletes all the archived log events associated with the log group.
		/// DeleteLogGroup /#X-Amz-Target=Logs_20140328.DeleteLogGroup
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteLogGroupAsync(DeleteLogGroupRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DeleteLogGroup";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified log stream and permanently deletes all the archived log events associated with the log stream.
		/// DeleteLogStream /#X-Amz-Target=Logs_20140328.DeleteLogStream
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteLogStreamAsync(DeleteLogStreamRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DeleteLogStream";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified metric filter.
		/// DeleteMetricFilter /#X-Amz-Target=Logs_20140328.DeleteMetricFilter
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteMetricFilterAsync(DeleteMetricFilterRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DeleteMetricFilter";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// DeleteQueryDefinition /#X-Amz-Target=Logs_20140328.DeleteQueryDefinition
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteQueryDefinitionResponse> DeleteQueryDefinitionAsync(DeleteQueryDefinitionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DeleteQueryDefinition";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteQueryDefinitionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a resource policy from this account. This revokes the access of the identities in that policy to put log events to this account.
		/// DeleteResourcePolicy /#X-Amz-Target=Logs_20140328.DeleteResourcePolicy
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteResourcePolicyAsync(DeleteResourcePolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DeleteResourcePolicy";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes the specified retention policy.</p> <p>Log events do not expire if they belong to log groups without a retention policy.</p>
		/// DeleteRetentionPolicy /#X-Amz-Target=Logs_20140328.DeleteRetentionPolicy
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteRetentionPolicyAsync(DeleteRetentionPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DeleteRetentionPolicy";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified subscription filter.
		/// DeleteSubscriptionFilter /#X-Amz-Target=Logs_20140328.DeleteSubscriptionFilter
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteSubscriptionFilterAsync(DeleteSubscriptionFilterRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DeleteSubscriptionFilter";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all your destinations. The results are ASCII-sorted by destination name.
		/// DescribeDestinations /#X-Amz-Target=Logs_20140328.DescribeDestinations
		/// </summary>
		/// <param name="limit">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeDestinationsResponse> DescribeDestinationsAsync(string limit, string nextToken, DescribeDestinationsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DescribeDestinations?limit=" + (limit==null? "" : Uri.EscapeDataString(limit))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeDestinationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the specified export tasks. You can list all your export tasks or filter the results based on task ID or task status.
		/// DescribeExportTasks /#X-Amz-Target=Logs_20140328.DescribeExportTasks
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeExportTasksResponse> DescribeExportTasksAsync(DescribeExportTasksRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DescribeExportTasks";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeExportTasksResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the specified log groups. You can list all your log groups or filter the results by prefix. The results are ASCII-sorted by log group name.
		/// DescribeLogGroups /#X-Amz-Target=Logs_20140328.DescribeLogGroups
		/// </summary>
		/// <param name="limit">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeLogGroupsResponse> DescribeLogGroupsAsync(string limit, string nextToken, DescribeLogGroupsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DescribeLogGroups?limit=" + (limit==null? "" : Uri.EscapeDataString(limit))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeLogGroupsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists the log streams for the specified log group. You can list all the log streams or filter the results by prefix. You can also control how the results are ordered.</p> <p>This operation has a limit of five transactions per second, after which transactions are throttled.</p>
		/// DescribeLogStreams /#X-Amz-Target=Logs_20140328.DescribeLogStreams
		/// </summary>
		/// <param name="limit">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeLogStreamsResponse> DescribeLogStreamsAsync(string limit, string nextToken, DescribeLogStreamsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DescribeLogStreams?limit=" + (limit==null? "" : Uri.EscapeDataString(limit))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeLogStreamsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the specified metric filters. You can list all the metric filters or filter the results by log name, prefix, metric name, or metric namespace. The results are ASCII-sorted by filter name.
		/// DescribeMetricFilters /#X-Amz-Target=Logs_20140328.DescribeMetricFilters
		/// </summary>
		/// <param name="limit">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeMetricFiltersResponse> DescribeMetricFiltersAsync(string limit, string nextToken, DescribeMetricFiltersRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DescribeMetricFilters?limit=" + (limit==null? "" : Uri.EscapeDataString(limit))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeMetricFiltersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of CloudWatch Logs Insights queries that are scheduled, executing, or have been executed recently in this account. You can request all queries, or limit it to queries of a specific log group or queries with a certain status.
		/// DescribeQueries /#X-Amz-Target=Logs_20140328.DescribeQueries
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeQueriesResponse> DescribeQueriesAsync(DescribeQueriesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DescribeQueries";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeQueriesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// DescribeQueryDefinitions /#X-Amz-Target=Logs_20140328.DescribeQueryDefinitions
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeQueryDefinitionsResponse> DescribeQueryDefinitionsAsync(DescribeQueryDefinitionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DescribeQueryDefinitions";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeQueryDefinitionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the resource policies in this account.
		/// DescribeResourcePolicies /#X-Amz-Target=Logs_20140328.DescribeResourcePolicies
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeResourcePoliciesResponse> DescribeResourcePoliciesAsync(DescribeResourcePoliciesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DescribeResourcePolicies";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeResourcePoliciesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the subscription filters for the specified log group. You can list all the subscription filters or filter the results by prefix. The results are ASCII-sorted by filter name.
		/// DescribeSubscriptionFilters /#X-Amz-Target=Logs_20140328.DescribeSubscriptionFilters
		/// </summary>
		/// <param name="limit">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeSubscriptionFiltersResponse> DescribeSubscriptionFiltersAsync(string limit, string nextToken, DescribeSubscriptionFiltersRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DescribeSubscriptionFilters?limit=" + (limit==null? "" : Uri.EscapeDataString(limit))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeSubscriptionFiltersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Disassociates the associated AWS Key Management Service (AWS KMS) customer master key (CMK) from the specified log group.</p> <p>After the AWS KMS CMK is disassociated from the log group, AWS CloudWatch Logs stops encrypting newly ingested data for the log group. All previously ingested data remains encrypted, and AWS CloudWatch Logs requires permissions for the CMK whenever the encrypted data is requested.</p> <p>Note that it can take up to 5 minutes for this operation to take effect.</p>
		/// DisassociateKmsKey /#X-Amz-Target=Logs_20140328.DisassociateKmsKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task DisassociateKmsKeyAsync(DisassociateKmsKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.DisassociateKmsKey";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists log events from the specified log group. You can list all the log events or filter the results using a filter pattern, a time range, and the name of the log stream.</p> <p>By default, this operation returns as many log events as can fit in 1 MB (up to 10,000 log events), or all the events found within the time range that you specify. If the results include a token, then there are more log events available, and you can get additional results by specifying the token in a subsequent call.</p>
		/// FilterLogEvents /#X-Amz-Target=Logs_20140328.FilterLogEvents
		/// </summary>
		/// <param name="limit">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<FilterLogEventsResponse> FilterLogEventsAsync(string limit, string nextToken, FilterLogEventsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.FilterLogEvents?limit=" + (limit==null? "" : Uri.EscapeDataString(limit))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<FilterLogEventsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists log events from the specified log stream. You can list all the log events or filter using a time range.</p> <p>By default, this operation returns as many log events as can fit in a response size of 1MB (up to 10,000 log events). You can get additional log events by specifying one of the tokens in a subsequent call.</p>
		/// GetLogEvents /#X-Amz-Target=Logs_20140328.GetLogEvents
		/// </summary>
		/// <param name="limit">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<GetLogEventsResponse> GetLogEventsAsync(string limit, string nextToken, GetLogEventsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.GetLogEvents?limit=" + (limit==null? "" : Uri.EscapeDataString(limit))+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetLogEventsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Returns a list of the fields that are included in log events in the specified log group, along with the percentage of log events that contain each field. The search is limited to a time period that you specify.</p> <p>In the results, fields that start with @ are fields generated by CloudWatch Logs. For example, <code>@timestamp</code> is the timestamp of each log event. For more information about the fields that are generated by CloudWatch logs, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields</a>.</p> <p>The response results are sorted by the frequency percentage, starting with the highest percentage.</p>
		/// GetLogGroupFields /#X-Amz-Target=Logs_20140328.GetLogGroupFields
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetLogGroupFieldsResponse> GetLogGroupFieldsAsync(GetLogGroupFieldsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.GetLogGroupFields";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetLogGroupFieldsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves all the fields and values of a single log event. All fields are retrieved, even if the original query that produced the <code>logRecordPointer</code> retrieved only a subset of fields. Fields are returned as field name/field value pairs.</p> <p>Additionally, the entire unparsed log event is returned within <code>@message</code>.</p>
		/// GetLogRecord /#X-Amz-Target=Logs_20140328.GetLogRecord
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetLogRecordResponse> GetLogRecordAsync(GetLogRecordRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.GetLogRecord";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetLogRecordResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Returns the results from the specified query.</p> <p>Only the fields requested in the query are returned, along with a <code>@ptr</code> field which is the identifier for the log record. You can use the value of <code>@ptr</code> in a <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_GetLogRecord.html">GetLogRecord</a> operation to get the full log record.</p> <p> <code>GetQueryResults</code> does not start a query execution. To run a query, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_StartQuery.html">StartQuery</a>.</p> <p>If the value of the <code>Status</code> field in the output is <code>Running</code>, this operation returns only partial results. If you see a value of <code>Scheduled</code> or <code>Running</code> for the status, you can retry the operation later to see the final results. </p>
		/// GetQueryResults /#X-Amz-Target=Logs_20140328.GetQueryResults
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetQueryResultsResponse> GetQueryResultsAsync(GetQueryResultsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.GetQueryResults";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetQueryResultsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the tags for the specified log group.
		/// ListTagsLogGroup /#X-Amz-Target=Logs_20140328.ListTagsLogGroup
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListTagsLogGroupResponse> ListTagsLogGroupAsync(ListTagsLogGroupRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.ListTagsLogGroup";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListTagsLogGroupResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates or updates a destination. This operation is used only to create destinations for cross-account subscriptions.</p> <p>A destination encapsulates a physical resource (such as an Amazon Kinesis stream) and enables you to subscribe to a real-time stream of log events for a different account, ingested using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p> <p>Through an access policy, a destination controls what is written to it. By default, <code>PutDestination</code> does not set any access policy with the destination, which means a cross-account user cannot call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutSubscriptionFilter.html">PutSubscriptionFilter</a> against this destination. To enable this, the destination owner must call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a> after <code>PutDestination</code>.</p>
		/// PutDestination /#X-Amz-Target=Logs_20140328.PutDestination
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PutDestinationResponse> PutDestinationAsync(PutDestinationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.PutDestination";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PutDestinationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates or updates an access policy associated with an existing destination. An access policy is an <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies_overview.html">IAM policy document</a> that is used to authorize claims to register a subscription filter against a given destination.
		/// PutDestinationPolicy /#X-Amz-Target=Logs_20140328.PutDestinationPolicy
		/// </summary>
		/// <returns>Success</returns>
		public async Task PutDestinationPolicyAsync(PutDestinationPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.PutDestinationPolicy";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Uploads a batch of log events to the specified log stream.</p> <p>You must include the sequence token obtained from the response of the previous call. An upload in a newly created log stream does not require a sequence token. You can also get the sequence token in the <code>expectedSequenceToken</code> field from <code>InvalidSequenceTokenException</code>. If you call <code>PutLogEvents</code> twice within a narrow time period using the same value for <code>sequenceToken</code>, both calls may be successful, or one may be rejected.</p> <p>The batch of events must satisfy the following constraints:</p> <ul> <li> <p>The maximum batch size is 1,048,576 bytes, and this size is calculated as the sum of all event messages in UTF-8, plus 26 bytes for each log event.</p> </li> <li> <p>None of the log events in the batch can be more than 2 hours in the future.</p> </li> <li> <p>None of the log events in the batch can be older than 14 days or older than the retention period of the log group.</p> </li> <li> <p>The log events in the batch must be in chronological ordered by their timestamp. The timestamp is the time the event occurred, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC. (In AWS Tools for PowerShell and the AWS SDK for .NET, the timestamp is specified in .NET format: yyyy-mm-ddThh:mm:ss. For example, 2017-09-15T13:45:30.) </p> </li> <li> <p>A batch of log events in a single request cannot span more than 24 hours. Otherwise, the operation fails.</p> </li> <li> <p>The maximum number of log events in a batch is 10,000.</p> </li> <li> <p>There is a quota of 5 requests per second per log stream. Additional requests are throttled. This quota can't be changed.</p> </li> </ul> <p>If a call to PutLogEvents returns "UnrecognizedClientException" the most likely cause is an invalid AWS access key ID or secret key. </p>
		/// PutLogEvents /#X-Amz-Target=Logs_20140328.PutLogEvents
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PutLogEventsResponse> PutLogEventsAsync(PutLogEventsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.PutLogEvents";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PutLogEventsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates or updates a metric filter and associates it with the specified log group. Metric filters allow you to configure rules to extract metric data from log events ingested through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p> <p>The maximum number of metric filters that can be associated with a log group is 100.</p>
		/// PutMetricFilter /#X-Amz-Target=Logs_20140328.PutMetricFilter
		/// </summary>
		/// <returns>Success</returns>
		public async Task PutMetricFilterAsync(PutMetricFilterRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.PutMetricFilter";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// PutQueryDefinition /#X-Amz-Target=Logs_20140328.PutQueryDefinition
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PutQueryDefinitionResponse> PutQueryDefinitionAsync(PutQueryDefinitionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.PutQueryDefinition";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PutQueryDefinitionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates or updates a resource policy allowing other AWS services to put log events to this account, such as Amazon Route 53. An account can have up to 10 resource policies per region.
		/// PutResourcePolicy /#X-Amz-Target=Logs_20140328.PutResourcePolicy
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PutResourcePolicyResponse> PutResourcePolicyAsync(PutResourcePolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.PutResourcePolicy";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PutResourcePolicyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the retention of the specified log group. A retention policy allows you to configure the number of days for which to retain log events in the specified log group.
		/// PutRetentionPolicy /#X-Amz-Target=Logs_20140328.PutRetentionPolicy
		/// </summary>
		/// <returns>Success</returns>
		public async Task PutRetentionPolicyAsync(PutRetentionPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.PutRetentionPolicy";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates or updates a subscription filter and associates it with the specified log group. Subscription filters allow you to subscribe to a real-time stream of log events ingested through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a> and have them delivered to a specific destination. Currently, the supported destinations are:</p> <ul> <li> <p>An Amazon Kinesis stream belonging to the same account as the subscription filter, for same-account delivery.</p> </li> <li> <p>A logical destination that belongs to a different account, for cross-account delivery.</p> </li> <li> <p>An Amazon Kinesis Firehose delivery stream that belongs to the same account as the subscription filter, for same-account delivery.</p> </li> <li> <p>An AWS Lambda function that belongs to the same account as the subscription filter, for same-account delivery.</p> </li> </ul> <p>There can only be one subscription filter associated with a log group. If you are updating an existing filter, you must specify the correct name in <code>filterName</code>. Otherwise, the call fails because you cannot associate a second filter with a log group.</p>
		/// PutSubscriptionFilter /#X-Amz-Target=Logs_20140328.PutSubscriptionFilter
		/// </summary>
		/// <returns>Success</returns>
		public async Task PutSubscriptionFilterAsync(PutSubscriptionFilterRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.PutSubscriptionFilter";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Schedules a query of a log group using CloudWatch Logs Insights. You specify the log group and time range to query, and the query string to use.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p> <p>Queries time out after 15 minutes of execution. If your queries are timing out, reduce the time range being searched, or partition your query into a number of queries.</p>
		/// StartQuery /#X-Amz-Target=Logs_20140328.StartQuery
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StartQueryResponse> StartQueryAsync(StartQueryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.StartQuery";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<StartQueryResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stops a CloudWatch Logs Insights query that is in progress. If the query has already ended, the operation returns an error indicating that the specified query is not running.
		/// StopQuery /#X-Amz-Target=Logs_20140328.StopQuery
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StopQueryResponse> StopQueryAsync(StopQueryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.StopQuery";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<StopQueryResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Adds or updates the specified tags for the specified log group.</p> <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>. To remove tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_UntagLogGroup.html">UntagLogGroup</a>.</p> <p>For more information about tags, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html#log-group-tagging">Tag Log Groups in Amazon CloudWatch Logs</a> in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
		/// TagLogGroup /#X-Amz-Target=Logs_20140328.TagLogGroup
		/// </summary>
		/// <returns>Success</returns>
		public async Task TagLogGroupAsync(TagLogGroupRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.TagLogGroup";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Tests the filter pattern of a metric filter against a sample of log event messages. You can use this operation to validate the correctness of a metric filter pattern.
		/// TestMetricFilter /#X-Amz-Target=Logs_20140328.TestMetricFilter
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TestMetricFilterResponse> TestMetricFilterAsync(TestMetricFilterRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.TestMetricFilter";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<TestMetricFilterResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Removes the specified tags from the specified log group.</p> <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>. To add tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_TagLogGroup.html">TagLogGroup</a>.</p>
		/// UntagLogGroup /#X-Amz-Target=Logs_20140328.UntagLogGroup
		/// </summary>
		/// <returns>Success</returns>
		public async Task UntagLogGroupAsync(UntagLogGroupRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/#X-Amz-Target=Logs_20140328.UntagLogGroup";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
