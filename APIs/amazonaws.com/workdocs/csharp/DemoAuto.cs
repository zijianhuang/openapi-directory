//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ActivateUserResponse
	{
		
		/// <summary>
		/// Describes a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public User User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddResourcePermissionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ShareResult[] ShareResults { get; set; }
	}
	
	/// <summary>
	/// Describes the recipient type and ID, if available.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SharePrincipal
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Id { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SharePrincipalType Type { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SharePrincipalRole Role { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SharePrincipalType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GROUP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVITE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANONYMOUS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SharePrincipalRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIEWER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTRIBUTOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COOWNER = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateCommentResponse
	{
		
		/// <summary>
		/// Describes a comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Comment Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateFolderResponse
	{
		
		/// <summary>
		/// Describes a folder.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata Metadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateNotificationSubscriptionResponse
	{
		
		/// <summary>
		/// Describes a subscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Subscription Subscription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateUserResponse
	{
		
		/// <summary>
		/// Describes a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public User User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum StorageType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNLIMITED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QUOTA = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeActivitiesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Activity[] UserActivities { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// Pattern: [\u0000-\u00FF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeCommentsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Comment[] Comments { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// Pattern: [\u0000-\u00FF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeDocumentVersionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentVersionMetadata[] DocumentVersions { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeFolderContentsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata[] Folders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentMetadata[] Documents { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeGroupsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public GroupMetadata[] Groups { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// Pattern: [\u0000-\u00FF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeNotificationSubscriptionsResponse
	{
		
		/// <summary>
		/// Maximum items: 256
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public Subscription[] Subscriptions { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeResourcePermissionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Principal[] Principals { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeRootFoldersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata[] Folders { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeUsersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public User[] Users { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalNumberOfUsers { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetCurrentUserResponse
	{
		
		/// <summary>
		/// Describes a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public User User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetDocumentResponse
	{
		
		/// <summary>
		/// Describes the document.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DocumentMetadata Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CustomMetadataMap CustomMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetDocumentPathResponse
	{
		
		/// <summary>
		/// Describes the path information of a resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ResourcePath Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetDocumentVersionResponse
	{
		
		/// <summary>
		/// Describes a version of a document.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DocumentVersionMetadata Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CustomMetadataMap CustomMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetFolderResponse
	{
		
		/// <summary>
		/// Describes a folder.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CustomMetadataMap CustomMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetFolderPathResponse
	{
		
		/// <summary>
		/// Describes the path information of a resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ResourcePath Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetResourcesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata[] Folders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentMetadata[] Documents { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class InitiateDocumentVersionUploadResponse
	{
		
		/// <summary>
		/// Describes the document.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DocumentMetadata Metadata { get; set; }
		
		/// <summary>
		/// Describes the upload.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UploadMetadata UploadMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateUserResponse
	{
		
		/// <summary>
		/// Describes a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public User User { get; set; }
	}
	
	/// <summary>
	/// Describes a user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class User
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Id { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [\w\-+.]+(@[a-zA-Z0-9.\-]+\.[a-zA-Z]+)?
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Username { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string EmailAddress { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string GivenName { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string Surname { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string RootFolderId { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string RecycleBinFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ModifiedTimestamp { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string TimeZoneId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserLocale Locale { get; set; }
		
		/// <summary>
		/// Describes the storage for a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserStorageMetadata Storage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UserStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UserType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POWERUSER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MINIMALUSER = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WORKSPACESUSER = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UserLocale
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fr = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ko = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		de = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		es = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ja = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ru = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zh_CN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zh_TW = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pt_BR = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		@default = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ActivityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_CHECKED_IN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_CHECKED_OUT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_RENAMED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_UPLOADED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_DELETED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_VIEWED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_DOWNLOADED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_RECYCLED = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_RESTORED = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_REVERTED = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHARED = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_UNSHARED = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHARE_PERMISSION_CHANGED = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHAREABLE_LINK_CREATED = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHAREABLE_LINK_REMOVED = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_MOVED = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_COMMENT_ADDED = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_COMMENT_DELETED = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_ANNOTATION_ADDED = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_ANNOTATION_DELETED = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_CREATED = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_DELETED = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_RENAMED = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_RECYCLED = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_RESTORED = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHARED = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_UNSHARED = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHARE_PERMISSION_CHANGED = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHAREABLE_LINK_CREATED = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHAREABLE_LINK_REMOVED = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_MOVED = 32,
	}
	
	/// <summary>
	/// Describes the metadata of the user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UserMetadata
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Id { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [\w\-+.]+(@[a-zA-Z0-9.\-]+\.[a-zA-Z]+)?
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Username { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string GivenName { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string Surname { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string EmailAddress { get; set; }
	}
	
	/// <summary>
	/// Describes the users or user groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Participants
	{
		
		[System.Runtime.Serialization.DataMember()]
		public UserMetadata[] Users { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GroupMetadata[] Groups { get; set; }
	}
	
	/// <summary>
	/// Describes the metadata of a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ResourceMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceMetadataType Type { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string OriginalName { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string Id { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string VersionId { get; set; }
		
		/// <summary>
		/// Describes the metadata of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserMetadata Owner { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ResourceMetadataType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT = 1,
	}
	
	/// <summary>
	/// Describes the metadata of a comment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CommentMetadata
	{
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string CommentId { get; set; }
		
		/// <summary>
		/// Describes a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public User Contributor { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CommentMetadataCommentStatus CommentStatus { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string RecipientId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CommentMetadataCommentStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DRAFT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLISHED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 2,
	}
	
	/// <summary>
	/// Describes the activity information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Activity
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ActivityType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> TimeStamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsIndirectActivity { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// Describes the metadata of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserMetadata Initiator { get; set; }
		
		/// <summary>
		/// Describes the users or user groups.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Participants Participants { get; set; }
		
		/// <summary>
		/// Describes the metadata of a resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ResourceMetadata ResourceMetadata { get; set; }
		
		/// <summary>
		/// Describes the metadata of a resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ResourceMetadata OriginalParent { get; set; }
		
		/// <summary>
		/// Describes the metadata of a comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CommentMetadata CommentMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ActivityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_CHECKED_IN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_CHECKED_OUT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_RENAMED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_UPLOADED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_DELETED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_VIEWED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_DOWNLOADED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_RECYCLED = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_RESTORED = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_REVERTED = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHARED = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_UNSHARED = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHARE_PERMISSION_CHANGED = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHAREABLE_LINK_CREATED = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHAREABLE_LINK_REMOVED = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_MOVED = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_COMMENT_ADDED = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_COMMENT_DELETED = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_ANNOTATION_ADDED = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_ANNOTATION_DELETED = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_CREATED = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_DELETED = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_RENAMED = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_RECYCLED = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_RESTORED = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHARED = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_UNSHARED = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHARE_PERMISSION_CHANGED = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHAREABLE_LINK_CREATED = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHAREABLE_LINK_REMOVED = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_MOVED = 32,
	}
	
	/// <summary>
	/// Set of options which defines notification preferences of given action.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class NotificationOptions
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SendEmail { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=0)]
		public string EmailMessage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddResourcePermissionsRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SharePrincipal[] Principals { get; set; }
		
		/// <summary>
		/// Set of options which defines notification preferences of given action.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NotificationOptions NotificationOptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum BooleanEnumType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRUE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FALSE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CommentStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DRAFT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLISHED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CommentVisibilityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 1,
	}
	
	/// <summary>
	/// Describes a comment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Comment
	{
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string CommentId { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentId { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ThreadId { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Text { get; set; }
		
		/// <summary>
		/// Describes a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public User Contributor { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CommentStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CommentVisibility Visibility { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string RecipientId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CommentStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DRAFT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLISHED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CommentVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateCommentRequest
	{
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentId { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ThreadId { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Text { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CreateCommentRequestVisibility Visibility { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> NotifyCollaborators { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateCommentRequestVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateCustomMetadataRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CustomMetadataMap CustomMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateFolderRequest
	{
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentFolderId { get; set; }
	}
	
	/// <summary>
	/// Describes a folder.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FolderMetadata
	{
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string Id { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string CreatorId { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ModifiedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadataResourceState ResourceState { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Signature { get; set; }
		
		/// <summary>
		/// Maximum items: 20
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public SharedLabel[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> LatestVersionSize { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FolderMetadataResourceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateLabelsRequest
	{
		
		/// <summary>
		/// Maximum items: 20
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public SharedLabel[] Labels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SubscriptionProtocolType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTPS = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SubscriptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateNotificationSubscriptionRequest
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Endpoint { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateNotificationSubscriptionRequestProtocol Protocol { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateNotificationSubscriptionRequestSubscriptionType SubscriptionType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateNotificationSubscriptionRequestProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTPS = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateNotificationSubscriptionRequestSubscriptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
	}
	
	/// <summary>
	/// Describes a subscription.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Subscription
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string SubscriptionId { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string EndPoint { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SubscriptionProtocol Protocol { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SubscriptionProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTPS = 0,
	}
	
	/// <summary>
	/// Describes the storage for a user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StorageRuleType
	{
		
		/// <summary>
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> StorageAllocatedInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageRuleTypeStorageType StorageType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum StorageRuleTypeStorageType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNLIMITED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QUOTA = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateUserRequest
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [\w\-+.]+(@[a-zA-Z0-9.\-]+\.[a-zA-Z]+)?
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Username { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string EmailAddress { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string GivenName { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string Surname { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 4
		/// Pattern: [\u0020-\u00FF]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=4)]
		public string Password { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string TimeZoneId { get; set; }
		
		/// <summary>
		/// Describes the storage for a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public StorageRuleType StorageRule { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ResourceSortType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NAME = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum OrderType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASCENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DESCENDING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FolderContentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UserFilterType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE_PENDING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UserSortType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER_NAME = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_NAME = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STORAGE_LIMIT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER_STATUS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STORAGE_USED = 4,
	}
	
	/// <summary>
	/// Describes a version of a document.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DocumentVersionMetadata
	{
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string Id { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ContentType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 0
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=0)]
		public string Signature { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentVersionMetadataStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ModifiedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ContentCreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ContentModifiedTimestamp { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string CreatorId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentThumbnailUrlMap Thumbnail { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentSourceUrlMap Source { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DocumentVersionMetadataStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INITIALIZED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ResourceStateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLED = 3,
	}
	
	/// <summary>
	/// Describes the document.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DocumentMetadata
	{
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string Id { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string CreatorId { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ModifiedTimestamp { get; set; }
		
		/// <summary>
		/// Describes a version of a document.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DocumentVersionMetadata LatestVersionMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentMetadataResourceState ResourceState { get; set; }
		
		/// <summary>
		/// Maximum items: 20
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public SharedLabel[] Labels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DocumentMetadataResourceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DocumentSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORIGINAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WITH_COMMENTS = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DocumentStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INITIALIZED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DocumentThumbnailType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SMALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SMALL_HQ = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LARGE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DocumentVersionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
	}
	
	/// <summary>
	/// Describes the path information of a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ResourcePath
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResourcePathComponent[] Components { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ResourceCollectionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHARED_WITH_ME = 0,
	}
	
	/// <summary>
	/// Describes the metadata of a user group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GroupMetadata
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class InitiateDocumentVersionUploadRequest
	{
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string Id { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ContentCreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ContentModifiedTimestamp { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ContentType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DocumentSizeInBytes { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentFolderId { get; set; }
	}
	
	/// <summary>
	/// Describes the upload.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UploadMetadata
	{
		
		/// <summary>
		/// Max length: 1024
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(1024, MinimumLength=1)]
		public string UploadUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SignedHeaderMap SignedHeaders { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum LocaleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fr = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ko = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		de = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		es = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ja = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ru = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zh_CN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zh_TW = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pt_BR = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		@default = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RoleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIEWER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTRIBUTOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COOWNER = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RolePermissionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INHERITED = 1,
	}
	
	/// <summary>
	/// Describes the permissions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PermissionInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PermissionInfoRole Role { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PermissionInfoType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PermissionInfoRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIEWER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTRIBUTOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COOWNER = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PermissionInfoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INHERITED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PrincipalType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GROUP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVITE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANONYMOUS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION = 4,
	}
	
	/// <summary>
	/// Describes a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Principal
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PrincipalType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PermissionInfo[] Roles { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum PrincipalType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GROUP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVITE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANONYMOUS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT = 1,
	}
	
	/// <summary>
	/// Describes the resource path.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ResourcePathComponent
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Id { get; set; }
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ShareStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILURE = 1,
	}
	
	/// <summary>
	/// Describes the share results of a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ShareResult
	{
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string PrincipalId { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string InviteePrincipalId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ShareResultRole Role { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ShareResultStatus Status { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ShareId { get; set; }
		
		/// <summary>
		/// Max length: 2048
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=0)]
		public string StatusMessage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ShareResultRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIEWER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTRIBUTOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COOWNER = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ShareResultStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILURE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateDocumentRequest
	{
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateDocumentRequestResourceState ResourceState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateDocumentRequestResourceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateDocumentVersionRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateDocumentVersionRequestVersionStatus VersionStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateDocumentVersionRequestVersionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFolderRequest
	{
		
		/// <summary>
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateFolderRequestResourceState ResourceState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateFolderRequestResourceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UserType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POWERUSER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MINIMALUSER = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WORKSPACESUSER = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateUserRequest
	{
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string GivenName { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string Surname { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateUserRequestType Type { get; set; }
		
		/// <summary>
		/// Describes the storage for a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public StorageRuleType StorageRule { get; set; }
		
		/// <summary>
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string TimeZoneId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateUserRequestLocale Locale { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateUserRequestGrantPoweruserPrivileges GrantPoweruserPrivileges { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateUserRequestType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POWERUSER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MINIMALUSER = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WORKSPACESUSER = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateUserRequestLocale
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fr = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ko = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		de = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		es = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ja = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ru = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zh_CN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zh_TW = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pt_BR = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		@default = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateUserRequestGrantPoweruserPrivileges
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRUE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FALSE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UserStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 2,
	}
	
	/// <summary>
	/// Describes the storage for a user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UserStorageMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StorageUtilizedInBytes { get; set; }
		
		/// <summary>
		/// Describes the storage for a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public StorageRuleType StorageRule { get; set; }
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Aborts the upload of the specified document version that was previously initiated by <a>InitiateDocumentVersionUpload</a>. The client should make this call only when it no longer intends to upload the document version, or fails to do so.
		/// AbortDocumentVersionUpload /api/v1/documents/{DocumentId}/versions/{VersionId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.</param>
		/// <param name="VersionId">The ID of the version.</param>
		public async Task AbortDocumentVersionUploadAsync(string DocumentId, string VersionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/documents/"+ (DocumentId==null? "" : Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : Uri.EscapeDataString(VersionId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves version metadata for the specified document.
		/// GetDocumentVersion /api/v1/documents/{DocumentId}/versions/{VersionId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.</param>
		/// <param name="VersionId">The version ID of the document.</param>
		/// <param name="fields">A comma-separated list of values. Specify "SOURCE" to include a URL for the source document.</param>
		/// <param name="includeCustomMetadata">Set this to TRUE to include custom metadata in the response.</param>
		/// <returns>Success</returns>
		public async Task<GetDocumentVersionResponse> GetDocumentVersionAsync(string DocumentId, string VersionId, string fields, bool includeCustomMetadata, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/documents/"+ (DocumentId==null? "" : Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : Uri.EscapeDataString(VersionId))+"&fields=" + (fields==null? "" : Uri.EscapeDataString(fields))+"&includeCustomMetadata="+includeCustomMetadata;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetDocumentVersionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Activates the specified user. Only active users can access Amazon WorkDocs.
		/// ActivateUser /api/v1/users/{UserId}/activation
		/// </summary>
		/// <param name="UserId">The ID of the user.</param>
		/// <returns>Success</returns>
		public async Task<ActivateUserResponse> ActivateUserAsync(string UserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/users/"+ (UserId==null? "" : Uri.EscapeDataString(UserId))+"/activation";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ActivateUserResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deactivates the specified user, which revokes the user's access to Amazon WorkDocs.
		/// DeactivateUser /api/v1/users/{UserId}/activation
		/// </summary>
		/// <param name="UserId">The ID of the user.</param>
		public async Task DeactivateUserAsync(string UserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/users/"+ (UserId==null? "" : Uri.EscapeDataString(UserId))+"/activation";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a set of permissions for the specified folder or document. The resource permissions are overwritten if the principals already have different permissions.
		/// AddResourcePermissions /api/v1/resources/{ResourceId}/permissions
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.</param>
		public async Task AddResourcePermissionsAsync(string ResourceId, AddResourcePermissionsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/resources/"+ (ResourceId==null? "" : Uri.EscapeDataString(ResourceId))+"/permissions";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Describes the permissions of a specified resource.
		/// DescribeResourcePermissions /api/v1/resources/{ResourceId}/permissions
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.</param>
		/// <param name="principalId">The ID of the principal to filter permissions by.</param>
		/// <param name="limit">The maximum number of items to return with this call.</param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call)</param>
		/// <returns>Success</returns>
		public async Task<DescribeResourcePermissionsResponse> DescribeResourcePermissionsAsync(string ResourceId, string principalId, int limit, string marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/resources/"+ (ResourceId==null? "" : Uri.EscapeDataString(ResourceId))+"/permissions&principalId=" + (principalId==null? "" : Uri.EscapeDataString(principalId))+"&limit="+limit+"&marker=" + (marker==null? "" : Uri.EscapeDataString(marker));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeResourcePermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes all the permissions from the specified resource.
		/// RemoveAllResourcePermissions /api/v1/resources/{ResourceId}/permissions
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.</param>
		public async Task RemoveAllResourcePermissionsAsync(string ResourceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/resources/"+ (ResourceId==null? "" : Uri.EscapeDataString(ResourceId))+"/permissions";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a new comment to the specified document version.
		/// CreateComment /api/v1/documents/{DocumentId}/versions/{VersionId}/comment
		/// </summary>
		/// <param name="DocumentId">The ID of the document.</param>
		/// <param name="VersionId">The ID of the document version.</param>
		public async Task CreateCommentAsync(string DocumentId, string VersionId, CreateCommentBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/documents/"+ (DocumentId==null? "" : Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : Uri.EscapeDataString(VersionId))+"/comment";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds one or more custom properties to the specified resource (a folder, document, or version).
		/// CreateCustomMetadata /api/v1/resources/{ResourceId}/customMetadata
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.</param>
		/// <param name="versionid">The ID of the version, if the custom metadata is being added to a document version.</param>
		/// <returns>Success</returns>
		public async Task<CreateCustomMetadataResponse> CreateCustomMetadataAsync(string ResourceId, string versionid, CreateCustomMetadataBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/resources/"+ (ResourceId==null? "" : Uri.EscapeDataString(ResourceId))+"/customMetadata&versionid=" + (versionid==null? "" : Uri.EscapeDataString(versionid));
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateCustomMetadataResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes custom metadata from the specified resource.
		/// DeleteCustomMetadata /api/v1/resources/{ResourceId}/customMetadata
		/// </summary>
		/// <param name="ResourceId">The ID of the resource, either a document or folder.</param>
		/// <param name="versionId">The ID of the version, if the custom metadata is being deleted from a document version.</param>
		/// <param name="keys">List of properties to remove.</param>
		/// <param name="deleteAll">Flag to indicate removal of all custom metadata properties from the specified resource.</param>
		/// <returns>Success</returns>
		public async Task<DeleteCustomMetadataResponse> DeleteCustomMetadataAsync(string ResourceId, string versionId, CustomMetadataKeyType[] keys, bool deleteAll, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/resources/"+ (ResourceId==null? "" : Uri.EscapeDataString(ResourceId))+"/customMetadata&versionId=" + (versionId==null? "" : Uri.EscapeDataString(versionId))+"&"+String.Join("&", keys.Select(z => $"keys={z}"))+"&deleteAll="+deleteAll;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteCustomMetadataResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a folder with the specified name and parent folder.
		/// CreateFolder /api/v1/folders
		/// </summary>
		public async Task CreateFolderAsync(CreateFolderBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/folders";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds the specified list of labels to the given resource (a document or folder)
		/// CreateLabels /api/v1/resources/{ResourceId}/labels
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.</param>
		/// <returns>Success</returns>
		public async Task<CreateLabelsResponse> CreateLabelsAsync(string ResourceId, CreateLabelsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/resources/"+ (ResourceId==null? "" : Uri.EscapeDataString(ResourceId))+"/labels";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateLabelsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified list of labels from a resource.
		/// DeleteLabels /api/v1/resources/{ResourceId}/labels
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.</param>
		/// <param name="labels">List of labels to delete from the resource.</param>
		/// <param name="deleteAll">Flag to request removal of all labels from the specified resource.</param>
		/// <returns>Success</returns>
		public async Task<DeleteLabelsResponse> DeleteLabelsAsync(string ResourceId, SharedLabel[] labels, bool deleteAll, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/resources/"+ (ResourceId==null? "" : Uri.EscapeDataString(ResourceId))+"/labels&"+String.Join("&", labels.Select(z => $"labels={z}"))+"&deleteAll="+deleteAll;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteLabelsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Configure Amazon WorkDocs to use Amazon SNS notifications. The endpoint receives a confirmation message, and must confirm the subscription.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/workdocs/latest/developerguide/subscribe-notifications.html">Subscribe to Notifications</a> in the <i>Amazon WorkDocs Developer Guide</i>.</p>
		/// CreateNotificationSubscription /api/v1/organizations/{OrganizationId}/subscriptions
		/// </summary>
		/// <param name="OrganizationId">The ID of the organization.</param>
		/// <returns>Success</returns>
		public async Task<CreateNotificationSubscriptionResponse> CreateNotificationSubscriptionAsync(string OrganizationId, CreateNotificationSubscriptionBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/organizations/"+ (OrganizationId==null? "" : Uri.EscapeDataString(OrganizationId))+"/subscriptions";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateNotificationSubscriptionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the specified notification subscriptions.
		/// DescribeNotificationSubscriptions /api/v1/organizations/{OrganizationId}/subscriptions
		/// </summary>
		/// <param name="OrganizationId">The ID of the organization.</param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call.)</param>
		/// <param name="limit">The maximum number of items to return with this call.</param>
		/// <returns>Success</returns>
		public async Task<DescribeNotificationSubscriptionsResponse> DescribeNotificationSubscriptionsAsync(string OrganizationId, string marker, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/organizations/"+ (OrganizationId==null? "" : Uri.EscapeDataString(OrganizationId))+"/subscriptions&marker=" + (marker==null? "" : Uri.EscapeDataString(marker))+"&limit="+limit;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeNotificationSubscriptionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a user in a Simple AD or Microsoft AD directory. The status of a newly created user is "ACTIVE". New users can access Amazon WorkDocs.
		/// CreateUser /api/v1/users
		/// </summary>
		public async Task CreateUserAsync(CreateUserBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/users";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Describes the specified users. You can describe all users or filter the results (for example, by status or organization).</p> <p>By default, Amazon WorkDocs returns the first 24 active or pending users. If there are more results, the response includes a marker that you can use to request the next set of results.</p>
		/// DescribeUsers /api/v1/users
		/// </summary>
		/// <param name="organizationId">The ID of the organization.</param>
		/// <param name="userIds">The IDs of the users.</param>
		/// <param name="query">A query to filter users by user name.</param>
		/// <param name="include">The state of the users. Specify "ALL" to include inactive users.</param>
		/// <param name="order">The order for the results.</param>
		/// <param name="sort">The sorting criteria.</param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call.)</param>
		/// <param name="limit">The maximum number of items to return.</param>
		/// <param name="fields">A comma-separated list of values. Specify "STORAGE_METADATA" to include the user storage quota and utilization information.</param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeUsersResponse> DescribeUsersAsync(string organizationId, string userIds, string query, UserFilterType include, OrderType order, UserSortType sort, string marker, int limit, string fields, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/users?organizationId=" + (organizationId==null? "" : Uri.EscapeDataString(organizationId))+"&userIds=" + (userIds==null? "" : Uri.EscapeDataString(userIds))+"&query=" + (query==null? "" : Uri.EscapeDataString(query))+"&include=" + include+"&order=" + order+"&sort=" + sort+"&marker=" + (marker==null? "" : Uri.EscapeDataString(marker))+"&limit="+limit+"&fields=" + (fields==null? "" : Uri.EscapeDataString(fields))+"&Limit=" + (Limit==null? "" : Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : Uri.EscapeDataString(Marker));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeUsersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified comment from the document version.
		/// DeleteComment /api/v1/documents/{DocumentId}/versions/{VersionId}/comment/{CommentId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.</param>
		/// <param name="VersionId">The ID of the document version.</param>
		/// <param name="CommentId">The ID of the comment.</param>
		public async Task DeleteCommentAsync(string DocumentId, string VersionId, string CommentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/documents/"+ (DocumentId==null? "" : Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : Uri.EscapeDataString(VersionId))+"/comment/"+ (CommentId==null? "" : Uri.EscapeDataString(CommentId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Permanently deletes the specified document and its associated metadata.
		/// DeleteDocument /api/v1/documents/{DocumentId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.</param>
		public async Task DeleteDocumentAsync(string DocumentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/documents/"+ (DocumentId==null? "" : Uri.EscapeDataString(DocumentId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves details of a document.
		/// GetDocument /api/v1/documents/{DocumentId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.</param>
		/// <param name="includeCustomMetadata">Set this to <code>TRUE</code> to include custom metadata in the response.</param>
		/// <returns>Success</returns>
		public async Task<GetDocumentResponse> GetDocumentAsync(string DocumentId, bool includeCustomMetadata, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/documents/"+ (DocumentId==null? "" : Uri.EscapeDataString(DocumentId))+"&includeCustomMetadata="+includeCustomMetadata;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetDocumentResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Permanently deletes the specified folder and its contents.
		/// DeleteFolder /api/v1/folders/{FolderId}
		/// </summary>
		/// <param name="FolderId">The ID of the folder.</param>
		public async Task DeleteFolderAsync(string FolderId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/folders/"+ (FolderId==null? "" : Uri.EscapeDataString(FolderId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the metadata of the specified folder.
		/// GetFolder /api/v1/folders/{FolderId}
		/// </summary>
		/// <param name="FolderId">The ID of the folder.</param>
		/// <param name="includeCustomMetadata">Set to TRUE to include custom metadata in the response.</param>
		/// <returns>Success</returns>
		public async Task<GetFolderResponse> GetFolderAsync(string FolderId, bool includeCustomMetadata, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/folders/"+ (FolderId==null? "" : Uri.EscapeDataString(FolderId))+"&includeCustomMetadata="+includeCustomMetadata;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetFolderResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the contents of the specified folder.
		/// DeleteFolderContents /api/v1/folders/{FolderId}/contents
		/// </summary>
		/// <param name="FolderId">The ID of the folder.</param>
		public async Task DeleteFolderContentsAsync(string FolderId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/folders/"+ (FolderId==null? "" : Uri.EscapeDataString(FolderId))+"/contents";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Describes the contents of the specified folder, including its documents and subfolders.</p> <p>By default, Amazon WorkDocs returns the first 100 active document and folder metadata items. If there are more results, the response includes a marker that you can use to request the next set of results. You can also request initialized documents.</p>
		/// DescribeFolderContents /api/v1/folders/{FolderId}/contents
		/// </summary>
		/// <param name="FolderId">The ID of the folder.</param>
		/// <param name="sort">The sorting criteria.</param>
		/// <param name="order">The order for the contents of the folder.</param>
		/// <param name="limit">The maximum number of items to return with this call.</param>
		/// <param name="marker">The marker for the next set of results. This marker was received from a previous call.</param>
		/// <param name="type">The type of items.</param>
		/// <param name="include">The contents to include. Specify "INITIALIZED" to include initialized documents.</param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeFolderContentsResponse> DescribeFolderContentsAsync(string FolderId, ResourceSortType sort, OrderType order, int limit, string marker, FolderContentType type, string include, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/folders/"+ (FolderId==null? "" : Uri.EscapeDataString(FolderId))+"/contents&sort=" + sort+"&order=" + order+"&limit="+limit+"&marker=" + (marker==null? "" : Uri.EscapeDataString(marker))+"&type=" + type+"&include=" + (include==null? "" : Uri.EscapeDataString(include))+"&Limit=" + (Limit==null? "" : Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : Uri.EscapeDataString(Marker));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeFolderContentsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified subscription from the specified organization.
		/// DeleteNotificationSubscription /api/v1/organizations/{OrganizationId}/subscriptions/{SubscriptionId}
		/// </summary>
		/// <param name="SubscriptionId">The ID of the subscription.</param>
		/// <param name="OrganizationId">The ID of the organization.</param>
		/// <returns>Success</returns>
		public async Task DeleteNotificationSubscriptionAsync(string SubscriptionId, string OrganizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/organizations/"+ (OrganizationId==null? "" : Uri.EscapeDataString(OrganizationId))+"/subscriptions/"+ (SubscriptionId==null? "" : Uri.EscapeDataString(SubscriptionId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified user from a Simple AD or Microsoft AD directory.
		/// DeleteUser /api/v1/users/{UserId}
		/// </summary>
		/// <param name="UserId">The ID of the user.</param>
		public async Task DeleteUserAsync(string UserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/users/"+ (UserId==null? "" : Uri.EscapeDataString(UserId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes the user activities in a specified time period.
		/// DescribeActivities /api/v1/activities
		/// </summary>
		/// <param name="startTime">The timestamp that determines the starting time of the activities. The response includes the activities performed after the specified timestamp.</param>
		/// <param name="endTime">The timestamp that determines the end time of the activities. The response includes the activities performed before the specified timestamp.</param>
		/// <param name="organizationId">The ID of the organization. This is a mandatory parameter when using administrative API (SigV4) requests.</param>
		/// <param name="activityTypes">Specifies which activity types to include in the response. If this field is left empty, all activity types are returned.</param>
		/// <param name="resourceId">The document or folder ID for which to describe activity types.</param>
		/// <param name="userId">The ID of the user who performed the action. The response includes activities pertaining to this user. This is an optional parameter and is only applicable for administrative API (SigV4) requests.</param>
		/// <param name="includeIndirectActivities">Includes indirect activities. An indirect activity results from a direct activity performed on a parent resource. For example, sharing a parent folder (the direct activity) shares all of the subfolders and documents within the parent folder (the indirect activity).</param>
		/// <param name="limit">The maximum number of items to return.</param>
		/// <param name="marker">The marker for the next set of results.</param>
		/// <returns>Success</returns>
		public async Task<DescribeActivitiesResponse> DescribeActivitiesAsync(System.DateTimeOffset startTime, System.DateTimeOffset endTime, string organizationId, string activityTypes, string resourceId, string userId, bool includeIndirectActivities, int limit, string marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/activities?startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&organizationId=" + (organizationId==null? "" : Uri.EscapeDataString(organizationId))+"&activityTypes=" + (activityTypes==null? "" : Uri.EscapeDataString(activityTypes))+"&resourceId=" + (resourceId==null? "" : Uri.EscapeDataString(resourceId))+"&userId=" + (userId==null? "" : Uri.EscapeDataString(userId))+"&includeIndirectActivities="+includeIndirectActivities+"&limit="+limit+"&marker=" + (marker==null? "" : Uri.EscapeDataString(marker));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeActivitiesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all the comments for the specified document version.
		/// DescribeComments /api/v1/documents/{DocumentId}/versions/{VersionId}/comments
		/// </summary>
		/// <param name="DocumentId">The ID of the document.</param>
		/// <param name="VersionId">The ID of the document version.</param>
		/// <param name="limit">The maximum number of items to return.</param>
		/// <param name="marker">The marker for the next set of results. This marker was received from a previous call.</param>
		/// <returns>Success</returns>
		public async Task<DescribeCommentsResponse> DescribeCommentsAsync(string DocumentId, string VersionId, int limit, string marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/documents/"+ (DocumentId==null? "" : Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : Uri.EscapeDataString(VersionId))+"/comments&limit="+limit+"&marker=" + (marker==null? "" : Uri.EscapeDataString(marker));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeCommentsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves the document versions for the specified document.</p> <p>By default, only active versions are returned.</p>
		/// DescribeDocumentVersions /api/v1/documents/{DocumentId}/versions
		/// </summary>
		/// <param name="DocumentId">The ID of the document.</param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call.)</param>
		/// <param name="limit">The maximum number of versions to return with this call.</param>
		/// <param name="include">A comma-separated list of values. Specify "INITIALIZED" to include incomplete versions.</param>
		/// <param name="fields">Specify "SOURCE" to include initialized versions and a URL for the source document.</param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeDocumentVersionsResponse> DescribeDocumentVersionsAsync(string DocumentId, string marker, int limit, string include, string fields, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/documents/"+ (DocumentId==null? "" : Uri.EscapeDataString(DocumentId))+"/versions&marker=" + (marker==null? "" : Uri.EscapeDataString(marker))+"&limit="+limit+"&include=" + (include==null? "" : Uri.EscapeDataString(include))+"&fields=" + (fields==null? "" : Uri.EscapeDataString(fields))+"&Limit=" + (Limit==null? "" : Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : Uri.EscapeDataString(Marker));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeDocumentVersionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes the groups specified by the query. Groups are defined by the underlying Active Directory.
		/// DescribeGroups /api/v1/groups#searchQuery
		/// </summary>
		/// <param name="searchQuery">A query to describe groups by group name.</param>
		/// <param name="organizationId">The ID of the organization.</param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call.)</param>
		/// <param name="limit">The maximum number of items to return with this call.</param>
		/// <returns>Success</returns>
		public async Task<DescribeGroupsResponse> DescribeGroupsAsync(string searchQuery, string organizationId, string marker, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/groups#searchQuery?searchQuery=" + (searchQuery==null? "" : Uri.EscapeDataString(searchQuery))+"&organizationId=" + (organizationId==null? "" : Uri.EscapeDataString(organizationId))+"&marker=" + (marker==null? "" : Uri.EscapeDataString(marker))+"&limit="+limit;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeGroupsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Describes the current user's special folders; the <code>RootFolder</code> and the <code>RecycleBin</code>. <code>RootFolder</code> is the root of user's files and folders and <code>RecycleBin</code> is the root of recycled items. This is not a valid action for SigV4 (administrative API) clients.</p> <p>This action requires an authentication token. To get an authentication token, register an application with Amazon WorkDocs. For more information, see <a href="https://docs.aws.amazon.com/workdocs/latest/developerguide/wd-auth-user.html">Authentication and Access Control for User Applications</a> in the <i>Amazon WorkDocs Developer Guide</i>.</p>
		/// DescribeRootFolders /api/v1/me/root#Authentication
		/// </summary>
		/// <param name="limit">The maximum number of items to return.</param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call.)</param>
		/// <returns>Success</returns>
		public async Task<DescribeRootFoldersResponse> DescribeRootFoldersAsync(int limit, string marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/me/root#Authentication?limit="+limit+"&marker=" + (marker==null? "" : Uri.EscapeDataString(marker));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeRootFoldersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves details of the current user for whom the authentication token was generated. This is not a valid action for SigV4 (administrative API) clients.</p> <p>This action requires an authentication token. To get an authentication token, register an application with Amazon WorkDocs. For more information, see <a href="https://docs.aws.amazon.com/workdocs/latest/developerguide/wd-auth-user.html">Authentication and Access Control for User Applications</a> in the <i>Amazon WorkDocs Developer Guide</i>.</p>
		/// GetCurrentUser /api/v1/me#Authentication
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetCurrentUserResponse> GetCurrentUserAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/me#Authentication";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetCurrentUserResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves the path information (the hierarchy from the root folder) for the requested document.</p> <p>By default, Amazon WorkDocs returns a maximum of 100 levels upwards from the requested document and only includes the IDs of the parent folders in the path. You can limit the maximum number of levels. You can also request the names of the parent folders.</p>
		/// GetDocumentPath /api/v1/documents/{DocumentId}/path
		/// </summary>
		/// <param name="DocumentId">The ID of the document.</param>
		/// <param name="limit">The maximum number of levels in the hierarchy to return.</param>
		/// <param name="fields">A comma-separated list of values. Specify <code>NAME</code> to include the names of the parent folders.</param>
		/// <param name="marker">This value is not supported.</param>
		/// <returns>Success</returns>
		public async Task<GetDocumentPathResponse> GetDocumentPathAsync(string DocumentId, int limit, string fields, string marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/documents/"+ (DocumentId==null? "" : Uri.EscapeDataString(DocumentId))+"/path&limit="+limit+"&fields=" + (fields==null? "" : Uri.EscapeDataString(fields))+"&marker=" + (marker==null? "" : Uri.EscapeDataString(marker));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetDocumentPathResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves the path information (the hierarchy from the root folder) for the specified folder.</p> <p>By default, Amazon WorkDocs returns a maximum of 100 levels upwards from the requested folder and only includes the IDs of the parent folders in the path. You can limit the maximum number of levels. You can also request the parent folder names.</p>
		/// GetFolderPath /api/v1/folders/{FolderId}/path
		/// </summary>
		/// <param name="FolderId">The ID of the folder.</param>
		/// <param name="limit">The maximum number of levels in the hierarchy to return.</param>
		/// <param name="fields">A comma-separated list of values. Specify "NAME" to include the names of the parent folders.</param>
		/// <param name="marker">This value is not supported.</param>
		/// <returns>Success</returns>
		public async Task<GetFolderPathResponse> GetFolderPathAsync(string FolderId, int limit, string fields, string marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/folders/"+ (FolderId==null? "" : Uri.EscapeDataString(FolderId))+"/path&limit="+limit+"&fields=" + (fields==null? "" : Uri.EscapeDataString(fields))+"&marker=" + (marker==null? "" : Uri.EscapeDataString(marker));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetFolderPathResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a collection of resources, including folders and documents. The only <code>CollectionType</code> supported is <code>SHARED_WITH_ME</code>.
		/// GetResources /api/v1/resources
		/// </summary>
		/// <param name="userId">The user ID for the resource collection. This is a required field for accessing the API operation using IAM credentials.</param>
		/// <param name="collectionType">The collection type.</param>
		/// <param name="limit">The maximum number of resources to return.</param>
		/// <param name="marker">The marker for the next set of results. This marker was received from a previous call.</param>
		/// <returns>Success</returns>
		public async Task<GetResourcesResponse> GetResourcesAsync(string userId, ResourceCollectionType collectionType, int limit, string marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/resources?userId=" + (userId==null? "" : Uri.EscapeDataString(userId))+"&collectionType=" + collectionType+"&limit="+limit+"&marker=" + (marker==null? "" : Uri.EscapeDataString(marker));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetResourcesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a new document object and version object.</p> <p>The client specifies the parent folder ID and name of the document to upload. The ID is optionally specified when creating a new version of an existing document. This is the first step to upload a document. Next, upload the document to the URL returned from the call, and then call <a>UpdateDocumentVersion</a>.</p> <p>To cancel the document upload, call <a>AbortDocumentVersionUpload</a>.</p>
		/// InitiateDocumentVersionUpload /api/v1/documents
		/// </summary>
		public async Task InitiateDocumentVersionUploadAsync(InitiateDocumentVersionUploadBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/documents";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes the permission for the specified principal from the specified resource.
		/// RemoveResourcePermission /api/v1/resources/{ResourceId}/permissions/{PrincipalId}
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.</param>
		/// <param name="PrincipalId">The principal ID of the resource.</param>
		/// <param name="type">The principal type of the resource.</param>
		public async Task RemoveResourcePermissionAsync(string ResourceId, string PrincipalId, SharePrincipalType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/api/v1/resources/"+ (ResourceId==null? "" : Uri.EscapeDataString(ResourceId))+"/permissions/"+ (PrincipalId==null? "" : Uri.EscapeDataString(PrincipalId))+"&type=" + type;
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AddResourcePermissionsBody
	{
		
		/// <summary>
		/// The users, groups, or organization being granted permission.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SharePrincipal[] Principals { get; set; }
		
		/// <summary>
		/// Set of options which defines notification preferences of given action.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string NotificationOptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateCommentBody
	{
		
		/// <summary>
		/// The ID of the parent comment.
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentId { get; set; }
		
		/// <summary>
		/// The ID of the root comment in the thread.
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ThreadId { get; set; }
		
		/// <summary>
		/// The text of the comment.
		/// Max length: 2048
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(2048, MinimumLength=1)]
		public string Text { get; set; }
		
		/// <summary>
		/// The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateCommentBodyVisibility Visibility { get; set; }
		
		/// <summary>
		/// Set this parameter to TRUE to send an email out to the document collaborators after the comment is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> NotifyCollaborators { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateCommentBodyVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateCustomMetadataBody
	{
		
		/// <summary>
		/// Custom metadata in the form of name-value pairs.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CustomMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateFolderBody
	{
		
		/// <summary>
		/// The name of the new folder.
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the parent folder.
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentFolderId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateLabelsBody
	{
		
		/// <summary>
		/// List of labels to add to the resource.
		/// Maximum items: 20
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public SharedLabel[] Labels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateNotificationSubscriptionBody
	{
		
		/// <summary>
		/// The endpoint to receive the notifications. If the protocol is HTTPS, the endpoint is a URL that begins with <code>https</code>.
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Endpoint { get; set; }
		
		/// <summary>
		/// The protocol to use. The supported value is https, which delivers JSON-encoded messages using HTTPS POST.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateNotificationSubscriptionBodyProtocol Protocol { get; set; }
		
		/// <summary>
		/// The notification type.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateNotificationSubscriptionBodySubscriptionType SubscriptionType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateNotificationSubscriptionBodyProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTPS = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateNotificationSubscriptionBodySubscriptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateUserBody
	{
		
		/// <summary>
		/// The ID of the organization.
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// The login name of the user.
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [\w\-+.]+(@[a-zA-Z0-9.\-]+\.[a-zA-Z]+)?
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string Username { get; set; }
		
		/// <summary>
		/// The email address of the user.
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string EmailAddress { get; set; }
		
		/// <summary>
		/// The given name of the user.
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string GivenName { get; set; }
		
		/// <summary>
		/// The surname of the user.
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string Surname { get; set; }
		
		/// <summary>
		/// The password of the user.
		/// Max length: 32
		/// Min length: 4
		/// Pattern: [\u0020-\u00FF]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=4)]
		public string Password { get; set; }
		
		/// <summary>
		/// The time zone ID of the user.
		/// Max length: 256
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength=1)]
		public string TimeZoneId { get; set; }
		
		/// <summary>
		/// Describes the storage for a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string StorageRule { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class InitiateDocumentVersionUploadBody
	{
		
		/// <summary>
		/// The ID of the document.
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the document.
		/// Max length: 255
		/// Min length: 1
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(255, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// The timestamp when the content of the document was originally created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ContentCreatedTimestamp { get; set; }
		
		/// <summary>
		/// The timestamp when the content of the document was modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ContentModifiedTimestamp { get; set; }
		
		/// <summary>
		/// The content type of the document.
		/// Max length: 128
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ContentType { get; set; }
		
		/// <summary>
		/// The size of the document, in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DocumentSizeInBytes { get; set; }
		
		/// <summary>
		/// The ID of the parent folder.
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string ParentFolderId { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
