//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Represents the output of a <code>CreateApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateApiCacheResponse
	{
		
		/// <summary>
		/// The <code>ApiCache</code> object.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ApiCache ApiCache { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateApiKeyResponse
	{
		
		/// <summary>
		/// <p>Describes an API key.</p> <p>Customers invoke AWS AppSync GraphQL API operations with API keys as an identity mechanism. There are two key versions:</p> <p> <b>da1</b>: This version was introduced at launch in November 2017. These keys always expire after 7 days. Key expiration is managed by Amazon DynamoDB TTL. The keys ceased to be valid after February 21, 2018 and should not be used after that date.</p> <ul> <li> <p> <code>ListApiKeys</code> returns the expiration time in milliseconds.</p> </li> <li> <p> <code>CreateApiKey</code> returns the expiration time in milliseconds.</p> </li> <li> <p> <code>UpdateApiKey</code> is not available for this key version.</p> </li> <li> <p> <code>DeleteApiKey</code> deletes the item from the table.</p> </li> <li> <p>Expiration is stored in Amazon DynamoDB as milliseconds. This results in a bug where keys are not automatically deleted because DynamoDB expects the TTL to be stored in seconds. As a one-time action, we will delete these keys from the table after February 21, 2018.</p> </li> </ul> <p> <b>da2</b>: This version was introduced in February 2018 when AppSync added support to extend key expiration.</p> <ul> <li> <p> <code>ListApiKeys</code> returns the expiration time in seconds.</p> </li> <li> <p> <code>CreateApiKey</code> returns the expiration time in seconds and accepts a user-provided expiration time in seconds.</p> </li> <li> <p> <code>UpdateApiKey</code> returns the expiration time in seconds and accepts a user-provided expiration time in seconds. Key expiration can only be updated while the key has not expired.</p> </li> <li> <p> <code>DeleteApiKey</code> deletes the item from the table.</p> </li> <li> <p>Expiration is stored in Amazon DynamoDB as seconds.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ApiKey ApiKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateDataSourceResponse
	{
		
		/// <summary>
		/// Describes a data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DataSource DataSource { get; set; }
	}
	
	/// <summary>
	/// Describes a Delta Sync configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeltaSyncConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BaseTableTTL { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DeltaSyncTableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DeltaSyncTableTTL { get; set; }
	}
	
	/// <summary>
	/// The authorization config in case the HTTP endpoint requires authorization.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AuthorizationConfig
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AuthorizationConfigAuthorizationType AuthorizationType { get; set; }
		
		/// <summary>
		/// The AWS IAM configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AwsIamConfig AwsIamConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AuthorizationConfigAuthorizationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_IAM = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RelationalDatabaseSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RDS_HTTP_ENDPOINT = 0,
	}
	
	/// <summary>
	/// The Amazon RDS HTTP endpoint configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RdsHttpEndpointConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AwsRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DbClusterIdentifier { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DatabaseName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Schema { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AwsSecretStoreArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateFunctionResponse
	{
		
		/// <summary>
		/// A function is a reusable entity. Multiple functions can be used to compose the resolver logic.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FunctionConfiguration FunctionConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateGraphqlApiResponse
	{
		
		/// <summary>
		/// Describes a GraphQL API.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GraphqlApi GraphqlApi { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum FieldLogLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DefaultAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALLOW = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DENY = 1,
	}
	
	/// <summary>
	/// Describes an additional authentication provider.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AdditionalAuthenticationProvider
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AdditionalAuthenticationProviderAuthenticationType AuthenticationType { get; set; }
		
		/// <summary>
		/// Describes an OpenID Connect configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public OpenIDConnectConfig OpenIDConnectConfig { get; set; }
		
		/// <summary>
		/// Describes an Amazon Cognito user pool configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CognitoUserPoolConfig UserPoolConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AdditionalAuthenticationProviderAuthenticationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_KEY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_IAM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_COGNITO_USER_POOLS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPENID_CONNECT = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateResolverResponse
	{
		
		/// <summary>
		/// Describes a resolver.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Resolver Resolver { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ConflictHandlerType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPTIMISTIC_CONCURRENCY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LAMBDA = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ConflictDetectionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VERSION = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 1,
	}
	
	/// <summary>
	/// The <code>LambdaConflictHandlerConfig</code> object when configuring LAMBDA as the Conflict Handler.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class LambdaConflictHandlerConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string LambdaConflictHandlerArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateTypeResponse
	{
		
		/// <summary>
		/// Describes a type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Type Type { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a <code>GetApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetApiCacheResponse
	{
		
		/// <summary>
		/// The <code>ApiCache</code> object.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ApiCache ApiCache { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetDataSourceResponse
	{
		
		/// <summary>
		/// Describes a data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DataSource DataSource { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetFunctionResponse
	{
		
		/// <summary>
		/// A function is a reusable entity. Multiple functions can be used to compose the resolver logic.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FunctionConfiguration FunctionConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetGraphqlApiResponse
	{
		
		/// <summary>
		/// Describes a GraphQL API.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GraphqlApi GraphqlApi { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetIntrospectionSchemaResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Schema { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetResolverResponse
	{
		
		/// <summary>
		/// Describes a resolver.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Resolver Resolver { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetSchemaCreationStatusResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public GetSchemaCreationStatusResponseStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Details { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GetSchemaCreationStatusResponseStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROCESSING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_APPLICABLE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetTypeResponse
	{
		
		/// <summary>
		/// Describes a type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Type Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListApiKeysResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ApiKey[] ApiKeys { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [\\S]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListDataSourcesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DataSource[] DataSources { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [\\S]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListFunctionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FunctionConfiguration[] Functions { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [\\S]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListGraphqlApisResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public GraphqlApi[] GraphqlApis { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [\\S]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListResolversResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Resolver[] Resolvers { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [\\S]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListResolversByFunctionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Resolver[] Resolvers { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [\\S]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsForResourceResponse
	{
		
		/// <summary>
		/// A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TagMap Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTypesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Type[] Types { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [\\S]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartSchemaCreationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public StartSchemaCreationResponseStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum StartSchemaCreationResponseStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROCESSING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_APPLICABLE = 5,
	}
	
	/// <summary>
	/// Represents the output of a <code>UpdateApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApiCacheResponse
	{
		
		/// <summary>
		/// The <code>ApiCache</code> object.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ApiCache ApiCache { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApiKeyResponse
	{
		
		/// <summary>
		/// <p>Describes an API key.</p> <p>Customers invoke AWS AppSync GraphQL API operations with API keys as an identity mechanism. There are two key versions:</p> <p> <b>da1</b>: This version was introduced at launch in November 2017. These keys always expire after 7 days. Key expiration is managed by Amazon DynamoDB TTL. The keys ceased to be valid after February 21, 2018 and should not be used after that date.</p> <ul> <li> <p> <code>ListApiKeys</code> returns the expiration time in milliseconds.</p> </li> <li> <p> <code>CreateApiKey</code> returns the expiration time in milliseconds.</p> </li> <li> <p> <code>UpdateApiKey</code> is not available for this key version.</p> </li> <li> <p> <code>DeleteApiKey</code> deletes the item from the table.</p> </li> <li> <p>Expiration is stored in Amazon DynamoDB as milliseconds. This results in a bug where keys are not automatically deleted because DynamoDB expects the TTL to be stored in seconds. As a one-time action, we will delete these keys from the table after February 21, 2018.</p> </li> </ul> <p> <b>da2</b>: This version was introduced in February 2018 when AppSync added support to extend key expiration.</p> <ul> <li> <p> <code>ListApiKeys</code> returns the expiration time in seconds.</p> </li> <li> <p> <code>CreateApiKey</code> returns the expiration time in seconds and accepts a user-provided expiration time in seconds.</p> </li> <li> <p> <code>UpdateApiKey</code> returns the expiration time in seconds and accepts a user-provided expiration time in seconds. Key expiration can only be updated while the key has not expired.</p> </li> <li> <p> <code>DeleteApiKey</code> deletes the item from the table.</p> </li> <li> <p>Expiration is stored in Amazon DynamoDB as seconds.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ApiKey ApiKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateDataSourceResponse
	{
		
		/// <summary>
		/// Describes a data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DataSource DataSource { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFunctionResponse
	{
		
		/// <summary>
		/// A function is a reusable entity. Multiple functions can be used to compose the resolver logic.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public FunctionConfiguration FunctionConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateGraphqlApiResponse
	{
		
		/// <summary>
		/// Describes a GraphQL API.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GraphqlApi GraphqlApi { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateResolverResponse
	{
		
		/// <summary>
		/// Describes a resolver.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Resolver Resolver { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateTypeResponse
	{
		
		/// <summary>
		/// Describes a type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Type Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AuthenticationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_KEY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_IAM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_COGNITO_USER_POOLS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPENID_CONNECT = 3,
	}
	
	/// <summary>
	/// Describes an OpenID Connect configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class OpenIDConnectConfig
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Issuer { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IatTTL { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AuthTTL { get; set; }
	}
	
	/// <summary>
	/// Describes an Amazon Cognito user pool configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CognitoUserPoolConfig
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserPoolId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AwsRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AppIdClientRegex { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ApiCachingBehavior
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_REQUEST_CACHING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_RESOLVER_CACHING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ApiCacheType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_SMALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_MEDIUM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_LARGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_XLARGE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_2XLARGE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_4XLARGE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_8XLARGE = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ApiCacheStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVAILABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODIFYING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
	}
	
	/// <summary>
	/// The <code>ApiCache</code> object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ApiCache
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Ttl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ApiCacheApiCachingBehavior ApiCachingBehavior { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> TransitEncryptionEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AtRestEncryptionEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ApiCacheType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ApiCacheStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ApiCacheApiCachingBehavior
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_REQUEST_CACHING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_RESOLVER_CACHING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ApiCacheType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_SMALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_MEDIUM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_LARGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_XLARGE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_2XLARGE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_4XLARGE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_8XLARGE = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ApiCacheStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVAILABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODIFYING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
	}
	
	/// <summary>
	/// <p>Describes an API key.</p> <p>Customers invoke AWS AppSync GraphQL API operations with API keys as an identity mechanism. There are two key versions:</p> <p> <b>da1</b>: This version was introduced at launch in November 2017. These keys always expire after 7 days. Key expiration is managed by Amazon DynamoDB TTL. The keys ceased to be valid after February 21, 2018 and should not be used after that date.</p> <ul> <li> <p> <code>ListApiKeys</code> returns the expiration time in milliseconds.</p> </li> <li> <p> <code>CreateApiKey</code> returns the expiration time in milliseconds.</p> </li> <li> <p> <code>UpdateApiKey</code> is not available for this key version.</p> </li> <li> <p> <code>DeleteApiKey</code> deletes the item from the table.</p> </li> <li> <p>Expiration is stored in Amazon DynamoDB as milliseconds. This results in a bug where keys are not automatically deleted because DynamoDB expects the TTL to be stored in seconds. As a one-time action, we will delete these keys from the table after February 21, 2018.</p> </li> </ul> <p> <b>da2</b>: This version was introduced in February 2018 when AppSync added support to extend key expiration.</p> <ul> <li> <p> <code>ListApiKeys</code> returns the expiration time in seconds.</p> </li> <li> <p> <code>CreateApiKey</code> returns the expiration time in seconds and accepts a user-provided expiration time in seconds.</p> </li> <li> <p> <code>UpdateApiKey</code> returns the expiration time in seconds and accepts a user-provided expiration time in seconds. Key expiration can only be updated while the key has not expired.</p> </li> <li> <p> <code>DeleteApiKey</code> deletes the item from the table.</p> </li> <li> <p>Expiration is stored in Amazon DynamoDB as seconds.</p> </li> </ul>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ApiKey
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Expires { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum AuthorizationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_IAM = 0,
	}
	
	/// <summary>
	/// The AWS IAM configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class AwsIamConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SigningRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SigningServiceName { get; set; }
	}
	
	/// <summary>
	/// The caching configuration for a resolver that has caching enabled.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CachingConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Ttl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public String[] CachingKeys { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>CreateApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateApiCacheRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Ttl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> TransitEncryptionEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AtRestEncryptionEnabled { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateApiCacheRequestApiCachingBehavior ApiCachingBehavior { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateApiCacheRequestType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateApiCacheRequestApiCachingBehavior
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_REQUEST_CACHING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_RESOLVER_CACHING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateApiCacheRequestType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_SMALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_MEDIUM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_LARGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_XLARGE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_2XLARGE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_4XLARGE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_8XLARGE = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateApiKeyRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Expires { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DataSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_LAMBDA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_DYNAMODB = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_ELASTICSEARCH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RELATIONAL_DATABASE = 5,
	}
	
	/// <summary>
	/// Describes an Amazon DynamoDB data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DynamodbDataSourceConfig
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AwsRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UseCallerCredentials { get; set; }
		
		/// <summary>
		/// Describes a Delta Sync configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeltaSyncConfig DeltaSyncConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Versioned { get; set; }
	}
	
	/// <summary>
	/// Describes an AWS Lambda data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class LambdaDataSourceConfig
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string LambdaFunctionArn { get; set; }
	}
	
	/// <summary>
	/// Describes an Elasticsearch data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ElasticsearchDataSourceConfig
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Endpoint { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AwsRegion { get; set; }
	}
	
	/// <summary>
	/// Describes an HTTP data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class HttpDataSourceConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Endpoint { get; set; }
		
		/// <summary>
		/// The authorization config in case the HTTP endpoint requires authorization.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AuthorizationConfig AuthorizationConfig { get; set; }
	}
	
	/// <summary>
	/// Describes a relational database data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class RelationalDatabaseDataSourceConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public RelationalDatabaseDataSourceConfigRelationalDatabaseSourceType RelationalDatabaseSourceType { get; set; }
		
		/// <summary>
		/// The Amazon RDS HTTP endpoint configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RdsHttpEndpointConfig RdsHttpEndpointConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum RelationalDatabaseDataSourceConfigRelationalDatabaseSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RDS_HTTP_ENDPOINT = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateDataSourceRequest
	{
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateDataSourceRequestType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServiceRoleArn { get; set; }
		
		/// <summary>
		/// Describes an Amazon DynamoDB data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DynamodbDataSourceConfig DynamodbConfig { get; set; }
		
		/// <summary>
		/// Describes an AWS Lambda data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LambdaDataSourceConfig LambdaConfig { get; set; }
		
		/// <summary>
		/// Describes an Elasticsearch data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ElasticsearchDataSourceConfig ElasticsearchConfig { get; set; }
		
		/// <summary>
		/// Describes an HTTP data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public HttpDataSourceConfig HttpConfig { get; set; }
		
		/// <summary>
		/// Describes a relational database data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RelationalDatabaseDataSourceConfig RelationalDatabaseConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateDataSourceRequestType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_LAMBDA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_DYNAMODB = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_ELASTICSEARCH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RELATIONAL_DATABASE = 5,
	}
	
	/// <summary>
	/// Describes a data source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DataSource
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string DataSourceArn { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DataSourceType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServiceRoleArn { get; set; }
		
		/// <summary>
		/// Describes an Amazon DynamoDB data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DynamodbDataSourceConfig DynamodbConfig { get; set; }
		
		/// <summary>
		/// Describes an AWS Lambda data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LambdaDataSourceConfig LambdaConfig { get; set; }
		
		/// <summary>
		/// Describes an Elasticsearch data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ElasticsearchDataSourceConfig ElasticsearchConfig { get; set; }
		
		/// <summary>
		/// Describes an HTTP data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public HttpDataSourceConfig HttpConfig { get; set; }
		
		/// <summary>
		/// Describes a relational database data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RelationalDatabaseDataSourceConfig RelationalDatabaseConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DataSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_LAMBDA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_DYNAMODB = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_ELASTICSEARCH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RELATIONAL_DATABASE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateFunctionRequest
	{
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string ResponseMappingTemplate { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FunctionVersion { get; set; }
	}
	
	/// <summary>
	/// A function is a reusable entity. Multiple functions can be used to compose the resolver logic.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class FunctionConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FunctionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FunctionArn { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string ResponseMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FunctionVersion { get; set; }
	}
	
	/// <summary>
	/// The CloudWatch Logs configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class LogConfig
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public LogConfigFieldLogLevel FieldLogLevel { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CloudWatchLogsRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ExcludeVerboseContent { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum LogConfigFieldLogLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 2,
	}
	
	/// <summary>
	/// Describes an Amazon Cognito user pool configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UserPoolConfig
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserPoolId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AwsRegion { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UserPoolConfigDefaultAction DefaultAction { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AppIdClientRegex { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UserPoolConfigDefaultAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALLOW = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DENY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateGraphqlApiRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The CloudWatch Logs configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LogConfig LogConfig { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateGraphqlApiRequestAuthenticationType AuthenticationType { get; set; }
		
		/// <summary>
		/// Describes an Amazon Cognito user pool configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserPoolConfig UserPoolConfig { get; set; }
		
		/// <summary>
		/// Describes an OpenID Connect configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public OpenIDConnectConfig OpenIDConnectConfig { get; set; }
		
		/// <summary>
		/// A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TagMap Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AdditionalAuthenticationProvider[] AdditionalAuthenticationProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> XrayEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateGraphqlApiRequestAuthenticationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_KEY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_IAM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_COGNITO_USER_POOLS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPENID_CONNECT = 3,
	}
	
	/// <summary>
	/// Describes a GraphQL API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GraphqlApi
	{
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GraphqlApiAuthenticationType AuthenticationType { get; set; }
		
		/// <summary>
		/// The CloudWatch Logs configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LogConfig LogConfig { get; set; }
		
		/// <summary>
		/// Describes an Amazon Cognito user pool configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserPoolConfig UserPoolConfig { get; set; }
		
		/// <summary>
		/// Describes an OpenID Connect configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public OpenIDConnectConfig OpenIDConnectConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MapOfStringToString Uris { get; set; }
		
		/// <summary>
		/// A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TagMap Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AdditionalAuthenticationProvider[] AdditionalAuthenticationProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> XrayEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum GraphqlApiAuthenticationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_KEY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_IAM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_COGNITO_USER_POOLS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPENID_CONNECT = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ResolverKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNIT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PIPELINE = 1,
	}
	
	/// <summary>
	/// The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PipelineConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public String[] Functions { get; set; }
	}
	
	/// <summary>
	/// <p>Describes a Sync configuration for a resolver.</p> <p>Contains information on which Conflict Detection as well as Resolution strategy should be performed when the resolver is invoked.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class SyncConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SyncConfigConflictHandler ConflictHandler { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SyncConfigConflictDetection ConflictDetection { get; set; }
		
		/// <summary>
		/// The <code>LambdaConflictHandlerConfig</code> object when configuring LAMBDA as the Conflict Handler.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LambdaConflictHandlerConfig LambdaConflictHandlerConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SyncConfigConflictHandler
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPTIMISTIC_CONCURRENCY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LAMBDA = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMERGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SyncConfigConflictDetection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VERSION = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateResolverRequest
	{
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string FieldName { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string ResponseMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CreateResolverRequestKind Kind { get; set; }
		
		/// <summary>
		/// The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PipelineConfig PipelineConfig { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Contains information on which Conflict Detection as well as Resolution strategy should be performed when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SyncConfig SyncConfig { get; set; }
		
		/// <summary>
		/// The caching configuration for a resolver that has caching enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CachingConfig CachingConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateResolverRequestKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNIT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PIPELINE = 1,
	}
	
	/// <summary>
	/// Describes a resolver.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Resolver
	{
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string TypeName { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string FieldName { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string DataSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResolverArn { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string ResponseMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResolverKind Kind { get; set; }
		
		/// <summary>
		/// The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PipelineConfig PipelineConfig { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Contains information on which Conflict Detection as well as Resolution strategy should be performed when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SyncConfig SyncConfig { get; set; }
		
		/// <summary>
		/// The caching configuration for a resolver that has caching enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CachingConfig CachingConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ResolverKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNIT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PIPELINE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TypeDefinitionFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SDL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateTypeRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Definition { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateTypeRequestFormat Format { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateTypeRequestFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SDL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON = 1,
	}
	
	/// <summary>
	/// Describes a type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Type
	{
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Definition { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TypeFormat Format { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum TypeFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SDL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum OutputType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SDL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum SchemaStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROCESSING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_APPLICABLE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartSchemaCreationRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Definition { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TagMap Tags { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>UpdateApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApiCacheRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Ttl { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateApiCacheRequestApiCachingBehavior ApiCachingBehavior { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateApiCacheRequestType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateApiCacheRequestApiCachingBehavior
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_REQUEST_CACHING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_RESOLVER_CACHING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateApiCacheRequestType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_SMALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_MEDIUM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_LARGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_XLARGE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_2XLARGE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_4XLARGE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_8XLARGE = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApiKeyRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Expires { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateDataSourceRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateDataSourceRequestType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServiceRoleArn { get; set; }
		
		/// <summary>
		/// Describes an Amazon DynamoDB data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DynamodbDataSourceConfig DynamodbConfig { get; set; }
		
		/// <summary>
		/// Describes an AWS Lambda data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LambdaDataSourceConfig LambdaConfig { get; set; }
		
		/// <summary>
		/// Describes an Elasticsearch data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ElasticsearchDataSourceConfig ElasticsearchConfig { get; set; }
		
		/// <summary>
		/// Describes an HTTP data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public HttpDataSourceConfig HttpConfig { get; set; }
		
		/// <summary>
		/// Describes a relational database data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RelationalDatabaseDataSourceConfig RelationalDatabaseConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateDataSourceRequestType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_LAMBDA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_DYNAMODB = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_ELASTICSEARCH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RELATIONAL_DATABASE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFunctionRequest
	{
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string ResponseMappingTemplate { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FunctionVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateGraphqlApiRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The CloudWatch Logs configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LogConfig LogConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateGraphqlApiRequestAuthenticationType AuthenticationType { get; set; }
		
		/// <summary>
		/// Describes an Amazon Cognito user pool configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserPoolConfig UserPoolConfig { get; set; }
		
		/// <summary>
		/// Describes an OpenID Connect configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public OpenIDConnectConfig OpenIDConnectConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AdditionalAuthenticationProvider[] AdditionalAuthenticationProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> XrayEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateGraphqlApiRequestAuthenticationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_KEY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_IAM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_COGNITO_USER_POOLS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPENID_CONNECT = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateResolverRequest
	{
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string ResponseMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateResolverRequestKind Kind { get; set; }
		
		/// <summary>
		/// The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PipelineConfig PipelineConfig { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Contains information on which Conflict Detection as well as Resolution strategy should be performed when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SyncConfig SyncConfig { get; set; }
		
		/// <summary>
		/// The caching configuration for a resolver that has caching enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CachingConfig CachingConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateResolverRequestKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNIT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PIPELINE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateTypeRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Definition { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateTypeRequestFormat Format { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateTypeRequestFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SDL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON = 1,
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Creates a cache for the GraphQL API.
		/// CreateApiCache /v1/apis/{apiId}/ApiCaches
		/// </summary>
		/// <param name="apiId">The GraphQL API Id.</param>
		/// <returns>Success</returns>
		public async Task<CreateApiCacheResponse> CreateApiCacheAsync(string apiId, CreateApiCacheBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/ApiCaches";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateApiCacheResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an <code>ApiCache</code> object.
		/// DeleteApiCache /v1/apis/{apiId}/ApiCaches
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<DeleteApiCacheResponse> DeleteApiCacheAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/ApiCaches";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteApiCacheResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an <code>ApiCache</code> object.
		/// GetApiCache /v1/apis/{apiId}/ApiCaches
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<GetApiCacheResponse> GetApiCacheAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/ApiCaches";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetApiCacheResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a unique key that you can distribute to clients who are executing your API.
		/// CreateApiKey /v1/apis/{apiId}/apikeys
		/// </summary>
		/// <param name="apiId">The ID for your GraphQL API.</param>
		/// <returns>Success</returns>
		public async Task<CreateApiKeyResponse> CreateApiKeyAsync(string apiId, CreateApiKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/apikeys";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateApiKeyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists the API keys for a given API.</p> <note> <p>API keys are deleted automatically sometime after they expire. However, they may still be included in the response until they have actually been deleted. You can safely call <code>DeleteApiKey</code> to manually delete a key before it's automatically deleted.</p> </note>
		/// ListApiKeys /v1/apis/{apiId}/apikeys
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.</param>
		/// <param name="maxResults">The maximum number of results you want the request to return.</param>
		/// <returns>Success</returns>
		public async Task<ListApiKeysResponse> ListApiKeysAsync(string apiId, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/apikeys&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListApiKeysResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a <code>DataSource</code> object.
		/// CreateDataSource /v1/apis/{apiId}/datasources
		/// </summary>
		/// <param name="apiId">The API ID for the GraphQL API for the <code>DataSource</code>.</param>
		/// <returns>Success</returns>
		public async Task<CreateDataSourceResponse> CreateDataSourceAsync(string apiId, CreateDataSourceBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/datasources";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateDataSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the data sources for a given API.
		/// ListDataSources /v1/apis/{apiId}/datasources
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. </param>
		/// <param name="maxResults">The maximum number of results you want the request to return.</param>
		/// <returns>Success</returns>
		public async Task<ListDataSourcesResponse> ListDataSourcesAsync(string apiId, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/datasources&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListDataSourcesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a <code>Function</code> object.</p> <p>A function is a reusable entity. Multiple functions can be used to compose the resolver logic.</p>
		/// CreateFunction /v1/apis/{apiId}/functions
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <returns>Success</returns>
		public async Task<CreateFunctionResponse> CreateFunctionAsync(string apiId, CreateFunctionBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/functions";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateFunctionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List multiple functions.
		/// ListFunctions /v1/apis/{apiId}/functions
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.</param>
		/// <param name="maxResults">The maximum number of results you want the request to return.</param>
		/// <returns>Success</returns>
		public async Task<ListFunctionsResponse> ListFunctionsAsync(string apiId, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/functions&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListFunctionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a <code>GraphqlApi</code> object.
		/// CreateGraphqlApi /v1/apis
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateGraphqlApiResponse> CreateGraphqlApiAsync(CreateGraphqlApiBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists your GraphQL APIs.
		/// ListGraphqlApis /v1/apis
		/// </summary>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. </param>
		/// <param name="maxResults">The maximum number of results you want the request to return.</param>
		/// <returns>Success</returns>
		public async Task<ListGraphqlApisResponse> ListGraphqlApisAsync(string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis?nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListGraphqlApisResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a <code>Resolver</code> object.</p> <p>A resolver converts incoming requests into a format that a data source can understand and converts the data source's responses into GraphQL.</p>
		/// CreateResolver /v1/apis/{apiId}/types/{typeName}/resolvers
		/// </summary>
		/// <param name="apiId">The ID for the GraphQL API for which the resolver is being created.</param>
		/// <param name="typeName">The name of the <code>Type</code>.</param>
		/// <returns>Success</returns>
		public async Task<CreateResolverResponse> CreateResolverAsync(string apiId, string typeName, CreateResolverBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : Uri.EscapeDataString(typeName))+"/resolvers";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateResolverResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the resolvers for a given API and type.
		/// ListResolvers /v1/apis/{apiId}/types/{typeName}/resolvers
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The type name.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. </param>
		/// <param name="maxResults">The maximum number of results you want the request to return.</param>
		/// <returns>Success</returns>
		public async Task<ListResolversResponse> ListResolversAsync(string apiId, string typeName, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : Uri.EscapeDataString(typeName))+"/resolvers&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListResolversResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a <code>Type</code> object.
		/// CreateType /v1/apis/{apiId}/types
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<CreateTypeResponse> CreateTypeAsync(string apiId, CreateTypeBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/types";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateTypeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an API key.
		/// DeleteApiKey /v1/apis/{apiId}/apikeys/{id}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="id">The ID for the API key.</param>
		/// <returns>Success</returns>
		public async Task<DeleteApiKeyResponse> DeleteApiKeyAsync(string apiId, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/apikeys/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteApiKeyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an API key.
		/// UpdateApiKey /v1/apis/{apiId}/apikeys/{id}
		/// </summary>
		/// <param name="apiId">The ID for the GraphQL API.</param>
		/// <param name="id">The API key ID.</param>
		/// <returns>Success</returns>
		public async Task<UpdateApiKeyResponse> UpdateApiKeyAsync(string apiId, string id, UpdateApiKeyBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/apikeys/"+ (id==null? "" : Uri.EscapeDataString(id));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateApiKeyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a <code>DataSource</code> object.
		/// DeleteDataSource /v1/apis/{apiId}/datasources/{name}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="name">The name of the data source.</param>
		/// <returns>Success</returns>
		public async Task<DeleteDataSourceResponse> DeleteDataSourceAsync(string apiId, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/datasources/"+ (name==null? "" : Uri.EscapeDataString(name));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteDataSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a <code>DataSource</code> object.
		/// GetDataSource /v1/apis/{apiId}/datasources/{name}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="name">The name of the data source.</param>
		/// <returns>Success</returns>
		public async Task<GetDataSourceResponse> GetDataSourceAsync(string apiId, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/datasources/"+ (name==null? "" : Uri.EscapeDataString(name));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetDataSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a <code>DataSource</code> object.
		/// UpdateDataSource /v1/apis/{apiId}/datasources/{name}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="name">The new name for the data source.</param>
		/// <returns>Success</returns>
		public async Task<UpdateDataSourceResponse> UpdateDataSourceAsync(string apiId, string name, UpdateDataSourceBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/datasources/"+ (name==null? "" : Uri.EscapeDataString(name));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateDataSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a <code>Function</code>.
		/// DeleteFunction /v1/apis/{apiId}/functions/{functionId}
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <param name="functionId">The <code>Function</code> ID.</param>
		/// <returns>Success</returns>
		public async Task<DeleteFunctionResponse> DeleteFunctionAsync(string apiId, string functionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/functions/"+ (functionId==null? "" : Uri.EscapeDataString(functionId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteFunctionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a <code>Function</code>.
		/// GetFunction /v1/apis/{apiId}/functions/{functionId}
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <param name="functionId">The <code>Function</code> ID.</param>
		/// <returns>Success</returns>
		public async Task<GetFunctionResponse> GetFunctionAsync(string apiId, string functionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/functions/"+ (functionId==null? "" : Uri.EscapeDataString(functionId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetFunctionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a <code>Function</code> object.
		/// UpdateFunction /v1/apis/{apiId}/functions/{functionId}
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <param name="functionId">The function ID.</param>
		/// <returns>Success</returns>
		public async Task<UpdateFunctionResponse> UpdateFunctionAsync(string apiId, string functionId, UpdateFunctionBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/functions/"+ (functionId==null? "" : Uri.EscapeDataString(functionId));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateFunctionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a <code>GraphqlApi</code> object.
		/// DeleteGraphqlApi /v1/apis/{apiId}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<DeleteGraphqlApiResponse> DeleteGraphqlApiAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a <code>GraphqlApi</code> object.
		/// GetGraphqlApi /v1/apis/{apiId}
		/// </summary>
		/// <param name="apiId">The API ID for the GraphQL API.</param>
		/// <returns>Success</returns>
		public async Task<GetGraphqlApiResponse> GetGraphqlApiAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a <code>GraphqlApi</code> object.
		/// UpdateGraphqlApi /v1/apis/{apiId}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<UpdateGraphqlApiResponse> UpdateGraphqlApiAsync(string apiId, UpdateGraphqlApiBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a <code>Resolver</code> object.
		/// DeleteResolver /v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The name of the resolver type.</param>
		/// <param name="fieldName">The resolver field name.</param>
		/// <returns>Success</returns>
		public async Task<DeleteResolverResponse> DeleteResolverAsync(string apiId, string typeName, string fieldName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : Uri.EscapeDataString(typeName))+"/resolvers/"+ (fieldName==null? "" : Uri.EscapeDataString(fieldName));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteResolverResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a <code>Resolver</code> object.
		/// GetResolver /v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The resolver type name.</param>
		/// <param name="fieldName">The resolver field name.</param>
		/// <returns>Success</returns>
		public async Task<GetResolverResponse> GetResolverAsync(string apiId, string typeName, string fieldName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : Uri.EscapeDataString(typeName))+"/resolvers/"+ (fieldName==null? "" : Uri.EscapeDataString(fieldName));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetResolverResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a <code>Resolver</code> object.
		/// UpdateResolver /v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The new type name.</param>
		/// <param name="fieldName">The new field name.</param>
		/// <returns>Success</returns>
		public async Task<UpdateResolverResponse> UpdateResolverAsync(string apiId, string typeName, string fieldName, UpdateResolverBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : Uri.EscapeDataString(typeName))+"/resolvers/"+ (fieldName==null? "" : Uri.EscapeDataString(fieldName));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateResolverResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a <code>Type</code> object.
		/// DeleteType /v1/apis/{apiId}/types/{typeName}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The type name.</param>
		/// <returns>Success</returns>
		public async Task<DeleteTypeResponse> DeleteTypeAsync(string apiId, string typeName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : Uri.EscapeDataString(typeName));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteTypeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a <code>Type</code> object.
		/// UpdateType /v1/apis/{apiId}/types/{typeName}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The new type name.</param>
		/// <returns>Success</returns>
		public async Task<UpdateTypeResponse> UpdateTypeAsync(string apiId, string typeName, UpdateTypeBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : Uri.EscapeDataString(typeName));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateTypeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Flushes an <code>ApiCache</code> object.
		/// FlushApiCache /v1/apis/{apiId}/FlushCache
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<FlushApiCacheResponse> FlushApiCacheAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/FlushCache";
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<FlushApiCacheResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the introspection schema for a GraphQL API.
		/// GetIntrospectionSchema /v1/apis/{apiId}/schema#format
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="format">The schema format: SDL or JSON.</param>
		/// <param name="includeDirectives">A flag that specifies whether the schema introspection should contain directives.</param>
		/// <returns>Success</returns>
		public async Task<GetIntrospectionSchemaResponse> GetIntrospectionSchemaAsync(string apiId, TypeDefinitionFormat format, bool includeDirectives, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/schema#format&format=" + format+"&includeDirectives="+includeDirectives;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetIntrospectionSchemaResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the current status of a schema creation operation.
		/// GetSchemaCreationStatus /v1/apis/{apiId}/schemacreation
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<GetSchemaCreationStatusResponse> GetSchemaCreationStatusAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/schemacreation";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetSchemaCreationStatusResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Adds a new schema to your GraphQL API.</p> <p>This operation is asynchronous. Use to determine when it has completed.</p>
		/// StartSchemaCreation /v1/apis/{apiId}/schemacreation
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<StartSchemaCreationResponse> StartSchemaCreationAsync(string apiId, StartSchemaCreationBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/schemacreation";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<StartSchemaCreationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a <code>Type</code> object.
		/// GetType /v1/apis/{apiId}/types/{typeName}#format
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The type name.</param>
		/// <param name="format">The type format: SDL or JSON.</param>
		/// <returns>Success</returns>
		public async Task<GetTypeResponse> GetTypeAsync(string apiId, string typeName, TypeDefinitionFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : Uri.EscapeDataString(typeName))+"#format&format=" + format;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetTypeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the resolvers that are associated with a specific function.
		/// ListResolversByFunction /v1/apis/{apiId}/functions/{functionId}/resolvers
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="functionId">The Function ID.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.</param>
		/// <param name="maxResults">The maximum number of results you want the request to return.</param>
		/// <returns>Success</returns>
		public async Task<ListResolversByFunctionResponse> ListResolversByFunctionAsync(string apiId, string functionId, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/functions/"+ (functionId==null? "" : Uri.EscapeDataString(functionId))+"/resolvers&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListResolversByFunctionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the tags for a resource.
		/// ListTagsForResource /v1/tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The <code>GraphqlApi</code> ARN.</param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Tags a resource with user-supplied tags.
		/// TagResource /v1/tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The <code>GraphqlApi</code> ARN.</param>
		/// <returns>Success</returns>
		public async Task<TagResourceResponse> TagResourceAsync(string resourceArn, TagResourceBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<TagResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the types for a given API.
		/// ListTypes /v1/apis/{apiId}/types#format
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="format">The type format: SDL or JSON.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. </param>
		/// <param name="maxResults">The maximum number of results you want the request to return.</param>
		/// <returns>Success</returns>
		public async Task<ListTypesResponse> ListTypesAsync(string apiId, TypeDefinitionFormat format, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/types#format&format=" + format+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListTypesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Untags a resource.
		/// UntagResource /v1/tags/{resourceArn}#tagKeys
		/// </summary>
		/// <param name="resourceArn">The <code>GraphqlApi</code> ARN.</param>
		/// <param name="tagKeys">A list of <code>TagKey</code> objects.</param>
		/// <returns>Success</returns>
		public async Task<UntagResourceResponse> UntagResourceAsync(string resourceArn, TagKey[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn))+"#tagKeys&"+String.Join("&", tagKeys.Select(z => $"tagKeys={z}"));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UntagResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the cache for the GraphQL API.
		/// UpdateApiCache /v1/apis/{apiId}/ApiCaches/update
		/// </summary>
		/// <param name="apiId">The GraphQL API Id.</param>
		/// <returns>Success</returns>
		public async Task<UpdateApiCacheResponse> UpdateApiCacheAsync(string apiId, UpdateApiCacheBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/apis/"+ (apiId==null? "" : Uri.EscapeDataString(apiId))+"/ApiCaches/update";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateApiCacheResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateApiCacheBody
	{
		
		/// <summary>
		/// <p>TTL in seconds for cache entries.</p> <p>Valid values are between 1 and 3600 seconds.</p>
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Ttl { get; set; }
		
		/// <summary>
		/// Transit encryption flag when connecting to cache. This setting cannot be updated after creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> TransitEncryptionEnabled { get; set; }
		
		/// <summary>
		/// At rest encryption flag for cache. This setting cannot be updated after creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AtRestEncryptionEnabled { get; set; }
		
		/// <summary>
		/// <p>Caching behavior.</p> <ul> <li> <p> <b>FULL_REQUEST_CACHING</b>: All requests are fully cached.</p> </li> <li> <p> <b>PER_RESOLVER_CACHING</b>: Individual resovlers that you specify are cached.</p> </li> </ul>
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateApiCacheBodyApiCachingBehavior ApiCachingBehavior { get; set; }
		
		/// <summary>
		/// <p>The cache instance type.</p> <ul> <li> <p> <b>T2_SMALL</b>: A t2.small instance type.</p> </li> <li> <p> <b>T2_MEDIUM</b>: A t2.medium instance type.</p> </li> <li> <p> <b>R4_LARGE</b>: A r4.large instance type.</p> </li> <li> <p> <b>R4_XLARGE</b>: A r4.xlarge instance type.</p> </li> <li> <p> <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p> </li> <li> <p> <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p> </li> <li> <p> <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p> </li> </ul>
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateApiCacheBodyType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateApiCacheBodyApiCachingBehavior
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_REQUEST_CACHING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_RESOLVER_CACHING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateApiCacheBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_SMALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_MEDIUM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_LARGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_XLARGE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_2XLARGE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_4XLARGE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_8XLARGE = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateApiKeyBody
	{
		
		/// <summary>
		/// A description of the purpose of the API key.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The time from creation time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour. The default value for this parameter is 7 days from creation time. For more information, see .
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Expires { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateDataSourceBody
	{
		
		/// <summary>
		/// A user-supplied name for the <code>DataSource</code>.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// A description of the <code>DataSource</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The type of the <code>DataSource</code>.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateDataSourceBodyType Type { get; set; }
		
		/// <summary>
		/// The AWS IAM service role ARN for the data source. The system assumes this role when accessing the data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServiceRoleArn { get; set; }
		
		/// <summary>
		/// Describes an Amazon DynamoDB data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DynamodbConfig { get; set; }
		
		/// <summary>
		/// Describes an AWS Lambda data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LambdaConfig { get; set; }
		
		/// <summary>
		/// Describes an Elasticsearch data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ElasticsearchConfig { get; set; }
		
		/// <summary>
		/// Describes an HTTP data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string HttpConfig { get; set; }
		
		/// <summary>
		/// Describes a relational database data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RelationalDatabaseConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateDataSourceBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_LAMBDA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_DYNAMODB = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_ELASTICSEARCH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RELATIONAL_DATABASE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateFunctionBody
	{
		
		/// <summary>
		/// The <code>Function</code> name. The function name does not have to be unique.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// The <code>Function</code> description.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The <code>Function</code> <code>DataSource</code> name.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// The <code>Function</code> request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// The <code>Function</code> response mapping template. 
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string ResponseMappingTemplate { get; set; }
		
		/// <summary>
		/// The <code>version</code> of the request mapping template. Currently the supported value is 2018-05-29. 
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FunctionVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateGraphqlApiBody
	{
		
		/// <summary>
		/// A user-supplied name for the <code>GraphqlApi</code>.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The CloudWatch Logs configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LogConfig { get; set; }
		
		/// <summary>
		/// The authentication type: API key, AWS IAM, OIDC, or Amazon Cognito user pools.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateGraphqlApiBodyAuthenticationType AuthenticationType { get; set; }
		
		/// <summary>
		/// Describes an Amazon Cognito user pool configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserPoolConfig { get; set; }
		
		/// <summary>
		/// Describes an OpenID Connect configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OpenIDConnectConfig { get; set; }
		
		/// <summary>
		/// A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Tags { get; set; }
		
		/// <summary>
		/// A list of additional authentication providers for the <code>GraphqlApi</code> API.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AdditionalAuthenticationProvider[] AdditionalAuthenticationProviders { get; set; }
		
		/// <summary>
		/// A flag indicating whether to enable X-Ray tracing for the <code>GraphqlApi</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> XrayEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateGraphqlApiBodyAuthenticationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_KEY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_IAM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_COGNITO_USER_POOLS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPENID_CONNECT = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateResolverBody
	{
		
		/// <summary>
		/// The name of the field to attach the resolver to.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string FieldName { get; set; }
		
		/// <summary>
		/// The name of the data source for which the resolver is being created.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// <p>The mapping template to be used for requests.</p> <p>A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL).</p>
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// The mapping template to be used for responses from the data source.
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string ResponseMappingTemplate { get; set; }
		
		/// <summary>
		/// <p>The resolver type.</p> <ul> <li> <p> <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is the default resolver type. A UNIT resolver enables you to execute a GraphQL query against a single data source.</p> </li> <li> <p> <b>PIPELINE</b>: A PIPELINE resolver type. A PIPELINE resolver enables you to execute a series of <code>Function</code> in a serial manner. You can use a pipeline resolver to execute a GraphQL query against multiple data sources.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateResolverBodyKind Kind { get; set; }
		
		/// <summary>
		/// The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PipelineConfig { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Contains information on which Conflict Detection as well as Resolution strategy should be performed when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SyncConfig { get; set; }
		
		/// <summary>
		/// The caching configuration for a resolver that has caching enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CachingConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateResolverBodyKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNIT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PIPELINE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateTypeBody
	{
		
		/// <summary>
		/// <p>The type definition, in GraphQL Schema Definition Language (SDL) format.</p> <p>For more information, see the <a href="http://graphql.org/learn/schema/">GraphQL SDL documentation</a>.</p>
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Definition { get; set; }
		
		/// <summary>
		/// The type format: SDL or JSON.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateTypeBodyFormat Format { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateTypeBodyFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SDL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApiKeyBody
	{
		
		/// <summary>
		/// A description of the purpose of the API key.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The time from update time after which the API key expires. The date is represented as seconds since the epoch. For more information, see .
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Expires { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateDataSourceBody
	{
		
		/// <summary>
		/// The new description for the data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The new data source type.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateDataSourceBodyType Type { get; set; }
		
		/// <summary>
		/// The new service role ARN for the data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServiceRoleArn { get; set; }
		
		/// <summary>
		/// Describes an Amazon DynamoDB data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DynamodbConfig { get; set; }
		
		/// <summary>
		/// Describes an AWS Lambda data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LambdaConfig { get; set; }
		
		/// <summary>
		/// Describes an Elasticsearch data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ElasticsearchConfig { get; set; }
		
		/// <summary>
		/// Describes an HTTP data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string HttpConfig { get; set; }
		
		/// <summary>
		/// Describes a relational database data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RelationalDatabaseConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateDataSourceBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_LAMBDA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_DYNAMODB = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_ELASTICSEARCH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RELATIONAL_DATABASE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateFunctionBody
	{
		
		/// <summary>
		/// The <code>Function</code> name.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// The <code>Function</code> description.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// The <code>Function</code> <code>DataSource</code> name.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// The <code>Function</code> request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// The <code>Function</code> request mapping template. 
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string ResponseMappingTemplate { get; set; }
		
		/// <summary>
		/// The <code>version</code> of the request mapping template. Currently the supported value is 2018-05-29. 
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string FunctionVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateGraphqlApiBody
	{
		
		/// <summary>
		/// The new name for the <code>GraphqlApi</code> object.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The CloudWatch Logs configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LogConfig { get; set; }
		
		/// <summary>
		/// The new authentication type for the <code>GraphqlApi</code> object.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateGraphqlApiBodyAuthenticationType AuthenticationType { get; set; }
		
		/// <summary>
		/// Describes an Amazon Cognito user pool configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserPoolConfig { get; set; }
		
		/// <summary>
		/// Describes an OpenID Connect configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OpenIDConnectConfig { get; set; }
		
		/// <summary>
		/// A list of additional authentication providers for the <code>GraphqlApi</code> API.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AdditionalAuthenticationProvider[] AdditionalAuthenticationProviders { get; set; }
		
		/// <summary>
		/// A flag indicating whether to enable X-Ray tracing for the <code>GraphqlApi</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> XrayEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateGraphqlApiBodyAuthenticationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_KEY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_IAM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMAZON_COGNITO_USER_POOLS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPENID_CONNECT = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateResolverBody
	{
		
		/// <summary>
		/// The new data source name.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// The new request mapping template.
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// The new response mapping template.
		/// Max length: 65536
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(65536, MinimumLength=1)]
		public string ResponseMappingTemplate { get; set; }
		
		/// <summary>
		/// <p>The resolver type.</p> <ul> <li> <p> <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is the default resolver type. A UNIT resolver enables you to execute a GraphQL query against a single data source.</p> </li> <li> <p> <b>PIPELINE</b>: A PIPELINE resolver type. A PIPELINE resolver enables you to execute a series of <code>Function</code> in a serial manner. You can use a pipeline resolver to execute a GraphQL query against multiple data sources.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateResolverBodyKind Kind { get; set; }
		
		/// <summary>
		/// The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PipelineConfig { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Contains information on which Conflict Detection as well as Resolution strategy should be performed when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SyncConfig { get; set; }
		
		/// <summary>
		/// The caching configuration for a resolver that has caching enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CachingConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateResolverBodyKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNIT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PIPELINE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateTypeBody
	{
		
		/// <summary>
		/// The new definition.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Definition { get; set; }
		
		/// <summary>
		/// The new type format: SDL or JSON.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateTypeBodyFormat Format { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateTypeBodyFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SDL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StartSchemaCreationBody
	{
		
		/// <summary>
		/// The schema definition, in GraphQL schema language format.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Definition { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceBody
	{
		
		/// <summary>
		/// A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateApiCacheBody
	{
		
		/// <summary>
		/// <p>TTL in seconds for cache entries.</p> <p>Valid values are between 1 and 3600 seconds.</p>
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Ttl { get; set; }
		
		/// <summary>
		/// <p>Caching behavior.</p> <ul> <li> <p> <b>FULL_REQUEST_CACHING</b>: All requests are fully cached.</p> </li> <li> <p> <b>PER_RESOLVER_CACHING</b>: Individual resovlers that you specify are cached.</p> </li> </ul>
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateApiCacheBodyApiCachingBehavior ApiCachingBehavior { get; set; }
		
		/// <summary>
		/// <p>The cache instance type.</p> <ul> <li> <p> <b>T2_SMALL</b>: A t2.small instance type.</p> </li> <li> <p> <b>T2_MEDIUM</b>: A t2.medium instance type.</p> </li> <li> <p> <b>R4_LARGE</b>: A r4.large instance type.</p> </li> <li> <p> <b>R4_XLARGE</b>: A r4.xlarge instance type.</p> </li> <li> <p> <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p> </li> <li> <p> <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p> </li> <li> <p> <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p> </li> </ul>
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateApiCacheBodyType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateApiCacheBodyApiCachingBehavior
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_REQUEST_CACHING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_RESOLVER_CACHING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateApiCacheBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_SMALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2_MEDIUM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_LARGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_XLARGE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_2XLARGE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_4XLARGE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		R4_8XLARGE = 6,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
