//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace My.Demo.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateClusterResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterName { get; set; }
		
		/// <summary>
		/// 
		///            <p>The state of a Kafka cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateClusterResponseState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateClusterResponseState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
	}
	
	/// <summary>
	/// 
	///            <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
	///         <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum BrokerAZDistribution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
	}
	
	/// <summary>
	/// 
	///            <p>Contains information about storage volumes attached to MSK broker nodes.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StorageInfo
	{
		
		/// <summary>
		/// 
		///            <p>Contains information about the EBS storage volumes attached to Kafka broker nodes.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public EBSStorageInfo EbsStorageInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Details for client authentication using TLS.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Tls
	{
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] CertificateAuthorityArnList { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The data-volume encryption details.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EncryptionAtRest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DataVolumeKMSKeyId { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The settings for encrypting data in transit.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EncryptionInTransit
	{
		
		/// <summary>
		/// 
		///            <p>Client-broker encryption in transit setting.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInTransitClientBroker ClientBroker { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> InCluster { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum EncryptionInTransitClientBroker
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS_PLAINTEXT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PLAINTEXT = 2,
	}
	
	/// <summary>
	/// 
	///            <p>Prometheus settings.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class PrometheusInfo
	{
		
		/// <summary>
		/// 
		///            <p>Indicates whether you want to enable or disable the JMX Exporter.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public JmxExporterInfo JmxExporter { get; set; }
		
		/// <summary>
		/// 
		///            <p>Indicates whether you want to enable or disable the Node Exporter.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NodeExporterInfo NodeExporter { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BrokerLogs
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CloudWatchLogs CloudWatchLogs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Firehose Firehose { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public S3 S3 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationTime { get; set; }
		
		/// <summary>
		/// 
		///            <p>Describes a configuration revision.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationRevision LatestRevision { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DeleteClusterResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		/// <summary>
		/// 
		///            <p>The state of a Kafka cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeleteClusterResponseState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum DeleteClusterResponseState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeClusterResponse
	{
		
		/// <summary>
		/// 
		///            <p>Returns information about a cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ClusterInfo ClusterInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeClusterOperationResponse
	{
		
		/// <summary>
		/// 
		///            <p>Returns information about a cluster operation.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationInfo ClusterOperationInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] KafkaVersions { get; set; }
		
		/// <summary>
		/// 
		///            <p>Describes a configuration revision.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationRevision LatestRevision { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class DescribeConfigurationRevisionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Revision { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServerProperties { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetBootstrapBrokersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerString { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerStringTls { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class GetCompatibleKafkaVersionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CompatibleKafkaVersion[] CompatibleKafkaVersions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListClusterOperationsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationInfo[] ClusterOperationInfoList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListClustersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterInfo[] ClusterInfoList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListConfigurationRevisionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationRevision[] Revisions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListConfigurationsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Configuration[] Configurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListKafkaVersionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public KafkaVersion[] KafkaVersions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListNodesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public NodeInfo[] NodeInfoList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateBrokerCountResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateBrokerStorageResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Specifies the EBS volume upgrade information. The broker identifier must be set to the keyword ALL. This means the changes apply to all the brokers in the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BrokerEBSVolumeInfo
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string KafkaBrokerNodeId { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int VolumeSizeGB { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateClusterConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateClusterKafkaVersionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateMonitoringResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CloudWatchLogs
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LogGroup { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Firehose
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string DeliveryStream { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class S3
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Bucket { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Prefix { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Describes the setup to be used for Kafka broker nodes in the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BrokerNodeGroupInfo
	{
		
		/// <summary>
		/// 
		///            <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
		///         <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BrokerNodeGroupInfoBrokerAZDistribution BrokerAZDistribution { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__string[] ClientSubnets { get; set; }
		
		/// <summary>
		/// Max length: 32
		/// Min length: 5
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(32, MinimumLength=5)]
		public string InstanceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] SecurityGroups { get; set; }
		
		/// <summary>
		/// 
		///            <p>Contains information about storage volumes attached to MSK broker nodes.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public StorageInfo StorageInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum BrokerNodeGroupInfoBrokerAZDistribution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
	}
	
	/// <summary>
	/// 
	///            <p>Information about the current software installed on the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BrokerSoftwareInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ConfigurationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ConfigurationRevision { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KafkaVersion { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>BrokerNodeInfo</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class BrokerNodeInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AttachedENIId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> BrokerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientSubnet { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientVpcIpAddress { get; set; }
		
		/// <summary>
		/// 
		///            <p>Information about the current software installed on the cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BrokerSoftwareInfo CurrentBrokerSoftwareInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] Endpoints { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Includes all client authentication information.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ClientAuthentication
	{
		
		/// <summary>
		/// 
		///            <p>Details for client authentication using TLS.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Tls Tls { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Client-broker encryption in transit setting.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ClientBroker
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS_PLAINTEXT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PLAINTEXT = 2,
	}
	
	/// <summary>
	/// 
	///            <p>Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EncryptionInfo
	{
		
		/// <summary>
		/// 
		///            <p>The data-volume encryption details.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public EncryptionAtRest EncryptionAtRest { get; set; }
		
		/// <summary>
		/// 
		///            <p>The settings for encrypting data in transit.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInTransit EncryptionInTransit { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Specifies which metrics are gathered for the MSK cluster. This property has three possible values: DEFAULT, PER_BROKER, and PER_TOPIC_PER_BROKER. For a list of the metrics associated with each of these three levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum EnhancedMonitoring
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_BROKER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_TOPIC_PER_BROKER = 2,
	}
	
	/// <summary>
	/// 
	///            <p>JMX and Node monitoring for the MSK cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class OpenMonitoring
	{
		
		/// <summary>
		/// 
		///            <p>Prometheus settings.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Prometheus Prometheus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class LoggingInfo
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BrokerLogs BrokerLogs { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The state of a Kafka cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ClusterState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class StateInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about a cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ClusterInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ActiveOperationArn { get; set; }
		
		/// <summary>
		/// 
		///            <p>Describes the setup to be used for Kafka broker nodes in the cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BrokerNodeGroupInfo BrokerNodeGroupInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Includes all client authentication information.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ClientAuthentication ClientAuthentication { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationTime { get; set; }
		
		/// <summary>
		/// 
		///            <p>Information about the current software installed on the cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BrokerSoftwareInfo CurrentBrokerSoftwareInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInfo EncryptionInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies which metrics are gathered for the MSK cluster. This property has three possible values: DEFAULT, PER_BROKER, and PER_TOPIC_PER_BROKER. For a list of the metrics associated with each of these three levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ClusterInfoEnhancedMonitoring EnhancedMonitoring { get; set; }
		
		/// <summary>
		/// 
		///            <p>JMX and Node monitoring for the MSK cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoring OpenMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NumberOfBrokerNodes { get; set; }
		
		/// <summary>
		/// 
		///            <p>The state of a Kafka cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ClusterInfoState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StateInfo StateInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ZookeeperConnectString { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ClusterInfoEnhancedMonitoring
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_BROKER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_TOPIC_PER_BROKER = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum ClusterInfoState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about an error state of the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ErrorInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorString { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Information about cluster attributes that can be updated via update APIs.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class MutableClusterInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerEBSVolumeInfo[] BrokerEBSVolumeInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies the configuration to use for the brokers.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationInfo ConfigurationInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NumberOfBrokerNodes { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies which metrics are gathered for the MSK cluster. This property has three possible values: DEFAULT, PER_BROKER, and PER_TOPIC_PER_BROKER. For a list of the metrics associated with each of these three levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MutableClusterInfoEnhancedMonitoring EnhancedMonitoring { get; set; }
		
		/// <summary>
		/// 
		///            <p>JMX and Node monitoring for the MSK cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoring OpenMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KafkaVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum MutableClusterInfoEnhancedMonitoring
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_BROKER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_TOPIC_PER_BROKER = 2,
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about a cluster operation.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ClusterOperationInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		/// <summary>
		/// 
		///            <p>Returns information about an error state of the cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ErrorInfo ErrorInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationStep[] OperationSteps { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationType { get; set; }
		
		/// <summary>
		/// 
		///            <p>Information about cluster attributes that can be updated via update APIs.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MutableClusterInfo SourceClusterInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Information about cluster attributes that can be updated via update APIs.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MutableClusterInfo TargetClusterInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>State information about the operation step.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ClusterOperationStepInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string StepStatus { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Step taken during a cluster operation.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ClusterOperationStep
	{
		
		/// <summary>
		/// 
		///            <p>State information about the operation step.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationStepInfo StepInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StepName { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Contains source Kafka versions and compatible target Kafka versions.</p>
	///        
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CompatibleKafkaVersion
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] TargetVersions { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Describes a configuration revision.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ConfigurationRevision
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Revision { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Represents an MSK Configuration.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Configuration
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__string[] KafkaVersions { get; set; }
		
		/// <summary>
		/// 
		///            <p>Describes a configuration revision.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationRevision LatestRevision { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Specifies the configuration to use for the brokers.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ConfigurationInfo
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Revision { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>JMX and Node monitoring for the MSK cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class OpenMonitoringInfo
	{
		
		/// <summary>
		/// 
		///            <p>Prometheus settings.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PrometheusInfo Prometheus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateClusterRequest
	{
		
		/// <summary>
		/// 
		///            <p>Describes the setup to be used for Kafka broker nodes in the cluster.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BrokerNodeGroupInfo BrokerNodeGroupInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Includes all client authentication information.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ClientAuthentication ClientAuthentication { get; set; }
		
		/// <summary>
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string ClusterName { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies the configuration to use for the brokers.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationInfo ConfigurationInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInfo EncryptionInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies which metrics are gathered for the MSK cluster. This property has three possible values: DEFAULT, PER_BROKER, and PER_TOPIC_PER_BROKER. For a list of the metrics associated with each of these three levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateClusterRequestEnhancedMonitoring EnhancedMonitoring { get; set; }
		
		/// <summary>
		/// 
		///            <p>JMX and Node monitoring for the MSK cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoringInfo OpenMonitoring { get; set; }
		
		/// <summary>
		/// Max length: 128
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string KafkaVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 15
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 15)]
		public int NumberOfBrokerNodes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateClusterRequestEnhancedMonitoring
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_BROKER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_TOPIC_PER_BROKER = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateConfigurationRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] KafkaVersions { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerProperties { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Contains information about the EBS storage volumes attached to Kafka broker nodes.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class EBSStorageInfo
	{
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 16384
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 16384)]
		public System.Nullable<System.Int32> VolumeSize { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum KafkaVersionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class KafkaVersion
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KafkaVersionStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum KafkaVersionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED = 1,
	}
	
	/// <summary>
	/// 
	///            <p>Indicates whether you want to enable or disable the Node Exporter.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class NodeExporter
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EnabledInBroker { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Indicates whether you want to enable or disable the Node Exporter.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class NodeExporterInfo
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EnabledInBroker { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Indicates whether you want to enable or disable the JMX Exporter.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class JmxExporter
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EnabledInBroker { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Indicates whether you want to enable or disable the JMX Exporter.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class JmxExporterInfo
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EnabledInBroker { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Prometheus settings.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class Prometheus
	{
		
		/// <summary>
		/// 
		///            <p>Indicates whether you want to enable or disable the JMX Exporter.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public JmxExporter JmxExporter { get; set; }
		
		/// <summary>
		/// 
		///            <p>Indicates whether you want to enable or disable the Node Exporter.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NodeExporter NodeExporter { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The broker or Zookeeper node.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum NodeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BROKER = 0,
	}
	
	/// <summary>
	/// 
	///            <p>Zookeeper node information.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class ZookeeperNodeInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AttachedENIId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientVpcIpAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__string[] Endpoints { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ZookeeperId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ZookeeperVersion { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The node information object.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class NodeInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AddedToClusterTime { get; set; }
		
		/// <summary>
		/// 
		///            <p>BrokerNodeInfo</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BrokerNodeInfo BrokerNodeInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string InstanceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NodeARN { get; set; }
		
		/// <summary>
		/// 
		///            <p>The broker or Zookeeper node.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NodeInfoNodeType NodeType { get; set; }
		
		/// <summary>
		/// 
		///            <p>Zookeeper node information.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ZookeeperNodeInfo ZookeeperNodeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum NodeInfoNodeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BROKER = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateBrokerCountRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// Maximum: 15
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 15)]
		public int TargetNumberOfBrokerNodes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateBrokerStorageRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BrokerEBSVolumeInfo[] TargetBrokerEBSVolumeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateClusterConfigurationRequest
	{
		
		/// <summary>
		/// 
		///            <p>Specifies the configuration to use for the brokers.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationInfo ConfigurationInfo { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateClusterKafkaVersionRequest
	{
		
		/// <summary>
		/// 
		///            <p>Specifies the configuration to use for the brokers.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationInfo ConfigurationInfo { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TargetKafkaVersion { get; set; }
	}
	
	/// <summary>
	/// Request body for UpdateMonitoring.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateMonitoringRequest
	{
		
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies which metrics are gathered for the MSK cluster. This property has three possible values: DEFAULT, PER_BROKER, and PER_TOPIC_PER_BROKER. For a list of the metrics associated with each of these three levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateMonitoringRequestEnhancedMonitoring EnhancedMonitoring { get; set; }
		
		/// <summary>
		/// 
		///            <p>JMX and Node monitoring for the MSK cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoringInfo OpenMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateMonitoringRequestEnhancedMonitoring
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_BROKER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_TOPIC_PER_BROKER = 2,
	}
	
	public partial class DemoClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public DemoClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// 
		/// <p>Creates a new MSK cluster.</p>
		/// 
		/// CreateCluster /v1/clusters
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateClusterResponse> CreateClusterAsync(CreateClusterBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateClusterResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the MSK clusters in the current Region.</p>
		/// 
		/// ListClusters /v1/clusters
		/// </summary>
		/// <param name="clusterNameFilter">
		///            <p>Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListClustersResponse> ListClustersAsync(string clusterNameFilter, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters?clusterNameFilter=" + (clusterNameFilter==null? "" : Uri.EscapeDataString(clusterNameFilter))+"&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListClustersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Creates a new MSK configuration.</p>
		/// 
		/// CreateConfiguration /v1/configurations
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateConfigurationResponse> CreateConfigurationAsync(CreateConfigurationBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/configurations";
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<CreateConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the MSK configurations in this Region.</p>
		/// 
		/// ListConfigurations /v1/configurations
		/// </summary>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListConfigurationsResponse> ListConfigurationsAsync(int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/configurations?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListConfigurationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Deletes the MSK cluster specified by the Amazon Resource Name (ARN) in the request.</p>
		/// 
		/// DeleteCluster /v1/clusters/{clusterArn}
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <param name="currentVersion">
		///            <p>The current version of the MSK cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DeleteClusterResponse> DeleteClusterAsync(string clusterArn, string currentVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters/"+ (clusterArn==null? "" : Uri.EscapeDataString(clusterArn))+"&currentVersion=" + (currentVersion==null? "" : Uri.EscapeDataString(currentVersion));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DeleteClusterResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of the MSK cluster whose Amazon Resource Name (ARN) is specified in the request.</p>
		/// 
		/// DescribeCluster /v1/clusters/{clusterArn}
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DescribeClusterResponse> DescribeClusterAsync(string clusterArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters/"+ (clusterArn==null? "" : Uri.EscapeDataString(clusterArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeClusterResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of the cluster operation specified by the ARN.</p>
		/// 
		/// DescribeClusterOperation /v1/operations/{clusterOperationArn}
		/// </summary>
		/// <param name="clusterOperationArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster operation.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DescribeClusterOperationResponse> DescribeClusterOperationAsync(string clusterOperationArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/operations/"+ (clusterOperationArn==null? "" : Uri.EscapeDataString(clusterOperationArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeClusterOperationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of this MSK configuration.</p>
		/// 
		/// DescribeConfiguration /v1/configurations/{arn}
		/// </summary>
		/// <param name="arn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DescribeConfigurationResponse> DescribeConfigurationAsync(string arn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/configurations/"+ (arn==null? "" : Uri.EscapeDataString(arn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of this revision of the configuration.</p>
		/// 
		/// DescribeConfigurationRevision /v1/configurations/{arn}/revisions/{revision}
		/// </summary>
		/// <param name="arn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
		///         </param>
		/// <param name="revision">
		///            <p>A string that uniquely identifies a revision of an MSK configuration.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DescribeConfigurationRevisionResponse> DescribeConfigurationRevisionAsync(string arn, int revision, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/configurations/"+ (arn==null? "" : Uri.EscapeDataString(arn))+"/revisions/"+revision;
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DescribeConfigurationRevisionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>A list of brokers that a client application can use to bootstrap.</p>
		/// 
		/// GetBootstrapBrokers /v1/clusters/{clusterArn}/bootstrap-brokers
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<GetBootstrapBrokersResponse> GetBootstrapBrokersAsync(string clusterArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters/"+ (clusterArn==null? "" : Uri.EscapeDataString(clusterArn))+"/bootstrap-brokers";
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetBootstrapBrokersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Gets the Apache Kafka versions to which you can update the MSK cluster.</p>
		/// 
		/// GetCompatibleKafkaVersions /v1/compatible-kafka-versions
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster check.</p>
		///            </param>
		/// <returns>Success</returns>
		public async Task<GetCompatibleKafkaVersionsResponse> GetCompatibleKafkaVersionsAsync(string clusterArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/compatible-kafka-versions?clusterArn=" + (clusterArn==null? "" : Uri.EscapeDataString(clusterArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GetCompatibleKafkaVersionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the operations that have been performed on the specified MSK cluster.</p>
		/// 
		/// ListClusterOperations /v1/clusters/{clusterArn}/operations
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListClusterOperationsResponse> ListClusterOperationsAsync(string clusterArn, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters/"+ (clusterArn==null? "" : Uri.EscapeDataString(clusterArn))+"/operations&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListClusterOperationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the MSK configurations in this Region.</p>
		/// 
		/// ListConfigurationRevisions /v1/configurations/{arn}/revisions
		/// </summary>
		/// <param name="arn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListConfigurationRevisionsResponse> ListConfigurationRevisionsAsync(string arn, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/configurations/"+ (arn==null? "" : Uri.EscapeDataString(arn))+"/revisions&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListConfigurationRevisionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of Kafka versions.</p>
		/// 
		/// ListKafkaVersions /v1/kafka-versions
		/// </summary>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p></param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.</p></param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListKafkaVersionsResponse> ListKafkaVersionsAsync(int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/kafka-versions?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListKafkaVersionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of the broker nodes in the cluster.</p>
		/// 
		/// ListNodes /v1/clusters/{clusterArn}/nodes
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListNodesResponse> ListNodesAsync(string clusterArn, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters/"+ (clusterArn==null? "" : Uri.EscapeDataString(clusterArn))+"/nodes&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : Uri.EscapeDataString(NextToken));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListNodesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of the tags associated with the specified resource.</p>
		/// 
		/// ListTagsForResource /v1/tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Adds tags to the specified MSK resource.</p>
		/// 
		/// TagResource /v1/tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
		///         </param>
		public async Task TagResourceAsync(string resourceArn, TagResourceBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn));
			using (var request = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Removes the tags associated with the keys that are provided in the query.</p>
		/// 
		/// UntagResource /v1/tags/{resourceArn}#tagKeys
		/// </summary>
		/// <param name="resourceArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
		///         </param>
		/// <param name="tagKeys">
		///            <p>Tag keys must be unique for a given cluster. In addition, the following restrictions apply:</p>
		///            <ul>
		///               <li>
		///                  <p>Each tag key must be unique. If you add a tag with a key that's already in
		///                  use, your new tag overwrites the existing key-value pair. </p>
		///               </li>
		///               <li>
		///                  <p>You can't start a tag key with aws: because this prefix is reserved for use
		///                  by  AWS.  AWS creates tags that begin with this prefix on your behalf, but
		///                  you can't edit or delete them.</p>
		///               </li>
		///               <li>
		///                  <p>Tag keys must be between 1 and 128 Unicode characters in length.</p>
		///               </li>
		///               <li>
		///                  <p>Tag keys must consist of the following characters: Unicode letters, digits,
		///                  white space, and the following special characters: _ . / = + -
		///                     @.</p>
		///               </li>
		///            </ul>
		///         </param>
		public async Task UntagResourceAsync(string resourceArn, @__string[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/tags/"+ (resourceArn==null? "" : Uri.EscapeDataString(resourceArn))+"#tagKeys&"+String.Join("&", tagKeys.Select(z => $"tagKeys={z}"));
			using (var request = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the number of broker nodes in the cluster.</p>
		/// 
		/// UpdateBrokerCount /v1/clusters/{clusterArn}/nodes/count
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateBrokerCountResponse> UpdateBrokerCountAsync(string clusterArn, UpdateBrokerCountBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters/"+ (clusterArn==null? "" : Uri.EscapeDataString(clusterArn))+"/nodes/count";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateBrokerCountResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the EBS storage associated with MSK brokers.</p>
		/// 
		/// UpdateBrokerStorage /v1/clusters/{clusterArn}/nodes/storage
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateBrokerStorageResponse> UpdateBrokerStorageAsync(string clusterArn, UpdateBrokerStorageBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters/"+ (clusterArn==null? "" : Uri.EscapeDataString(clusterArn))+"/nodes/storage";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateBrokerStorageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the cluster with the configuration that is specified in the request body.</p>
		/// 
		/// UpdateClusterConfiguration /v1/clusters/{clusterArn}/configuration
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateClusterConfigurationResponse> UpdateClusterConfigurationAsync(string clusterArn, UpdateClusterConfigurationBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters/"+ (clusterArn==null? "" : Uri.EscapeDataString(clusterArn))+"/configuration";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateClusterConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the Apache Kafka version for the cluster.</p>
		/// 
		/// UpdateClusterKafkaVersion /v1/clusters/{clusterArn}/version
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
		///            </param>
		/// <returns>Success</returns>
		public async Task<UpdateClusterKafkaVersionResponse> UpdateClusterKafkaVersionAsync(string clusterArn, UpdateClusterKafkaVersionBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters/"+ (clusterArn==null? "" : Uri.EscapeDataString(clusterArn))+"/version";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateClusterKafkaVersionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the monitoring settings for the cluster. You can use this operation to specify which Apache Kafka metrics you want Amazon MSK to send to Amazon CloudWatch. You can also specify settings for open monitoring with Prometheus.</p>
		/// 
		/// UpdateMonitoring /v1/clusters/{clusterArn}/monitoring
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateMonitoringResponse> UpdateMonitoringAsync(string clusterArn, UpdateMonitoringBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "/v1/clusters/"+ (clusterArn==null? "" : Uri.EscapeDataString(clusterArn))+"/monitoring";
			using (var request = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			request.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(request.Headers);
			}

			var responseMessage = await client.SendAsync(request);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpdateMonitoringResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateClusterBody
	{
		
		/// <summary>
		/// 
		///            <p>Describes the setup to be used for Kafka broker nodes in the cluster.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BrokerNodeGroupInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Includes all client authentication information.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ClientAuthentication { get; set; }
		
		/// <summary>
		/// 
		///            <p>The name of the cluster.</p>
		///         
		/// Max length: 64
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(64, MinimumLength=1)]
		public string ClusterName { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies the configuration to use for the brokers.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ConfigurationInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string EncryptionInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies which metrics are gathered for the MSK cluster. This property has three possible values: DEFAULT, PER_BROKER, and PER_TOPIC_PER_BROKER. For a list of the metrics associated with each of these three levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateClusterBodyEnhancedMonitoring EnhancedMonitoring { get; set; }
		
		/// <summary>
		/// 
		///            <p>JMX and Node monitoring for the MSK cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OpenMonitoring { get; set; }
		
		/// <summary>
		/// 
		///            <p>The version of Apache Kafka.</p>
		///         
		/// Max length: 128
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength=1)]
		public string KafkaVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LoggingInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>The number of broker nodes in the cluster.</p>
		///         
		/// Minimum: 1
		/// Maximum: 15
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 15)]
		public int NumberOfBrokerNodes { get; set; }
		
		/// <summary>
		/// 
		///            <p>Create tags when creating the cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum CreateClusterBodyEnhancedMonitoring
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_BROKER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_TOPIC_PER_BROKER = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class CreateConfigurationBody
	{
		
		/// <summary>
		/// 
		///            <p>The description of the configuration.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// 
		///            <p>The versions of Apache Kafka with which you can use this MSK configuration.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public @__string[] KafkaVersions { get; set; }
		
		/// <summary>
		/// 
		///            <p>The name of the configuration.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// 
		///            <p>Contents of the <filename>server.properties</filename> file. When using the API, you must ensure that the contents of the file are base64 encoded. 
		///               When using the AWS Management Console, the SDK, or the AWS CLI, the contents of <filename>server.properties</filename> can be in plaintext.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerProperties { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class TagResourceBody
	{
		
		/// <summary>
		/// 
		///            <p>The key-value pair for the resource tag.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateBrokerCountBody
	{
		
		/// <summary>
		/// 
		///            <p>The version of cluster to update from. A successful operation will then generate a new version.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>The number of broker nodes that you want the cluster to have after this operation completes successfully.</p>
		///         
		/// Minimum: 1
		/// Maximum: 15
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 15)]
		public int TargetNumberOfBrokerNodes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateBrokerStorageBody
	{
		
		/// <summary>
		/// 
		///            <p>The version of cluster to update from. A successful operation will then generate a new version.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>Describes the target volume size and the ID of the broker to apply the update to.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BrokerEBSVolumeInfo[] TargetBrokerEBSVolumeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateClusterConfigurationBody
	{
		
		/// <summary>
		/// 
		///            <p>Specifies the configuration to use for the brokers.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConfigurationInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>The version of the cluster that needs to be updated.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateClusterKafkaVersionBody
	{
		
		/// <summary>
		/// 
		///            <p>Specifies the configuration to use for the brokers.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ConfigurationInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Current cluster version.</p>
		///            
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>Target Kafka version.</p>
		///            
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TargetKafkaVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public class UpdateMonitoringBody
	{
		
		/// <summary>
		/// 
		///            <p>The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.</p>
		///         
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies which metrics are gathered for the MSK cluster. This property has three possible values: DEFAULT, PER_BROKER, and PER_TOPIC_PER_BROKER. For a list of the metrics associated with each of these three levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateMonitoringBodyEnhancedMonitoring EnhancedMonitoring { get; set; }
		
		/// <summary>
		/// 
		///            <p>JMX and Node monitoring for the MSK cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OpenMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LoggingInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Name="http://demo.domain/2020/03")]
	public enum UpdateMonitoringBodyEnhancedMonitoring
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_BROKER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_TOPIC_PER_BROKER = 2,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
